{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"generative song lyrics Documentation Source Code lyrics is a project for using Recurrent Neural Networks to generate song lyrics inspired by tensorflow-rnn-shakespeare Installation \u00b6 You're going to need tensorflow-gpu==1.12 (old). this project is intended to use an old GPU (GTX 650 compute capability=3.0) which is not officially supported by tensorflow, so compile tensorflow from source first. some notable tensorflow dependencies: nvidia-driver-390 cuda=9.0 cuDNN=7.7 nccl==2.2 create a virtual environment \u00b6 python -m virtualenv venv source venv/bin/activate install dependencies \u00b6 python -m pip install pkg/tensorflow-1.12.0-cp36-cp36m-linux_x86_64.whl cd src/recurrent python -m pip install -r requirements.txt python setup.py setup.py install cd src/grapheme2phoneme/grapheme2phoneme python -m pip install -r requirements.txt python -m nltk.downloader cmudict python setup.py develop Usage: \u00b6 source venv/bin/activate python rnn_train.py trains a language model on a directory of txt files (song lyrics or otherwise). tensorboard --logdir=config.log_dir rnn_train.py** is set up to save training and validation data as \"Tensorboard sumaries\" in the \"log\" folder. They can be visualised with Tensorboard. python rnn_play.py uses a trained snapshot (saved to checkpoints folder) to generate a new text. You can also generate new \"Tensorflow Python\" code. See comments in the file. Tests \u00b6 python setup.py install python -m pytest generated Beatles \u00b6 Well, it's a long with you I'm so slad at's time And I'm going to love you any old way [Verse 1] Got a good roasing for the day, the world If the sun you stile, hame whit me day I want to be your lover baby I want to be your man [Verse 2] Love you all the time I'clld so lave you while ever day I said, I love you And I'm always thinking of you Oh, oh, oh You treat me badly I love you madly You've really got a hold on me You've really got a hold on me, baby [Chorus] You've really got a hold on me DOoh, some insurance on me, baby Well, if you ever, ever say goodbye I'm gonna go right home and die Oh, if you want me, baby You've gotta come to me Mm honey Baby sawk home Seeks nowhing what sometnd cauld be baunt Nowhere man come your made yeah [Verse 2] The dud as aheit Is going to set you through Come on, pastencco in in nowhere, pain ag the haie You can stop theme soresede Who wan sun you know the walrus und Her lajj, don't you tell me why con't you tell me what you see It is no surprise now, what you see is me Contributing \u00b6 Pull requests are welcome. Requirements \u00b6 Python 3.6+ Installation \u00b6 pip install lyrics License \u00b6 This project is licensed under the terms of the MIT license.","title":"Lyrics"},{"location":"#installation","text":"You're going to need tensorflow-gpu==1.12 (old). this project is intended to use an old GPU (GTX 650 compute capability=3.0) which is not officially supported by tensorflow, so compile tensorflow from source first. some notable tensorflow dependencies: nvidia-driver-390 cuda=9.0 cuDNN=7.7 nccl==2.2","title":"Installation"},{"location":"#create-a-virtual-environment","text":"python -m virtualenv venv source venv/bin/activate","title":"create a virtual environment"},{"location":"#install-dependencies","text":"python -m pip install pkg/tensorflow-1.12.0-cp36-cp36m-linux_x86_64.whl cd src/recurrent python -m pip install -r requirements.txt python setup.py setup.py install cd src/grapheme2phoneme/grapheme2phoneme python -m pip install -r requirements.txt python -m nltk.downloader cmudict python setup.py develop","title":"install dependencies"},{"location":"#usage","text":"source venv/bin/activate python rnn_train.py trains a language model on a directory of txt files (song lyrics or otherwise). tensorboard --logdir=config.log_dir rnn_train.py** is set up to save training and validation data as \"Tensorboard sumaries\" in the \"log\" folder. They can be visualised with Tensorboard. python rnn_play.py uses a trained snapshot (saved to checkpoints folder) to generate a new text. You can also generate new \"Tensorflow Python\" code. See comments in the file.","title":"Usage:"},{"location":"#tests","text":"python setup.py install python -m pytest","title":"Tests"},{"location":"#generated-beatles","text":"Well, it's a long with you I'm so slad at's time And I'm going to love you any old way [Verse 1] Got a good roasing for the day, the world If the sun you stile, hame whit me day I want to be your lover baby I want to be your man [Verse 2] Love you all the time I'clld so lave you while ever day I said, I love you And I'm always thinking of you Oh, oh, oh You treat me badly I love you madly You've really got a hold on me You've really got a hold on me, baby [Chorus] You've really got a hold on me DOoh, some insurance on me, baby Well, if you ever, ever say goodbye I'm gonna go right home and die Oh, if you want me, baby You've gotta come to me Mm honey Baby sawk home Seeks nowhing what sometnd cauld be baunt Nowhere man come your made yeah [Verse 2] The dud as aheit Is going to set you through Come on, pastencco in in nowhere, pain ag the haie You can stop theme soresede Who wan sun you know the walrus und Her lajj, don't you tell me why con't you tell me what you see It is no surprise now, what you see is me","title":"generated Beatles"},{"location":"#contributing","text":"Pull requests are welcome.","title":"Contributing"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation_1","text":"pip install lyrics","title":"Installation"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"alternatives/","text":"What inspired Typer , how it compares to other alternatives and what it learned from them. Intro \u00b6 Typer wouldn't exist if not for the previous work of others. There have been many tools created before that have helped inspire its creation. Previous tools \u00b6 argparse \u00b6 argparse is the Python standard library's module to write CLIs. It provides a better alternative than reading the CLI Parameters as a list of str and parsing everything by hand. Inspired Typer to Provide a better development experience than just reading CLI Parameters by hand. Hug \u00b6 Hug is a library to create APIs and CLIs, it uses parameters in functions to declare the required data. It inspired a lot of the ideas in FastAPI and Typer . Inspired Typer to Use function parameters to declare CLI arguments and CLI options as it simplifies a lot the development experience. Plac \u00b6 Plac is another library to create CLIs using parameters in functions, similar to Hug. Inspired Typer to Provide a simple way to use a function as a command line app, without having to create a complete app, with typer.run(some_function) . Pydantic \u00b6 Pydantic is a library to handle data validation using standard modern Python type annotations. It powers FastAPI underneath. It is not used by Typer , but it inspired a lot of the design (through FastAPI ). Inspired Typer to Use standard Python type annotations to declare types instead of library-specific types or classes and use them for data validation and documentation. Click \u00b6 Click is one of the most widely used libraries to create CLIs in Python. It's a very powerful tool and there are many CLIs built with it. It is what powers Typer underneath. It also uses functions with parameters for CLI arguments and CLI options , but the declaration of the specific CLI arguments , CLI options , types, etc, is done in decorators on top of the function. This requires some code repetition (e.g. a CLI Option name --verbose and a variable name verbose ) and synchronization between two places related to the same information (the decorator and the parameter function). It uses decorators on top of functions to modify the actual value of those functions, converting them to instances of a specific class. This is a clever trick, but code editors can't provide great support for autocompletion that way. It was built with some great ideas and design using the features available in the language at the time (Python 2.x). Typer uses it for Everything. \ud83d\ude80 Typer mainly adds a layer on top of Click, making the code simpler and easier to use, with autocompletion everywhere, etc, but providing all the powerful features of Click underneath. As someone pointed out: \"Nice to see it is built on Click but adds the type stuff. Me gusta!\" click-completion \u00b6 click-completion is a plug-in for Click. It was created to extend completion support for shells when Click only had support for Bash completion. Previous versions of Typer had deep integrations with click-completion and used it as an optional dependency. But now all the completion logic is implemented internally in Typer itself, the internal logic was heavily inspired and using some parts of click-completion . And now Typer improved it to have new features, tests, some bug fixes (for issues in plain click-completion and Click), and better support for shells, including modern versions of PowerShell (e.g. the default versions that come with Windows 10). Inspired Typer to Provide auto completion for all the shells. FastAPI \u00b6 I created FastAPI to provide an easy way to build APIs with autocompletion for everything in the code (and some other features ). Typer is the \"FastAPI of CLIs\". It uses the same design and usage of FastAPI as much as possible. So, if you have used FastAPI, you know how to use Typer.","title":"Alternatives, Inspiration and Comparisons"},{"location":"alternatives/#intro","text":"Typer wouldn't exist if not for the previous work of others. There have been many tools created before that have helped inspire its creation.","title":"Intro"},{"location":"alternatives/#previous-tools","text":"","title":"Previous tools"},{"location":"alternatives/#argparse","text":"argparse is the Python standard library's module to write CLIs. It provides a better alternative than reading the CLI Parameters as a list of str and parsing everything by hand. Inspired Typer to Provide a better development experience than just reading CLI Parameters by hand.","title":"argparse"},{"location":"alternatives/#hug","text":"Hug is a library to create APIs and CLIs, it uses parameters in functions to declare the required data. It inspired a lot of the ideas in FastAPI and Typer . Inspired Typer to Use function parameters to declare CLI arguments and CLI options as it simplifies a lot the development experience.","title":"Hug"},{"location":"alternatives/#plac","text":"Plac is another library to create CLIs using parameters in functions, similar to Hug. Inspired Typer to Provide a simple way to use a function as a command line app, without having to create a complete app, with typer.run(some_function) .","title":"Plac"},{"location":"alternatives/#pydantic","text":"Pydantic is a library to handle data validation using standard modern Python type annotations. It powers FastAPI underneath. It is not used by Typer , but it inspired a lot of the design (through FastAPI ). Inspired Typer to Use standard Python type annotations to declare types instead of library-specific types or classes and use them for data validation and documentation.","title":"Pydantic"},{"location":"alternatives/#click","text":"Click is one of the most widely used libraries to create CLIs in Python. It's a very powerful tool and there are many CLIs built with it. It is what powers Typer underneath. It also uses functions with parameters for CLI arguments and CLI options , but the declaration of the specific CLI arguments , CLI options , types, etc, is done in decorators on top of the function. This requires some code repetition (e.g. a CLI Option name --verbose and a variable name verbose ) and synchronization between two places related to the same information (the decorator and the parameter function). It uses decorators on top of functions to modify the actual value of those functions, converting them to instances of a specific class. This is a clever trick, but code editors can't provide great support for autocompletion that way. It was built with some great ideas and design using the features available in the language at the time (Python 2.x). Typer uses it for Everything. \ud83d\ude80 Typer mainly adds a layer on top of Click, making the code simpler and easier to use, with autocompletion everywhere, etc, but providing all the powerful features of Click underneath. As someone pointed out: \"Nice to see it is built on Click but adds the type stuff. Me gusta!\"","title":"Click"},{"location":"alternatives/#click-completion","text":"click-completion is a plug-in for Click. It was created to extend completion support for shells when Click only had support for Bash completion. Previous versions of Typer had deep integrations with click-completion and used it as an optional dependency. But now all the completion logic is implemented internally in Typer itself, the internal logic was heavily inspired and using some parts of click-completion . And now Typer improved it to have new features, tests, some bug fixes (for issues in plain click-completion and Click), and better support for shells, including modern versions of PowerShell (e.g. the default versions that come with Windows 10). Inspired Typer to Provide auto completion for all the shells.","title":"click-completion"},{"location":"alternatives/#fastapi","text":"I created FastAPI to provide an easy way to build APIs with autocompletion for everything in the code (and some other features ). Typer is the \"FastAPI of CLIs\". It uses the same design and usage of FastAPI as much as possible. So, if you have used FastAPI, you know how to use Typer.","title":"FastAPI"},{"location":"contributing/","text":"First, you might want to see the basic ways to help Typer and get help . Developing \u00b6 If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment. Virtual environment with venv \u00b6 You can create a virtual environment in a directory using Python's venv module: $ python -m venv env That will create a directory ./env/ with the Python binaries and then you will be able to install packages for that isolated environment. Activate the environment \u00b6 Activate the new environment with: Linux, macOS $ source ./env/bin/activate Windows PowerShell $ . \\e nv \\S cripts \\A ctivate.ps1 Windows Bash Or if you use Bash for Windows (e.g. Git Bash ): $ source ./env/Scripts/activate To check it worked, use: Linux, macOS, Windows Bash $ which pip some/directory/typer/env/bin/pip Windows PowerShell $ Get-Command pip some/directory/typer/env/bin/pip If it shows the pip binary at env/bin/pip then it worked. \ud83c\udf89 Tip Every time you install a new package with pip under that environment, activate the environment again. This makes sure that if you use a terminal program installed by that package (like flit ), you use the one from your local environment and not any other that could be installed globally. Flit \u00b6 Typer uses Flit to build, package and publish the project. After activating the environment as described above, install flit : $ pip install flit ---> 100% Now re-activate the environment to make sure you are using the flit you just installed (and not a global one). And now use flit to install the development dependencies: Linux, macOS $ flit install --deps develop --symlink ---> 100% Windows If you are on Windows, use --pth-file instead of --symlink : $ flit install --deps develop --pth-file ---> 100% It will install all the dependencies and your local Typer in your local environment. Using your local Typer \u00b6 If you create a Python file that imports and uses Typer, and run it with the Python from your local environment, it will use your local Typer source code. And if you update that local Typer source code, as it is installed with --symlink (or --pth-file on Windows), when you run that Python file again, it will use the fresh version of Typer you just edited. That way, you don't have to \"install\" your local version to be able to test every change. Format \u00b6 There is a script that you can run that will format and clean all your code: $ bash scripts/format.sh It will also auto-sort all your imports. For it to sort them correctly, you need to have Typer installed locally in your environment, with the command in the section above using --symlink (or --pth-file on Windows). Format imports \u00b6 There is another script that formats all the imports and makes sure you don't have unused imports: $ bash scripts/format-imports.sh As it runs one command after the other and modifies and reverts many files, it takes a bit longer to run, so it might be easier to use scripts/format.sh frequently and scripts/format-imports.sh only before committing. Docs \u00b6 The documentation uses MkDocs . All the documentation is in Markdown format in the directory ./docs . Many of the tutorials have blocks of code. In most of the cases, these blocks of code are actual complete applications that can be run as is. In fact, those blocks of code are not written inside the Markdown, they are Python files in the ./docs_src/ directory. And those Python files are included/injected in the documentation when generating the site. Docs for tests \u00b6 Most of the tests actually run against the example source files in the documentation. This helps making sure that: The documentation is up to date. The documentation examples can be run as is. Most of the features are covered by the documentation, ensured by test coverage. During local development, there is a script that builds the site and checks for any changes, live-reloading: $ bash scripts/docs-live.sh <span style=\"color: green;\">[INFO]</span> - Building documentation... <span style=\"color: green;\">[INFO]</span> - Cleaning site directory <span style=\"color: green;\">[INFO]</span> - Documentation built in 2.74 seconds <span style=\"color: green;\">[INFO]</span> - Serving on http://127.0.0.1:8008 It will serve the documentation on http://127.0.0.1:8008 . That way, you can edit the documentation/source files and see the changes live. Tests \u00b6 There is a script that you can run locally to test all the code and generate coverage reports in HTML: $ bash scripts/test-cov-html.sh This command generates a directory ./htmlcov/ , if you open the file ./htmlcov/index.html in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.","title":"Development - Contributing"},{"location":"contributing/#developing","text":"If you already cloned the repository and you know that you need to deep dive in the code, here are some guidelines to set up your environment.","title":"Developing"},{"location":"contributing/#virtual-environment-with-venv","text":"You can create a virtual environment in a directory using Python's venv module: $ python -m venv env That will create a directory ./env/ with the Python binaries and then you will be able to install packages for that isolated environment.","title":"Virtual environment with venv"},{"location":"contributing/#activate-the-environment","text":"Activate the new environment with: Linux, macOS $ source ./env/bin/activate Windows PowerShell $ . \\e nv \\S cripts \\A ctivate.ps1 Windows Bash Or if you use Bash for Windows (e.g. Git Bash ): $ source ./env/Scripts/activate To check it worked, use: Linux, macOS, Windows Bash $ which pip some/directory/typer/env/bin/pip Windows PowerShell $ Get-Command pip some/directory/typer/env/bin/pip If it shows the pip binary at env/bin/pip then it worked. \ud83c\udf89 Tip Every time you install a new package with pip under that environment, activate the environment again. This makes sure that if you use a terminal program installed by that package (like flit ), you use the one from your local environment and not any other that could be installed globally.","title":"Activate the environment"},{"location":"contributing/#flit","text":"Typer uses Flit to build, package and publish the project. After activating the environment as described above, install flit : $ pip install flit ---> 100% Now re-activate the environment to make sure you are using the flit you just installed (and not a global one). And now use flit to install the development dependencies: Linux, macOS $ flit install --deps develop --symlink ---> 100% Windows If you are on Windows, use --pth-file instead of --symlink : $ flit install --deps develop --pth-file ---> 100% It will install all the dependencies and your local Typer in your local environment.","title":"Flit"},{"location":"contributing/#using-your-local-typer","text":"If you create a Python file that imports and uses Typer, and run it with the Python from your local environment, it will use your local Typer source code. And if you update that local Typer source code, as it is installed with --symlink (or --pth-file on Windows), when you run that Python file again, it will use the fresh version of Typer you just edited. That way, you don't have to \"install\" your local version to be able to test every change.","title":"Using your local Typer"},{"location":"contributing/#format","text":"There is a script that you can run that will format and clean all your code: $ bash scripts/format.sh It will also auto-sort all your imports. For it to sort them correctly, you need to have Typer installed locally in your environment, with the command in the section above using --symlink (or --pth-file on Windows).","title":"Format"},{"location":"contributing/#format-imports","text":"There is another script that formats all the imports and makes sure you don't have unused imports: $ bash scripts/format-imports.sh As it runs one command after the other and modifies and reverts many files, it takes a bit longer to run, so it might be easier to use scripts/format.sh frequently and scripts/format-imports.sh only before committing.","title":"Format imports"},{"location":"contributing/#docs","text":"The documentation uses MkDocs . All the documentation is in Markdown format in the directory ./docs . Many of the tutorials have blocks of code. In most of the cases, these blocks of code are actual complete applications that can be run as is. In fact, those blocks of code are not written inside the Markdown, they are Python files in the ./docs_src/ directory. And those Python files are included/injected in the documentation when generating the site.","title":"Docs"},{"location":"contributing/#docs-for-tests","text":"Most of the tests actually run against the example source files in the documentation. This helps making sure that: The documentation is up to date. The documentation examples can be run as is. Most of the features are covered by the documentation, ensured by test coverage. During local development, there is a script that builds the site and checks for any changes, live-reloading: $ bash scripts/docs-live.sh <span style=\"color: green;\">[INFO]</span> - Building documentation... <span style=\"color: green;\">[INFO]</span> - Cleaning site directory <span style=\"color: green;\">[INFO]</span> - Documentation built in 2.74 seconds <span style=\"color: green;\">[INFO]</span> - Serving on http://127.0.0.1:8008 It will serve the documentation on http://127.0.0.1:8008 . That way, you can edit the documentation/source files and see the changes live.","title":"Docs for tests"},{"location":"contributing/#tests","text":"There is a script that you can run locally to test all the code and generate coverage reports in HTML: $ bash scripts/test-cov-html.sh This command generates a directory ./htmlcov/ , if you open the file ./htmlcov/index.html in your browser, you can explore interactively the regions of code that are covered by the tests, and notice if there is any region missing.","title":"Tests"},{"location":"features/","text":"Design based on FastAPI \u00b6 Typer is FastAPI 's little sibling. It follows the same design and ideas. If you know FastAPI , you already know Typer ... more or less. Just Modern Python \u00b6 It's all based on standard Python 3.6 type declarations. No new syntax to learn. Just standard modern Python. If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI or Typer), check the FastAPI tutorial section: Python types intro . You will also see a 20 seconds refresher on the section Tutorial - User Guide: First Steps . Editor support \u00b6 Typer was designed to be easy and intuitive to use, to ensure the best development experience. With autocompletion everywhere. You will rarely need to come back to the docs. Here's how your editor might help you: in Visual Studio Code : in PyCharm : You will get completion for everything. That's something no other CLI library provides right now. No more guessing what type was that variable, if it could be None , etc. Short \u00b6 It has sensible defaults for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need, customize the help, callbacks per parameter, make them required or not, etc. But by default, it all \"just works\" . User friendly CLI apps \u00b6 The resulting CLI apps created with Typer have the nice features of many \"pro\" command line programs you probably already love. Automatic help options for the main CLI program and all its subcommands. Automatic command and subcommand structure handling (you will see more about subcommands in the Tutorial - User Guide). Automatic completion for the CLI app in all operating systems, in all the shells (Bash, Zsh, Fish, PowerShell), so that the final user of your app can just hit TAB and get the available options or subcommands. * * Auto completion Auto completion works when you create a package (installable with pip ). Or when using Typer CLI . If you also add shellingham as a dependency, Typer will use it to auto-detect the current shell when installing completion. Typer will automatically create 2 CLI options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. If you didn't add shellingham those CLI options take a value with the name of the shell to install completion for, e.g.: --install-completion bash . --show-completion powershell . Then you can tell the user to install completion after installing your CLI program and the rest will just work. Tip Typer 's completion is implemented internally, it uses ideas and components from Click and ideas from click-completion , but it doesn't use click-completion and re-implements some of the relevant parts of Click. Then it extends those ideas with features and bug fixes. For example, Typer programs also support modern versions of PowerShell (e.g. in Windows 10) among all the other shells. The power of Click \u00b6 Click is one of the most popular tools for building CLIs in Python. Typer is based on it, so you get all its benefits, plug-ins, robustness, etc. But you can write simpler code with the benefits of modern Python. Tested \u00b6 100% test coverage . 100% type annotated code base. Used in production applications.","title":"Features"},{"location":"features/#design-based-on-fastapi","text":"Typer is FastAPI 's little sibling. It follows the same design and ideas. If you know FastAPI , you already know Typer ... more or less.","title":"Design based on FastAPI"},{"location":"features/#just-modern-python","text":"It's all based on standard Python 3.6 type declarations. No new syntax to learn. Just standard modern Python. If you need a 2 minute refresher of how to use Python types (even if you don't use FastAPI or Typer), check the FastAPI tutorial section: Python types intro . You will also see a 20 seconds refresher on the section Tutorial - User Guide: First Steps .","title":"Just Modern Python"},{"location":"features/#editor-support","text":"Typer was designed to be easy and intuitive to use, to ensure the best development experience. With autocompletion everywhere. You will rarely need to come back to the docs. Here's how your editor might help you: in Visual Studio Code : in PyCharm : You will get completion for everything. That's something no other CLI library provides right now. No more guessing what type was that variable, if it could be None , etc.","title":"Editor support"},{"location":"features/#short","text":"It has sensible defaults for everything, with optional configurations everywhere. All the parameters can be fine-tuned to do what you need, customize the help, callbacks per parameter, make them required or not, etc. But by default, it all \"just works\" .","title":"Short"},{"location":"features/#user-friendly-cli-apps","text":"The resulting CLI apps created with Typer have the nice features of many \"pro\" command line programs you probably already love. Automatic help options for the main CLI program and all its subcommands. Automatic command and subcommand structure handling (you will see more about subcommands in the Tutorial - User Guide). Automatic completion for the CLI app in all operating systems, in all the shells (Bash, Zsh, Fish, PowerShell), so that the final user of your app can just hit TAB and get the available options or subcommands. * * Auto completion Auto completion works when you create a package (installable with pip ). Or when using Typer CLI . If you also add shellingham as a dependency, Typer will use it to auto-detect the current shell when installing completion. Typer will automatically create 2 CLI options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. If you didn't add shellingham those CLI options take a value with the name of the shell to install completion for, e.g.: --install-completion bash . --show-completion powershell . Then you can tell the user to install completion after installing your CLI program and the rest will just work. Tip Typer 's completion is implemented internally, it uses ideas and components from Click and ideas from click-completion , but it doesn't use click-completion and re-implements some of the relevant parts of Click. Then it extends those ideas with features and bug fixes. For example, Typer programs also support modern versions of PowerShell (e.g. in Windows 10) among all the other shells.","title":"User friendly CLI apps"},{"location":"features/#the-power-of-click","text":"Click is one of the most popular tools for building CLIs in Python. Typer is based on it, so you get all its benefits, plug-ins, robustness, etc. But you can write simpler code with the benefits of modern Python.","title":"The power of Click"},{"location":"features/#tested","text":"100% test coverage . 100% type annotated code base. Used in production applications.","title":"Tested"},{"location":"help-typer/","text":"Are you liking Typer ? Would you like to help Typer, other users, and the author? Or would you like to get help with Typer ? There are very simple ways to help (several involve just one or two clicks). And there are several ways to get help too. Star Typer in GitHub \u00b6 You can \"star\" Typer in GitHub (clicking the star button at the top right): https://github.com/tiangolo/typer . By adding a star, other users will be able to find it more easily and see that it has been already useful for others. Watch the GitHub repository for releases \u00b6 You can \"watch\" Typer in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/typer . There you can select \"Releases only\". Doing it, you will receive notifications (in your email) whenever there's a new release (a new version) of Typer with bug fixes and new features. Connect with the author \u00b6 You can connect with me (Sebasti\u00e1n Ram\u00edrez / tiangolo ) , the author. You can: Follow me on GitHub . See other Open Source projects I have created that could help you. Follow me to see when I create a new Open Source project. Follow me on Twitter . Tell me how you use Typer (I love to hear that). Ask questions. Connect with me on Linkedin . Talk to me. Endorse me or recommend me :) Read what I write (or follow me): Read other ideas, articles and tools I have created. Follow me to see when I publish something new. On Dev.to . On Medium . Tweet about Typer \u00b6 Tweet about Typer and let me and others know why you like it. Let me know how are you using Typer \u00b6 I love to hear about how Typer is being used, what have you liked in it, in which project/company you are using it, etc. You can let me know: On Twitter . On Linkedin . On Dev.to . On Medium . Help others with issues in GitHub \u00b6 You can see existing issues and try and help others. Watch the GitHub repository \u00b6 You can \"watch\" Typer in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/typer . If you select \"Watching\" instead of \"Releases only\", you will receive notifications when someone creates a new issue. Then you can try and help them solving those issues. Create issues \u00b6 You can create a new issue in the GitHub repository, for example to: Report a bug/issue. Suggest a new feature. Ask a question. Create a Pull Request \u00b6 You can create a Pull Request , for example: To fix a typo you found on the documentation. To propose new documentation sections. To fix an existing issue/bug. To add a new feature. Thanks!","title":"Help Typer - Get Help"},{"location":"help-typer/#star-typer-in-github","text":"You can \"star\" Typer in GitHub (clicking the star button at the top right): https://github.com/tiangolo/typer . By adding a star, other users will be able to find it more easily and see that it has been already useful for others.","title":"Star Typer in GitHub"},{"location":"help-typer/#watch-the-github-repository-for-releases","text":"You can \"watch\" Typer in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/typer . There you can select \"Releases only\". Doing it, you will receive notifications (in your email) whenever there's a new release (a new version) of Typer with bug fixes and new features.","title":"Watch the GitHub repository for releases"},{"location":"help-typer/#connect-with-the-author","text":"You can connect with me (Sebasti\u00e1n Ram\u00edrez / tiangolo ) , the author. You can: Follow me on GitHub . See other Open Source projects I have created that could help you. Follow me to see when I create a new Open Source project. Follow me on Twitter . Tell me how you use Typer (I love to hear that). Ask questions. Connect with me on Linkedin . Talk to me. Endorse me or recommend me :) Read what I write (or follow me): Read other ideas, articles and tools I have created. Follow me to see when I publish something new. On Dev.to . On Medium .","title":"Connect with the author"},{"location":"help-typer/#tweet-about-typer","text":"Tweet about Typer and let me and others know why you like it.","title":"Tweet about Typer"},{"location":"help-typer/#let-me-know-how-are-you-using-typer","text":"I love to hear about how Typer is being used, what have you liked in it, in which project/company you are using it, etc. You can let me know: On Twitter . On Linkedin . On Dev.to . On Medium .","title":"Let me know how are you using Typer"},{"location":"help-typer/#help-others-with-issues-in-github","text":"You can see existing issues and try and help others.","title":"Help others with issues in GitHub"},{"location":"help-typer/#watch-the-github-repository","text":"You can \"watch\" Typer in GitHub (clicking the \"watch\" button at the top right): https://github.com/tiangolo/typer . If you select \"Watching\" instead of \"Releases only\", you will receive notifications when someone creates a new issue. Then you can try and help them solving those issues.","title":"Watch the GitHub repository"},{"location":"help-typer/#create-issues","text":"You can create a new issue in the GitHub repository, for example to: Report a bug/issue. Suggest a new feature. Ask a question.","title":"Create issues"},{"location":"help-typer/#create-a-pull-request","text":"You can create a Pull Request , for example: To fix a typo you found on the documentation. To propose new documentation sections. To fix an existing issue/bug. To add a new feature. Thanks!","title":"Create a Pull Request"},{"location":"release-notes/","text":"Latest changes \u00b6 0.3.2 \u00b6 Features \u00b6 Add support for mypy --strict . Original PR #147 by @victorphoenix3 . Docs \u00b6 Update docs with new --help showing default values. PR #135 by @victorphoenix3 . Add Optional to docs for CLI Arguments and Options with a default of None . PR #131 by @rkbeatss . Add valid date formats to docs. PR #122 by @IamCathal . Internal \u00b6 Report coverage in XML to support GitHub Actions. PR #146 . Update badges and remove Travis, now that GitHub Actions is the main CI. PR #145 . 0.3.1 \u00b6 Add GitHub Actions, move from Travis. PR #144 . Pin dependencies. PR #138 . Add Dependabot. PR #136 . Upgrade Isort to version 5.x.x. PR #137 . 0.3.0 \u00b6 Add support for help parameter in CLI arguments : As help in CLI arguments is not supported by Click, there are two new internal classes (Click sub-classes) to support it: typer.core.TyperArgument typer.core.TyperCommand This includes a new auto-generated help text section Arguments for CLI arguments , showing defaults, required arguments, etc. It's also possible to disable it and keep the previous behavior, not showing automatic help for CLI arguments (Click's default) using the hidden parameter. Now show_default is True by default. And now show_envvar is True by default. So, default values and env vars are shown in the help text by default, without having to manually enable them, for both CLI arguments and CLI options . New docs: CLI Arguments Intro . Optional CLI Arguments . CLI Arguments with Default . CLI Arguments with Help . CLI Arguments with Environment Variables . CLI Arguments: Other uses . CLI arguments with tuples . Lot's of tests for all the new examples in the new docs, keeping coverage at 100%. PR #123 . Add docs for calling packages with python -m some_package using __main__.py : Building a Package: Support python -m . PR #121 . Add support for *args and **kwargs when calling the Typer app, just like in Click. PR #120 by @teymour-aldridge . Fix typos in README and main docs #103 by @mrcartoonster . Fix typo in docs. PR #98 by @mrcartoonster . Fix typos and rewording in docs. PR #97 by @mrcartoonster . Update GitHub Action issue-manager. PR #114 . 0.2.1 \u00b6 Add support for forward references (types declared inside of strings). PR #93 . 0.2.0 \u00b6 Add support for completion for commands/programs not available on startup. This allows installing a Typer program/script in a virtual environment and still have completion globally installed. PR #92 . Add note about typer.echo() and print() for colors in Windows. PR #89 . Upgrade Mkdocs-Material version, update contributing guide style. PR #90 . 0.1.1 \u00b6 Fix completion evaluation for Bash and Zsh when the program is not installed/found. PR #83 . Fix completion script for Fish. PR #82 . Fix shell installation for Bash to ~/.bashrc and update Windows development docs. PR #81 . Update coverage badge. PR #78 . 0.1.0 \u00b6 Fix coverage instructions. PR #72 . Add docs for Building a Package . PR #71 . Add docs for Using Click (with Typer) . PR #70 . Add support for type-based callbacks and autocompletion functions, extra tests and docs: Extra tests, raising coverage to 100%. New docs: Printing and Colors: \"Standard Output\" and \"Standard Error\" . New docs: Password CLI Option and Confirmation Prompt . Support for callbacks based on type annotations. New docs: CLI Option Callback and Context . New docs: Version CLI Option, is_eager . Support for autocompletion functions based on type annotations. New docs: CLI Option autocompletion . New docs: Commands: Using the Context . New docs: Testing . PR #68 . Fix Zsh completion install script. PR #69 . Fix typo in progressbar example. PR #63 by @ValentinCalomme . 0.0.11 \u00b6 Re-implement completion system: Remove optional dependency click-completion (with its sub-dependencies, like Jinja). Add optional dependency shellingham to auto detect shell to install (it was used by click-completion ). Completion now doesn't require a third party library. If shellingham is not installed/added as a dependency, --install-completion and --show-completion take a value with the name of the shell. Fix support for user provided completion in CLI Parameters . Fix completion for files in Bash, Zsh, and Fish. Add support for modern versions of PowerShell, 5, 6, and 7 (e.g. in Windows 10). Add support for pwsh (PowerShell Core). PowerShell support includes help strings for commands and CLI Parameters . Several bug fixes. Tests for the completion logic/code. Tested in all the shells in Linux and Windows. PR #66 . Fix format in docs with highlighted lines. PR #65 . Add docs about Typer CLI - completion for small scripts . PR #64 . Add docs about Alternatives, Inspiration and Comparisons . PR #62 . Add Development - Contributing Guide . PR #61 . 0.0.10 \u00b6 Add support for Click version 7.1.1. PR #60 . 0.0.9 \u00b6 Add support for PEP 561, to allow mypy to type check applications built with Typer . PR #58 . Upgrade deploy docs to Netlify GitHub action. PR #57 . Add support for Mermaid JS for visualizations. PR #56 . Update CI to run docs deployment in GitHub actions. PR #50 . Update format for internal links. PR #38 . Tweak external links' format. PR #36 . 0.0.8 \u00b6 Update docs and add latest changes to MkDocs/website. PR #33 . Add extra tests for edge cases that don't belong in docs' examples. PR #32 . Add docs for CLI Parameters with Multiple Values . Includes tests for all the examples and bug fixes. PR #31 . Add docs for extra CLI parameter types: CLI Parameter Types: Number and CLI Parameter Types: Boolean CLI Options . PR #30 . Extend docs for Commands, add Commands: Typer Callback and Commands: One or Multiple . This includes tests for all the examples and bug fixes. PR #29 . Add docs for SubCommands - Command Groups . This includes tests for all the examples and bug fixes. PR #28 . Remove unneeded code for argument handling. PR #26 . Add docs for Launching Applications . PR #25 . Add docs for getting the CLI Application Directory . PR #24 . Add docs for Progress Bars . PR #23 . Add docs for Asking with Interactive Prompts . PR #22 . Update docs for path CLI option . PR #21 . Add colors module and docs for Printing and Colors and for Terminating , including tests. PR #20 . Refactor docs to make each individual page/section \"bite-sized\" / small. Add docs for CLI option names . Update typer.Argument() to remove invalid positional param_decls . PR #19 . 0.0.7 \u00b6 Add docs for CLI parameter types . Includes tests and file classes refactor. PR #17 . Add tests for completion. PR #15 and #16 . 0.0.6 \u00b6 Add docs for Commands . Includes a bug fix for handling default values set in typer.Typer() parameters. PR #14 . Add docs for CLI Arguments . PR #13 . Add docs for CLI Options . PR #12 . 0.0.5 \u00b6 Clean exports from Typer. Remove unneeded components from Click and add needed Exit exception. PR #11 . Fix and document extracting help from a function's docstring First Steps: Document your CLI app . PR #10 . Update references to --install-completion and --show-completion in docs. PR #9 . Fix testing utilities, add tests for First Steps examples. PR #8 . Add auto completion options by default when click-completion is installed: --install-completion and --show-completion . PR #7 . Update Termynal to have fixed sizes, add \"fast\" button, and use it in First Steps . PR #6 . Add custom automatic Termynal for docs. PR #5 . 0.0.4 \u00b6 Update short descriptions and assets. Docs rewording and fix typos. PR #1 by @mariacamilagl . 0.0.3 \u00b6 Fix group creation without name. 0.0.2 \u00b6 Add initial version of code, docs, etc. 0.0.1 \u00b6 First commit. Publish to PyPI to reserve package name.","title":"Release Notes"},{"location":"release-notes/#latest-changes","text":"","title":"Latest changes"},{"location":"release-notes/#032","text":"","title":"0.3.2"},{"location":"release-notes/#features","text":"Add support for mypy --strict . Original PR #147 by @victorphoenix3 .","title":"Features"},{"location":"release-notes/#docs","text":"Update docs with new --help showing default values. PR #135 by @victorphoenix3 . Add Optional to docs for CLI Arguments and Options with a default of None . PR #131 by @rkbeatss . Add valid date formats to docs. PR #122 by @IamCathal .","title":"Docs"},{"location":"release-notes/#internal","text":"Report coverage in XML to support GitHub Actions. PR #146 . Update badges and remove Travis, now that GitHub Actions is the main CI. PR #145 .","title":"Internal"},{"location":"release-notes/#031","text":"Add GitHub Actions, move from Travis. PR #144 . Pin dependencies. PR #138 . Add Dependabot. PR #136 . Upgrade Isort to version 5.x.x. PR #137 .","title":"0.3.1"},{"location":"release-notes/#030","text":"Add support for help parameter in CLI arguments : As help in CLI arguments is not supported by Click, there are two new internal classes (Click sub-classes) to support it: typer.core.TyperArgument typer.core.TyperCommand This includes a new auto-generated help text section Arguments for CLI arguments , showing defaults, required arguments, etc. It's also possible to disable it and keep the previous behavior, not showing automatic help for CLI arguments (Click's default) using the hidden parameter. Now show_default is True by default. And now show_envvar is True by default. So, default values and env vars are shown in the help text by default, without having to manually enable them, for both CLI arguments and CLI options . New docs: CLI Arguments Intro . Optional CLI Arguments . CLI Arguments with Default . CLI Arguments with Help . CLI Arguments with Environment Variables . CLI Arguments: Other uses . CLI arguments with tuples . Lot's of tests for all the new examples in the new docs, keeping coverage at 100%. PR #123 . Add docs for calling packages with python -m some_package using __main__.py : Building a Package: Support python -m . PR #121 . Add support for *args and **kwargs when calling the Typer app, just like in Click. PR #120 by @teymour-aldridge . Fix typos in README and main docs #103 by @mrcartoonster . Fix typo in docs. PR #98 by @mrcartoonster . Fix typos and rewording in docs. PR #97 by @mrcartoonster . Update GitHub Action issue-manager. PR #114 .","title":"0.3.0"},{"location":"release-notes/#021","text":"Add support for forward references (types declared inside of strings). PR #93 .","title":"0.2.1"},{"location":"release-notes/#020","text":"Add support for completion for commands/programs not available on startup. This allows installing a Typer program/script in a virtual environment and still have completion globally installed. PR #92 . Add note about typer.echo() and print() for colors in Windows. PR #89 . Upgrade Mkdocs-Material version, update contributing guide style. PR #90 .","title":"0.2.0"},{"location":"release-notes/#011","text":"Fix completion evaluation for Bash and Zsh when the program is not installed/found. PR #83 . Fix completion script for Fish. PR #82 . Fix shell installation for Bash to ~/.bashrc and update Windows development docs. PR #81 . Update coverage badge. PR #78 .","title":"0.1.1"},{"location":"release-notes/#010","text":"Fix coverage instructions. PR #72 . Add docs for Building a Package . PR #71 . Add docs for Using Click (with Typer) . PR #70 . Add support for type-based callbacks and autocompletion functions, extra tests and docs: Extra tests, raising coverage to 100%. New docs: Printing and Colors: \"Standard Output\" and \"Standard Error\" . New docs: Password CLI Option and Confirmation Prompt . Support for callbacks based on type annotations. New docs: CLI Option Callback and Context . New docs: Version CLI Option, is_eager . Support for autocompletion functions based on type annotations. New docs: CLI Option autocompletion . New docs: Commands: Using the Context . New docs: Testing . PR #68 . Fix Zsh completion install script. PR #69 . Fix typo in progressbar example. PR #63 by @ValentinCalomme .","title":"0.1.0"},{"location":"release-notes/#0011","text":"Re-implement completion system: Remove optional dependency click-completion (with its sub-dependencies, like Jinja). Add optional dependency shellingham to auto detect shell to install (it was used by click-completion ). Completion now doesn't require a third party library. If shellingham is not installed/added as a dependency, --install-completion and --show-completion take a value with the name of the shell. Fix support for user provided completion in CLI Parameters . Fix completion for files in Bash, Zsh, and Fish. Add support for modern versions of PowerShell, 5, 6, and 7 (e.g. in Windows 10). Add support for pwsh (PowerShell Core). PowerShell support includes help strings for commands and CLI Parameters . Several bug fixes. Tests for the completion logic/code. Tested in all the shells in Linux and Windows. PR #66 . Fix format in docs with highlighted lines. PR #65 . Add docs about Typer CLI - completion for small scripts . PR #64 . Add docs about Alternatives, Inspiration and Comparisons . PR #62 . Add Development - Contributing Guide . PR #61 .","title":"0.0.11"},{"location":"release-notes/#0010","text":"Add support for Click version 7.1.1. PR #60 .","title":"0.0.10"},{"location":"release-notes/#009","text":"Add support for PEP 561, to allow mypy to type check applications built with Typer . PR #58 . Upgrade deploy docs to Netlify GitHub action. PR #57 . Add support for Mermaid JS for visualizations. PR #56 . Update CI to run docs deployment in GitHub actions. PR #50 . Update format for internal links. PR #38 . Tweak external links' format. PR #36 .","title":"0.0.9"},{"location":"release-notes/#008","text":"Update docs and add latest changes to MkDocs/website. PR #33 . Add extra tests for edge cases that don't belong in docs' examples. PR #32 . Add docs for CLI Parameters with Multiple Values . Includes tests for all the examples and bug fixes. PR #31 . Add docs for extra CLI parameter types: CLI Parameter Types: Number and CLI Parameter Types: Boolean CLI Options . PR #30 . Extend docs for Commands, add Commands: Typer Callback and Commands: One or Multiple . This includes tests for all the examples and bug fixes. PR #29 . Add docs for SubCommands - Command Groups . This includes tests for all the examples and bug fixes. PR #28 . Remove unneeded code for argument handling. PR #26 . Add docs for Launching Applications . PR #25 . Add docs for getting the CLI Application Directory . PR #24 . Add docs for Progress Bars . PR #23 . Add docs for Asking with Interactive Prompts . PR #22 . Update docs for path CLI option . PR #21 . Add colors module and docs for Printing and Colors and for Terminating , including tests. PR #20 . Refactor docs to make each individual page/section \"bite-sized\" / small. Add docs for CLI option names . Update typer.Argument() to remove invalid positional param_decls . PR #19 .","title":"0.0.8"},{"location":"release-notes/#007","text":"Add docs for CLI parameter types . Includes tests and file classes refactor. PR #17 . Add tests for completion. PR #15 and #16 .","title":"0.0.7"},{"location":"release-notes/#006","text":"Add docs for Commands . Includes a bug fix for handling default values set in typer.Typer() parameters. PR #14 . Add docs for CLI Arguments . PR #13 . Add docs for CLI Options . PR #12 .","title":"0.0.6"},{"location":"release-notes/#005","text":"Clean exports from Typer. Remove unneeded components from Click and add needed Exit exception. PR #11 . Fix and document extracting help from a function's docstring First Steps: Document your CLI app . PR #10 . Update references to --install-completion and --show-completion in docs. PR #9 . Fix testing utilities, add tests for First Steps examples. PR #8 . Add auto completion options by default when click-completion is installed: --install-completion and --show-completion . PR #7 . Update Termynal to have fixed sizes, add \"fast\" button, and use it in First Steps . PR #6 . Add custom automatic Termynal for docs. PR #5 .","title":"0.0.5"},{"location":"release-notes/#004","text":"Update short descriptions and assets. Docs rewording and fix typos. PR #1 by @mariacamilagl .","title":"0.0.4"},{"location":"release-notes/#003","text":"Fix group creation without name.","title":"0.0.3"},{"location":"release-notes/#002","text":"Add initial version of code, docs, etc.","title":"0.0.2"},{"location":"release-notes/#001","text":"First commit. Publish to PyPI to reserve package name.","title":"0.0.1"},{"location":"typer-cli/","text":"Typer CLI \u00b6 Run Typer scripts with completion, without having to create a package, using Typer CLI . There is an optional utility tool called Typer CLI , additional to Typer itself. It's main feature is to provide \u2728 completion \u2728 in the Terminal for your own small programs built with Typer . ...without you having to create a complete installable Python package. It's probably most useful if you have a small custom Python script using Typer (maybe as part of some project), for some small tasks, and it's not complex/important enough to create a whole installable Python package for it (something to be installed with pip ). In that case, you can install Typer CLI , and run your program with the typer command in your Terminal, and it will provide completion for your script. You can also use Typer CLI to generate Markdown documentation for your own Typer programs \ud83d\udcdd. Documentation : https://typer.tiangolo.com/typer-cli/ Source Code for Typer CLI : https://github.com/tiangolo/typer-cli Typer or Typer CLI \u00b6 Typer is a library for building CLIs (Command Line Interface applications). You use Typer in your Python scripts. Like in: import typer def main (): typer . echo ( \"Hello World\" ) if __name__ == \"__main__\" : typer . run ( main ) Typer CLI is a command line application to run simple programs created with Typer , with completion in your terminal \ud83d\ude80. You use Typer CLI in your terminal, to run your scripts (as an alternative to calling python directly). Like in: $ typer my_script.py run Hello World But you never import anything from Typer CLI in your own scripts. Usage \u00b6 Install \u00b6 Install Typer CLI : $ python -m pip install typer-cli ---> 100% Successfully installed typer-cli That creates a typer command you can call in your terminal, much like python , git , or echo . You can then install completion for it: $ typer --install-completion zsh completion installed in /home/user/.bashrc. Completion will take effect once you restart the terminal. Sample script \u00b6 Let's say you have a script that uses Typer in my_custom_script.py : from typing import Optional import typer app = typer . Typer () @app . command () def hello ( name : Optional [ str ] = None ): if name : typer . echo ( f \"Hello { name } \" ) else : typer . echo ( \"Hello World!\" ) @app . command () def bye ( name : Optional [ str ] = None ): if name : typer . echo ( f \"Bye { name } \" ) else : typer . echo ( \"Goodbye!\" ) if __name__ == \"__main__\" : app () For it to work, you would also install Typer : $ python -m pip install typer ---> 100% Successfully installed typer Run with Python \u00b6 Then you could run your script with normal Python: $ python my_custom_script.py hello Hello World! $ python my_custom_script.py hello --name Camila Hello Camila! $ python my_custom_script.py bye --name Camila Bye Camila There's nothing wrong with using Python directly to run it. And, in fact, if some other code or program uses your script, that would probably be the best way to do it. \u26d4\ufe0f But in your terminal, you won't get completion when hitting TAB for any of the subcommands or options, like hello , bye , and --name . Run with Typer CLI \u00b6 Here's where Typer CLI is useful. You can also run the same script with the typer command you get after installing typer-cli : $ typer my_custom_script.py run hello Hello World! $ typer my_custom_script.py run hello --name Camila Hello Camila! $ typer my_custom_script.py run bye --name Camila Bye Camila Instead of using python directly you use the typer command. After the name of the file, add the subcommand run . \u2714\ufe0f If you installed completion for Typer CLI (for the typer command) as described above, when you hit TAB you will have \u2728 completion for everything \u2728, including all the subcommands and options of your script, like hello , bye , and --name \ud83d\ude80. If main \u00b6 Because Typer CLI won't use the block with: if __name__ == \"__main__\" : app () ...you can also remove it if you are calling that script only with Typer CLI (using the typer command). Run other files \u00b6 Typer CLI can run any script with Typer , but the script doesn't even have to use Typer at all. Typer CLI could even run a file with a function that could be used with typer.run() , even if the script doesn't use typer.run() or anything else. For example, a file main.py like this will still work: def main ( name : str = \"World\" ): \"\"\" Say hi to someone, by default to the World. \"\"\" print ( f \"Hello { name } \" ) Then you can call it with: $ typer main.py run --help Usage: typer run [OPTIONS] Say hi to someone, by default to the World. Options: --name TEXT --help Show this message and exit. $ typer main.py run --name Camila Hello Camila And it will also have completion for things like the --name CLI Option . Run a package or module \u00b6 Instead of a file path you can pass a module (possibly in a package) to import. For example: $ typer my_package.main run --help Usage: typer run [OPTIONS] Options: --name TEXT --help Show this message and exit. $ typer my_package.main run --name Camila Hello Camila Options \u00b6 You can specify one of the following CLI options : --app : the name of the variable with a Typer() object to run as the main app. --func : the name of the variable with a function that would be used with typer.run() . Defaults \u00b6 When your run a script with the Typer CLI (the typer command) it will use the app from the following priority: An app object from the --app CLI Option . A function to convert to a Typer app from --func CLI Option (like when using typer.run() ). A Typer app in a variable with a name of app , cli , or main . The first Typer app available in the file, with any name. A function in a variable with a name of main , cli , or app . The first function in the file, with any name. Generate docs \u00b6 Typer CLI can also generate Markdown documentation for your Typer application. Sample script with docs \u00b6 For example, you could have a script like: import typer app = typer . Typer ( help = \"Awesome CLI user manager.\" ) @app . command () def create ( username : str ): \"\"\" Create a new user with USERNAME. \"\"\" typer . echo ( f \"Creating user: { username } \" ) @app . command () def delete ( username : str , force : bool = typer . Option ( ... , prompt = \"Are you sure you want to delete the user?\" , help = \"Force deletion without confirmation.\" , ), ): \"\"\" Delete a user with USERNAME. If --force is not used, will ask for confirmation. \"\"\" if force : typer . echo ( f \"Deleting user: { username } \" ) else : typer . echo ( \"Operation cancelled\" ) @app . command () def delete_all ( force : bool = typer . Option ( ... , prompt = \"Are you sure you want to delete ALL users?\" , help = \"Force deletion without confirmation.\" , ) ): \"\"\" Delete ALL users in the database. If --force is not used, will ask for confirmation. \"\"\" if force : typer . echo ( \"Deleting all users\" ) else : typer . echo ( \"Operation cancelled\" ) @app . command () def init (): \"\"\" Initialize the users database. \"\"\" typer . echo ( \"Initializing user database\" ) if __name__ == \"__main__\" : app () Generate docs with Typer CLI \u00b6 Then you could generate docs for it with Typer CLI . You can use the subcommand utils . And then the subcommand docs . $ typer some_script.py utils docs Options : --name TEXT : The name of the CLI program to use in docs. --output FILE : An output file to write docs to, like README.md. For example: $ typer my_package.main utils docs --name awesome-cli --output README.md Docs saved to: README.md Sample docs output \u00b6 For example, for the previous script, the generated docs would look like: awesome-cli \u00b6 Awesome CLI user manager. Usage : $ awesome-cli [ OPTIONS ] COMMAND [ ARGS ] ... Options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. --help : Show this message and exit. Commands : create : Create a new user with USERNAME. delete : Delete a user with USERNAME. delete-all : Delete ALL users in the database. init : Initialize the users database. awesome-cli create \u00b6 Create a new user with USERNAME. Usage : $ awesome-cli create [ OPTIONS ] USERNAME Options : --help : Show this message and exit. awesome-cli delete \u00b6 Delete a user with USERNAME. If --force is not used, will ask for confirmation. Usage : $ awesome-cli delete [ OPTIONS ] USERNAME Options : --force / --no-force : Force deletion without confirmation. [required] --help : Show this message and exit. awesome-cli delete-all \u00b6 Delete ALL users in the database. If --force is not used, will ask for confirmation. Usage : $ awesome-cli delete-all [ OPTIONS ] Options : --force / --no-force : Force deletion without confirmation. [required] --help : Show this message and exit. awesome-cli init \u00b6 Initialize the users database. Usage : $ awesome-cli init [ OPTIONS ] Options : --help : Show this message and exit. License \u00b6 Typer CLI , the same as Typer , is licensed under the terms of the MIT license.","title":"Typer CLI - completion for small scripts"},{"location":"typer-cli/#typer-cli","text":"Run Typer scripts with completion, without having to create a package, using Typer CLI . There is an optional utility tool called Typer CLI , additional to Typer itself. It's main feature is to provide \u2728 completion \u2728 in the Terminal for your own small programs built with Typer . ...without you having to create a complete installable Python package. It's probably most useful if you have a small custom Python script using Typer (maybe as part of some project), for some small tasks, and it's not complex/important enough to create a whole installable Python package for it (something to be installed with pip ). In that case, you can install Typer CLI , and run your program with the typer command in your Terminal, and it will provide completion for your script. You can also use Typer CLI to generate Markdown documentation for your own Typer programs \ud83d\udcdd. Documentation : https://typer.tiangolo.com/typer-cli/ Source Code for Typer CLI : https://github.com/tiangolo/typer-cli","title":"Typer CLI"},{"location":"typer-cli/#typer-or-typer-cli","text":"Typer is a library for building CLIs (Command Line Interface applications). You use Typer in your Python scripts. Like in: import typer def main (): typer . echo ( \"Hello World\" ) if __name__ == \"__main__\" : typer . run ( main ) Typer CLI is a command line application to run simple programs created with Typer , with completion in your terminal \ud83d\ude80. You use Typer CLI in your terminal, to run your scripts (as an alternative to calling python directly). Like in: $ typer my_script.py run Hello World But you never import anything from Typer CLI in your own scripts.","title":"Typer or Typer CLI"},{"location":"typer-cli/#usage","text":"","title":"Usage"},{"location":"typer-cli/#install","text":"Install Typer CLI : $ python -m pip install typer-cli ---> 100% Successfully installed typer-cli That creates a typer command you can call in your terminal, much like python , git , or echo . You can then install completion for it: $ typer --install-completion zsh completion installed in /home/user/.bashrc. Completion will take effect once you restart the terminal.","title":"Install"},{"location":"typer-cli/#sample-script","text":"Let's say you have a script that uses Typer in my_custom_script.py : from typing import Optional import typer app = typer . Typer () @app . command () def hello ( name : Optional [ str ] = None ): if name : typer . echo ( f \"Hello { name } \" ) else : typer . echo ( \"Hello World!\" ) @app . command () def bye ( name : Optional [ str ] = None ): if name : typer . echo ( f \"Bye { name } \" ) else : typer . echo ( \"Goodbye!\" ) if __name__ == \"__main__\" : app () For it to work, you would also install Typer : $ python -m pip install typer ---> 100% Successfully installed typer","title":"Sample script"},{"location":"typer-cli/#run-with-python","text":"Then you could run your script with normal Python: $ python my_custom_script.py hello Hello World! $ python my_custom_script.py hello --name Camila Hello Camila! $ python my_custom_script.py bye --name Camila Bye Camila There's nothing wrong with using Python directly to run it. And, in fact, if some other code or program uses your script, that would probably be the best way to do it. \u26d4\ufe0f But in your terminal, you won't get completion when hitting TAB for any of the subcommands or options, like hello , bye , and --name .","title":"Run with Python"},{"location":"typer-cli/#run-with-typer-cli","text":"Here's where Typer CLI is useful. You can also run the same script with the typer command you get after installing typer-cli : $ typer my_custom_script.py run hello Hello World! $ typer my_custom_script.py run hello --name Camila Hello Camila! $ typer my_custom_script.py run bye --name Camila Bye Camila Instead of using python directly you use the typer command. After the name of the file, add the subcommand run . \u2714\ufe0f If you installed completion for Typer CLI (for the typer command) as described above, when you hit TAB you will have \u2728 completion for everything \u2728, including all the subcommands and options of your script, like hello , bye , and --name \ud83d\ude80.","title":"Run with Typer CLI"},{"location":"typer-cli/#if-main","text":"Because Typer CLI won't use the block with: if __name__ == \"__main__\" : app () ...you can also remove it if you are calling that script only with Typer CLI (using the typer command).","title":"If main"},{"location":"typer-cli/#run-other-files","text":"Typer CLI can run any script with Typer , but the script doesn't even have to use Typer at all. Typer CLI could even run a file with a function that could be used with typer.run() , even if the script doesn't use typer.run() or anything else. For example, a file main.py like this will still work: def main ( name : str = \"World\" ): \"\"\" Say hi to someone, by default to the World. \"\"\" print ( f \"Hello { name } \" ) Then you can call it with: $ typer main.py run --help Usage: typer run [OPTIONS] Say hi to someone, by default to the World. Options: --name TEXT --help Show this message and exit. $ typer main.py run --name Camila Hello Camila And it will also have completion for things like the --name CLI Option .","title":"Run other files"},{"location":"typer-cli/#run-a-package-or-module","text":"Instead of a file path you can pass a module (possibly in a package) to import. For example: $ typer my_package.main run --help Usage: typer run [OPTIONS] Options: --name TEXT --help Show this message and exit. $ typer my_package.main run --name Camila Hello Camila","title":"Run a package or module"},{"location":"typer-cli/#options","text":"You can specify one of the following CLI options : --app : the name of the variable with a Typer() object to run as the main app. --func : the name of the variable with a function that would be used with typer.run() .","title":"Options"},{"location":"typer-cli/#defaults","text":"When your run a script with the Typer CLI (the typer command) it will use the app from the following priority: An app object from the --app CLI Option . A function to convert to a Typer app from --func CLI Option (like when using typer.run() ). A Typer app in a variable with a name of app , cli , or main . The first Typer app available in the file, with any name. A function in a variable with a name of main , cli , or app . The first function in the file, with any name.","title":"Defaults"},{"location":"typer-cli/#generate-docs","text":"Typer CLI can also generate Markdown documentation for your Typer application.","title":"Generate docs"},{"location":"typer-cli/#sample-script-with-docs","text":"For example, you could have a script like: import typer app = typer . Typer ( help = \"Awesome CLI user manager.\" ) @app . command () def create ( username : str ): \"\"\" Create a new user with USERNAME. \"\"\" typer . echo ( f \"Creating user: { username } \" ) @app . command () def delete ( username : str , force : bool = typer . Option ( ... , prompt = \"Are you sure you want to delete the user?\" , help = \"Force deletion without confirmation.\" , ), ): \"\"\" Delete a user with USERNAME. If --force is not used, will ask for confirmation. \"\"\" if force : typer . echo ( f \"Deleting user: { username } \" ) else : typer . echo ( \"Operation cancelled\" ) @app . command () def delete_all ( force : bool = typer . Option ( ... , prompt = \"Are you sure you want to delete ALL users?\" , help = \"Force deletion without confirmation.\" , ) ): \"\"\" Delete ALL users in the database. If --force is not used, will ask for confirmation. \"\"\" if force : typer . echo ( \"Deleting all users\" ) else : typer . echo ( \"Operation cancelled\" ) @app . command () def init (): \"\"\" Initialize the users database. \"\"\" typer . echo ( \"Initializing user database\" ) if __name__ == \"__main__\" : app ()","title":"Sample script with docs"},{"location":"typer-cli/#generate-docs-with-typer-cli","text":"Then you could generate docs for it with Typer CLI . You can use the subcommand utils . And then the subcommand docs . $ typer some_script.py utils docs Options : --name TEXT : The name of the CLI program to use in docs. --output FILE : An output file to write docs to, like README.md. For example: $ typer my_package.main utils docs --name awesome-cli --output README.md Docs saved to: README.md","title":"Generate docs with Typer CLI"},{"location":"typer-cli/#sample-docs-output","text":"For example, for the previous script, the generated docs would look like:","title":"Sample docs output"},{"location":"typer-cli/#awesome-cli","text":"Awesome CLI user manager. Usage : $ awesome-cli [ OPTIONS ] COMMAND [ ARGS ] ... Options : --install-completion : Install completion for the current shell. --show-completion : Show completion for the current shell, to copy it or customize the installation. --help : Show this message and exit. Commands : create : Create a new user with USERNAME. delete : Delete a user with USERNAME. delete-all : Delete ALL users in the database. init : Initialize the users database.","title":"awesome-cli"},{"location":"typer-cli/#awesome-cli-create","text":"Create a new user with USERNAME. Usage : $ awesome-cli create [ OPTIONS ] USERNAME Options : --help : Show this message and exit.","title":"awesome-cli create"},{"location":"typer-cli/#awesome-cli-delete","text":"Delete a user with USERNAME. If --force is not used, will ask for confirmation. Usage : $ awesome-cli delete [ OPTIONS ] USERNAME Options : --force / --no-force : Force deletion without confirmation. [required] --help : Show this message and exit.","title":"awesome-cli delete"},{"location":"typer-cli/#awesome-cli-delete-all","text":"Delete ALL users in the database. If --force is not used, will ask for confirmation. Usage : $ awesome-cli delete-all [ OPTIONS ] Options : --force / --no-force : Force deletion without confirmation. [required] --help : Show this message and exit.","title":"awesome-cli delete-all"},{"location":"typer-cli/#awesome-cli-init","text":"Initialize the users database. Usage : $ awesome-cli init [ OPTIONS ] Options : --help : Show this message and exit.","title":"awesome-cli init"},{"location":"typer-cli/#license","text":"Typer CLI , the same as Typer , is licensed under the terms of the MIT license.","title":"License"},{"location":"tutorial/","text":"Python types \u00b6 If you need a refreshed about how to use Python type hints, check the first part of FastAPI's Python types intro . You can also check the mypy cheat sheet . In short (very short), you can declare a function with parameters like: from typing import Optional def type_example ( name : str , formal : bool = False , intro : Optional [ str ] = None ): pass And your editor (and Typer ) will know that: name is of type str and is a required parameter. formal is a bool and is by default False . intro is an optional str , by default is None . These type hints are what give you autocomplete in your editor and several other features. Typer is based on these type hints. Intro \u00b6 This tutorial shows you how to use Typer with all its features, step by step. Each section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific CLI needs. It is also built to work as a future reference. So you can come back and see exactly what you need. Run the code \u00b6 All the code blocks can be copied and used directly (they are tested Python files). To run any of the examples, copy the code to a file main.py , and run it: $ python main.py \u2728 The magic happens here \u2728 It is HIGHLY encouraged that you write or copy the code, edit it and run it locally. Using it in your editor is what really shows you the benefits of Typer , seeing how little code you have to write, all the type checks, autocompletion, etc. And running the examples is what will really help you understand what is going on. You can learn a lot more by running some examples and playing around with them than by reading all the docs here. Install Typer \u00b6 The first step is to install Typer . For the tutorial, you might want to install it with all the optional dependencies and features: $ pip install typer [ all ] ---> 100% Successfully installed typer click colorama shellingham ...that also includes colorama and shellingham .","title":"Tutorial - User Guide - Intro"},{"location":"tutorial/#python-types","text":"If you need a refreshed about how to use Python type hints, check the first part of FastAPI's Python types intro . You can also check the mypy cheat sheet . In short (very short), you can declare a function with parameters like: from typing import Optional def type_example ( name : str , formal : bool = False , intro : Optional [ str ] = None ): pass And your editor (and Typer ) will know that: name is of type str and is a required parameter. formal is a bool and is by default False . intro is an optional str , by default is None . These type hints are what give you autocomplete in your editor and several other features. Typer is based on these type hints.","title":"Python types"},{"location":"tutorial/#intro","text":"This tutorial shows you how to use Typer with all its features, step by step. Each section gradually builds on the previous ones, but it's structured to separate topics, so that you can go directly to any specific one to solve your specific CLI needs. It is also built to work as a future reference. So you can come back and see exactly what you need.","title":"Intro"},{"location":"tutorial/#run-the-code","text":"All the code blocks can be copied and used directly (they are tested Python files). To run any of the examples, copy the code to a file main.py , and run it: $ python main.py \u2728 The magic happens here \u2728 It is HIGHLY encouraged that you write or copy the code, edit it and run it locally. Using it in your editor is what really shows you the benefits of Typer , seeing how little code you have to write, all the type checks, autocompletion, etc. And running the examples is what will really help you understand what is going on. You can learn a lot more by running some examples and playing around with them than by reading all the docs here.","title":"Run the code"},{"location":"tutorial/#install-typer","text":"The first step is to install Typer . For the tutorial, you might want to install it with all the optional dependencies and features: $ pip install typer [ all ] ---> 100% Successfully installed typer click colorama shellingham ...that also includes colorama and shellingham .","title":"Install Typer"},{"location":"tutorial/app-dir/","text":"You can get the application directory where you can, for example, save configuration files with typer.get_app_dir() : from pathlib import Path import typer APP_NAME = \"my-super-cli-app\" def main (): app_dir = typer . get_app_dir ( APP_NAME ) config_path : Path = Path ( app_dir ) / \"config.json\" if not config_path . is_file (): typer . echo ( \"Config file doesn't exist yet\" ) if __name__ == \"__main__\" : typer . run ( main ) It will give you a directory for storing configurations appropriate for your CLI program for the current user in each operating system. Check it: $ python main.py Config file doesn't exist yet About Path \u00b6 If you hadn't seen something like that: Path ( app_dir ) / \"config.json\" A Path object can be used with / and it will convert it to the separator for the current system ( / for Unix systems and \\ for Windows). If the first element is a Path object the next ones (after the / ) can be str . And it will create a new Path object from that. If you want a quick guide on using Path() you can check this post on Real Python or this post by Trey Hunner . In the code above, we are also explicitly declaring config_path as having type Path to help the editor provide completion and type checks: config_path : Path = Path ( app_dir ) / \"config.json\" Otherwise it could think it's a sub-type (a PurePath ) and stop providing completion for some methods.","title":"CLI Application Directory"},{"location":"tutorial/app-dir/#about-path","text":"If you hadn't seen something like that: Path ( app_dir ) / \"config.json\" A Path object can be used with / and it will convert it to the separator for the current system ( / for Unix systems and \\ for Windows). If the first element is a Path object the next ones (after the / ) can be str . And it will create a new Path object from that. If you want a quick guide on using Path() you can check this post on Real Python or this post by Trey Hunner . In the code above, we are also explicitly declaring config_path as having type Path to help the editor provide completion and type checks: config_path : Path = Path ( app_dir ) / \"config.json\" Otherwise it could think it's a sub-type (a PurePath ) and stop providing completion for some methods.","title":"About Path"},{"location":"tutorial/first-steps/","text":"The simplest example \u00b6 The simplest Typer file could look like this: import typer def main (): typer . echo ( \"Hello World\" ) if __name__ == \"__main__\" : typer . run ( main ) Tip You will learn more about typer.echo() later in the docs. Copy that to a file main.py . Test it: $ python main.py Hello World // It just prints \"Hello World\". // Now check the --help $ python main.py --help Usage: main.py [OPTIONS] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. ...but this program is still not very useful. Let's extend it. What is a CLI argument \u00b6 Here we will use the word CLI argument to refer to CLI parameters passed in some specific order to the CLI application. By default, they are required . If you go to your terminal and type: $ ls ./myproject first-steps.md intro.md ls will show the contents of the directory ./myproject . ls is the program (or \"command\", \"CLI app\"). ./myproject is a CLI argument , in this case it refers to the path of a directory. They are a bit different from CLI options that you will see later below. Add a CLI argument \u00b6 Update the previous example with an argument name : import typer def main ( name : str ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) $ python main.py // If you run it without the argument, it shows a nice error Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument 'NAME'. // Now pass that NAME CLI argument $ python main.py Camila Hello Camila // Here \"Camila\" is the CLI argument // To pass a name with spaces for the same CLI argument, use quotes $ python main.py \"Camila Guti\u00e9rrez\" Hello Camila Guti\u00e9rrez Tip If you need to pass a single value that contains spaces to a CLI argument , use quotes ( \" ) around it. Two CLI arguments \u00b6 Now let's say we want to have the name and last name separated. So, extend that to have 2 arguments, name and lastname : import typer def main ( name : str , lastname : str ): typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) // Check the main --help $ python main.py --help Usage: main.py [OPTIONS] NAME LASTNAME Arguments: NAME [required] LASTNAME [required] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // There are now 2 CLI arguments, name and lastname // Now pass a single name argument $ python main.py Camila Usage: main.py [OPTIONS] NAME LASTNAME Try \"main.py --help\" for help. Error: Missing argument 'LASTNAME'. // These 2 arguments are required, so, pass both: $ python main.py Camila Guti\u00e9rrez Hello Camila Guti\u00e9rrez Tip Notice that the order is important. The last name has to go after the first name. If you called it with: $ python main.py Guti\u00e9rrez Camila your app wouldn't have a way to know which is the name and which the lastname . It expects the first CLI argument to be the name and the second CLI argument to be the lastname . What is a CLI option \u00b6 Here we will use the word CLI option to refer to CLI parameters passed to the CLI application with a specific name. For example, if you go to your terminal and type: $ ls ./myproject --size 12 first-steps.md 4 intro.md ls will show the contents of the directory ./myproject with their size . ls is the program (or \"command\", \"CLI app\"). ./myproject is a CLI argument . --size is an optional CLI option . The program knows it has to show the size because it sees --size , not because of the order. A CLI option like --size doesn't depend on the order like a CLI argument . So, if you put the --size before the CLI argument , it still works (in fact, that's the most common way of doing it): $ ls --size ./myproject 12 first-steps.md 4 intro.md The main visual difference between a CLI option and and a CLI argument is that the CLI option has -- prepended to the name, like in \" --size \". A CLI option doesn't depend on the order because it has a predefined name (here it's --size ). This is because the CLI app is looking specifically for a literal --size parameter (also known as \"flag\" or \"switch\"), with that specific \"name\" (here the specific name is \" --size \"). The CLI app will check if you typed it or not, it will be actively looking for --size even if you didn't type it (to check if it's there or not). In contrast, the CLI app is not actively looking for the CLI argument with a text \" ./myproject \", it has no way to know if you would type ./myproject or ./my-super-awesome-project or anything else. It's just waiting to get whatever you give it. The only way to know that you refer to a specific CLI argument is because of the order. The same way that it knows that the first CLI argument was the name and the second was the lastname , but if you mixed the order, it wouldn't be able to handle it. Instead, with a CLI option , the order doesn't matter. Also, by default, a CLI option is optional (not required ). So, by default: A CLI argument is required A CLI option is optional But the required and optional defaults can be changed. So, the main and most important difference is that: CLI options start with -- and don't depend on the order CLI arguments depend on the sequence order Tip In this example above the CLI option --size is just a \"flag\" or \"switch\" that will contain a boolean value, True or False , depending on if it was added to the command or not. This one doesn't receive any values. But CLI options can also receive values like CLI arguments . You'll see how later. Add one CLI option \u00b6 Now add a --formal CLI option : import typer def main ( name : str , lastname : str , formal : bool = False ): if formal : typer . echo ( f \"Good day Ms. { name } { lastname } .\" ) else : typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) Here formal is a bool that is False by default. // Get the help $ python main.py --help Usage: main.py [OPTIONS] NAME LASTNAME Arguments: NAME [required] LASTNAME [required] Options: --formal / --no-formal [default: False] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip Notice that it automatically creates a --formal and a --no-formal because it detected that formal is a bool . Now call it normally: $ python main.py Camila Guti\u00e9rrez Hello Camila Guti\u00e9rrez // But if you pass --formal $ python main.py Camila Guti\u00e9rrez --formal Good day Ms. Camila Guti\u00e9rrez. // And as --formal is a CLI option you can put it anywhere in this command $ python main.py Camila --formal Guti\u00e9rrez Good day Ms. Camila Guti\u00e9rrez. $ python main.py --formal Camila Guti\u00e9rrez Good day Ms. Camila Guti\u00e9rrez. A CLI option with a value \u00b6 To convert the lastname from a CLI argument to a CLI option , give it a default value of \"\" : import typer def main ( name : str , lastname : str = \"\" , formal : bool = False ): if formal : typer . echo ( f \"Good day Ms. { name } { lastname } .\" ) else : typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) As lastname now has a default value of \"\" (an empty string) it is no longer required in the function, and Typer will now by default make it an optional CLI option . $ python main.py --help Usage: main.py [OPTIONS] NAME Arguments: NAME [required] Options: --lastname TEXT [default: ] --formal / --no-formal [default: False] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip Notice the --lastname , and notice that it takes a textual value. A CLI option with a value like --lastname (contrary to a CLI option without a value, a bool flag, like --formal or --size ) takes as its value whatever is at the right side of the CLI option . // Call it without a --lastname $ python main.py Camila Hello Camila // Pass the --lastname $ python main.py Camila --lastname Guti\u00e9rrez Hello Camila Guti\u00e9rrez Tip Notice that \" Guti\u00e9rrez \" is at the right side of --lastname . A CLI option with a value takes as its value whatever is at the right side . And as --lastname is now a CLI option that doesn't depend on the order, you can pass it before the name: $ python main.py --lastname Guti\u00e9rrez Camila // and it will still work normally Hello Camila Guti\u00e9rrez Document your CLI app \u00b6 If you add a docstring to your function it will be used in the help text: import typer def main ( name : str , lastname : str = \"\" , formal : bool = False ): \"\"\" Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. \"\"\" if formal : typer . echo ( f \"Good day Ms. { name } { lastname } .\" ) else : typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) Now see it with the --help option: $ python main.py --help Usage: main.py [OPTIONS] NAME Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. Arguments: NAME [required] Options: --lastname TEXT [default: ] --formal / --no-formal [default: False] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip There is another place to document the specific CLI options and CLI arguments that will show up next to them in the help text as with --install-completion or --help , you will learn that later in the tutorial. Arguments, options, parameters, optional, required \u00b6 Be aware that these terms refer to multiple things depending on the context, and sadly, those \"contexts\" mix frequently, so it's easy to get confused. In Python \u00b6 In Python, the names of the variables in a function, like name and lastname : def main ( name : str , lastname : str = \"\" ): pass are called \"Python function parameters\" or \"Python function arguments\". Technical Details There's actually a very small distinction in Python between \"parameter\" and \"argument\". It's quite technical... and somewhat pedantic. One refers to the variable name in a function declaration . Like: def bring_person(name: str, lastname: str = \"\"): pass The other refers to the value passed when calling a function. Like: person = bring_person(\"Camila\", lastname=\"Guti\u00e9rrez\") ...but you will probably see them used interchangeably in most of the places (including here). Python default values \u00b6 In Python, in a function, a parameter with a default value like lastname in: def main ( name : str , lastname : str = \"\" ): pass is considered an \"optional parameter\" (or \"optional argument\"). The default value can be anything, like \"\" or None . And a parameter like name , that doesn't have a default value, is considered required . In CLIs \u00b6 When talking about command line interface applications, the words \"argument\" and \"parameter\" are commonly used to refer to that data passed to a CLI app, those parameters. But those words don't imply anything about the data being required, needing to be passed in a certain order, nor having a flag like --lastname . The parameters that come with a name like --lastname (and optionally a value) are commonly optional, not required. So, when talking about CLIs it's common to call them optional arguments or optional parameters . Sometimes these optional parameters that start with -- are also called a flag or a switch . In reality, the parameters that require an order can be made optional too. And the ones that come with a flag (like --lastname ) can be required too. In Typer \u00b6 To try and make it a bit easier, we'll normally use the words \"parameter\" or \"argument\" to refer to Python functions. We'll use CLI argument to refer to those CLI parameters that depend on the specific order. That are required by default. And we'll use CLI option to refer to those CLI parameters that depend on a name that starts with -- (like --lastname ). That are optional by default. We will use CLI parameter to refer to both, CLI arguments and CLI options . Typer CLI \u00b6 Now that you know the basics of Typer , you might want to install and use Typer CLI . Typer CLI is a tool to run your Typer scripts giving you \u2728 auto completion \u2728 in your terminal. As an alternative to running with Python: $ python main.py Hello World You can run with Typer CLI : $ typer main.py run Hello World ...and it will give you auto completion in your terminal when you hit TAB for all your code. So you can use it to have auto completion for your own scripts as you continue with the tutorial. Tip Your CLI application built with Typer won't need Typer CLI to have auto completion once you create a Python package. But for short scripts and for learning, before creating a Python package, it might be useful.","title":"First Steps"},{"location":"tutorial/first-steps/#the-simplest-example","text":"The simplest Typer file could look like this: import typer def main (): typer . echo ( \"Hello World\" ) if __name__ == \"__main__\" : typer . run ( main ) Tip You will learn more about typer.echo() later in the docs. Copy that to a file main.py . Test it: $ python main.py Hello World // It just prints \"Hello World\". // Now check the --help $ python main.py --help Usage: main.py [OPTIONS] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. ...but this program is still not very useful. Let's extend it.","title":"The simplest example"},{"location":"tutorial/first-steps/#what-is-a-cli-argument","text":"Here we will use the word CLI argument to refer to CLI parameters passed in some specific order to the CLI application. By default, they are required . If you go to your terminal and type: $ ls ./myproject first-steps.md intro.md ls will show the contents of the directory ./myproject . ls is the program (or \"command\", \"CLI app\"). ./myproject is a CLI argument , in this case it refers to the path of a directory. They are a bit different from CLI options that you will see later below.","title":"What is a CLI argument"},{"location":"tutorial/first-steps/#add-a-cli-argument","text":"Update the previous example with an argument name : import typer def main ( name : str ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) $ python main.py // If you run it without the argument, it shows a nice error Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument 'NAME'. // Now pass that NAME CLI argument $ python main.py Camila Hello Camila // Here \"Camila\" is the CLI argument // To pass a name with spaces for the same CLI argument, use quotes $ python main.py \"Camila Guti\u00e9rrez\" Hello Camila Guti\u00e9rrez Tip If you need to pass a single value that contains spaces to a CLI argument , use quotes ( \" ) around it.","title":"Add a CLI argument"},{"location":"tutorial/first-steps/#two-cli-arguments","text":"Now let's say we want to have the name and last name separated. So, extend that to have 2 arguments, name and lastname : import typer def main ( name : str , lastname : str ): typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) // Check the main --help $ python main.py --help Usage: main.py [OPTIONS] NAME LASTNAME Arguments: NAME [required] LASTNAME [required] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // There are now 2 CLI arguments, name and lastname // Now pass a single name argument $ python main.py Camila Usage: main.py [OPTIONS] NAME LASTNAME Try \"main.py --help\" for help. Error: Missing argument 'LASTNAME'. // These 2 arguments are required, so, pass both: $ python main.py Camila Guti\u00e9rrez Hello Camila Guti\u00e9rrez Tip Notice that the order is important. The last name has to go after the first name. If you called it with: $ python main.py Guti\u00e9rrez Camila your app wouldn't have a way to know which is the name and which the lastname . It expects the first CLI argument to be the name and the second CLI argument to be the lastname .","title":"Two CLI arguments"},{"location":"tutorial/first-steps/#what-is-a-cli-option","text":"Here we will use the word CLI option to refer to CLI parameters passed to the CLI application with a specific name. For example, if you go to your terminal and type: $ ls ./myproject --size 12 first-steps.md 4 intro.md ls will show the contents of the directory ./myproject with their size . ls is the program (or \"command\", \"CLI app\"). ./myproject is a CLI argument . --size is an optional CLI option . The program knows it has to show the size because it sees --size , not because of the order. A CLI option like --size doesn't depend on the order like a CLI argument . So, if you put the --size before the CLI argument , it still works (in fact, that's the most common way of doing it): $ ls --size ./myproject 12 first-steps.md 4 intro.md The main visual difference between a CLI option and and a CLI argument is that the CLI option has -- prepended to the name, like in \" --size \". A CLI option doesn't depend on the order because it has a predefined name (here it's --size ). This is because the CLI app is looking specifically for a literal --size parameter (also known as \"flag\" or \"switch\"), with that specific \"name\" (here the specific name is \" --size \"). The CLI app will check if you typed it or not, it will be actively looking for --size even if you didn't type it (to check if it's there or not). In contrast, the CLI app is not actively looking for the CLI argument with a text \" ./myproject \", it has no way to know if you would type ./myproject or ./my-super-awesome-project or anything else. It's just waiting to get whatever you give it. The only way to know that you refer to a specific CLI argument is because of the order. The same way that it knows that the first CLI argument was the name and the second was the lastname , but if you mixed the order, it wouldn't be able to handle it. Instead, with a CLI option , the order doesn't matter. Also, by default, a CLI option is optional (not required ). So, by default: A CLI argument is required A CLI option is optional But the required and optional defaults can be changed. So, the main and most important difference is that: CLI options start with -- and don't depend on the order CLI arguments depend on the sequence order Tip In this example above the CLI option --size is just a \"flag\" or \"switch\" that will contain a boolean value, True or False , depending on if it was added to the command or not. This one doesn't receive any values. But CLI options can also receive values like CLI arguments . You'll see how later.","title":"What is a CLI option"},{"location":"tutorial/first-steps/#add-one-cli-option","text":"Now add a --formal CLI option : import typer def main ( name : str , lastname : str , formal : bool = False ): if formal : typer . echo ( f \"Good day Ms. { name } { lastname } .\" ) else : typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) Here formal is a bool that is False by default. // Get the help $ python main.py --help Usage: main.py [OPTIONS] NAME LASTNAME Arguments: NAME [required] LASTNAME [required] Options: --formal / --no-formal [default: False] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip Notice that it automatically creates a --formal and a --no-formal because it detected that formal is a bool . Now call it normally: $ python main.py Camila Guti\u00e9rrez Hello Camila Guti\u00e9rrez // But if you pass --formal $ python main.py Camila Guti\u00e9rrez --formal Good day Ms. Camila Guti\u00e9rrez. // And as --formal is a CLI option you can put it anywhere in this command $ python main.py Camila --formal Guti\u00e9rrez Good day Ms. Camila Guti\u00e9rrez. $ python main.py --formal Camila Guti\u00e9rrez Good day Ms. Camila Guti\u00e9rrez.","title":"Add one CLI option"},{"location":"tutorial/first-steps/#a-cli-option-with-a-value","text":"To convert the lastname from a CLI argument to a CLI option , give it a default value of \"\" : import typer def main ( name : str , lastname : str = \"\" , formal : bool = False ): if formal : typer . echo ( f \"Good day Ms. { name } { lastname } .\" ) else : typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) As lastname now has a default value of \"\" (an empty string) it is no longer required in the function, and Typer will now by default make it an optional CLI option . $ python main.py --help Usage: main.py [OPTIONS] NAME Arguments: NAME [required] Options: --lastname TEXT [default: ] --formal / --no-formal [default: False] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip Notice the --lastname , and notice that it takes a textual value. A CLI option with a value like --lastname (contrary to a CLI option without a value, a bool flag, like --formal or --size ) takes as its value whatever is at the right side of the CLI option . // Call it without a --lastname $ python main.py Camila Hello Camila // Pass the --lastname $ python main.py Camila --lastname Guti\u00e9rrez Hello Camila Guti\u00e9rrez Tip Notice that \" Guti\u00e9rrez \" is at the right side of --lastname . A CLI option with a value takes as its value whatever is at the right side . And as --lastname is now a CLI option that doesn't depend on the order, you can pass it before the name: $ python main.py --lastname Guti\u00e9rrez Camila // and it will still work normally Hello Camila Guti\u00e9rrez","title":"A CLI option with a value"},{"location":"tutorial/first-steps/#document-your-cli-app","text":"If you add a docstring to your function it will be used in the help text: import typer def main ( name : str , lastname : str = \"\" , formal : bool = False ): \"\"\" Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. \"\"\" if formal : typer . echo ( f \"Good day Ms. { name } { lastname } .\" ) else : typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) Now see it with the --help option: $ python main.py --help Usage: main.py [OPTIONS] NAME Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. Arguments: NAME [required] Options: --lastname TEXT [default: ] --formal / --no-formal [default: False] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip There is another place to document the specific CLI options and CLI arguments that will show up next to them in the help text as with --install-completion or --help , you will learn that later in the tutorial.","title":"Document your CLI app"},{"location":"tutorial/first-steps/#arguments-options-parameters-optional-required","text":"Be aware that these terms refer to multiple things depending on the context, and sadly, those \"contexts\" mix frequently, so it's easy to get confused.","title":"Arguments, options, parameters, optional, required"},{"location":"tutorial/first-steps/#in-python","text":"In Python, the names of the variables in a function, like name and lastname : def main ( name : str , lastname : str = \"\" ): pass are called \"Python function parameters\" or \"Python function arguments\". Technical Details There's actually a very small distinction in Python between \"parameter\" and \"argument\". It's quite technical... and somewhat pedantic. One refers to the variable name in a function declaration . Like: def bring_person(name: str, lastname: str = \"\"): pass The other refers to the value passed when calling a function. Like: person = bring_person(\"Camila\", lastname=\"Guti\u00e9rrez\") ...but you will probably see them used interchangeably in most of the places (including here).","title":"In Python"},{"location":"tutorial/first-steps/#python-default-values","text":"In Python, in a function, a parameter with a default value like lastname in: def main ( name : str , lastname : str = \"\" ): pass is considered an \"optional parameter\" (or \"optional argument\"). The default value can be anything, like \"\" or None . And a parameter like name , that doesn't have a default value, is considered required .","title":"Python default values"},{"location":"tutorial/first-steps/#in-clis","text":"When talking about command line interface applications, the words \"argument\" and \"parameter\" are commonly used to refer to that data passed to a CLI app, those parameters. But those words don't imply anything about the data being required, needing to be passed in a certain order, nor having a flag like --lastname . The parameters that come with a name like --lastname (and optionally a value) are commonly optional, not required. So, when talking about CLIs it's common to call them optional arguments or optional parameters . Sometimes these optional parameters that start with -- are also called a flag or a switch . In reality, the parameters that require an order can be made optional too. And the ones that come with a flag (like --lastname ) can be required too.","title":"In CLIs"},{"location":"tutorial/first-steps/#in-typer","text":"To try and make it a bit easier, we'll normally use the words \"parameter\" or \"argument\" to refer to Python functions. We'll use CLI argument to refer to those CLI parameters that depend on the specific order. That are required by default. And we'll use CLI option to refer to those CLI parameters that depend on a name that starts with -- (like --lastname ). That are optional by default. We will use CLI parameter to refer to both, CLI arguments and CLI options .","title":"In Typer"},{"location":"tutorial/first-steps/#typer-cli","text":"Now that you know the basics of Typer , you might want to install and use Typer CLI . Typer CLI is a tool to run your Typer scripts giving you \u2728 auto completion \u2728 in your terminal. As an alternative to running with Python: $ python main.py Hello World You can run with Typer CLI : $ typer main.py run Hello World ...and it will give you auto completion in your terminal when you hit TAB for all your code. So you can use it to have auto completion for your own scripts as you continue with the tutorial. Tip Your CLI application built with Typer won't need Typer CLI to have auto completion once you create a Python package. But for short scripts and for learning, before creating a Python package, it might be useful.","title":"Typer CLI"},{"location":"tutorial/launch/","text":"You can launch applications from your CLI program with typer.launch() . It will launch the appropriate application depending on the URL or file type you pass it: import typer def main (): typer . echo ( \"Opening Typer's docs\" ) typer . launch ( \"https://typer.tiangolo.com\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py Opening Typer docs // Opens browser with Typer's docs Locating a file \u00b6 You can also make the operating system open the file browser indicating where a file is located with locate=True : from pathlib import Path import typer APP_NAME = \"my-super-cli-app\" def main (): app_dir = typer . get_app_dir ( APP_NAME ) app_dir_path = Path ( app_dir ) app_dir_path . mkdir ( parents = True , exist_ok = True ) config_path : Path = Path ( app_dir ) / \"config.json\" if not config_path . is_file (): config_path . write_text ( '{\"version\": \"1.0.0\"}' ) config_file_str = str ( config_path ) typer . echo ( \"Opening config directory\" ) typer . launch ( config_file_str , locate = True ) if __name__ == \"__main__\" : typer . run ( main ) Tip The rest of the code in this example is just making sure the app directory exists and creating the config file. But the most important part is the typer.launch(config_file_str, locate=True) with the argument locate=True . Check it: $ python main.py Opening config directory // Opens a file browser indicating where the config file is located","title":"Launching Applications"},{"location":"tutorial/launch/#locating-a-file","text":"You can also make the operating system open the file browser indicating where a file is located with locate=True : from pathlib import Path import typer APP_NAME = \"my-super-cli-app\" def main (): app_dir = typer . get_app_dir ( APP_NAME ) app_dir_path = Path ( app_dir ) app_dir_path . mkdir ( parents = True , exist_ok = True ) config_path : Path = Path ( app_dir ) / \"config.json\" if not config_path . is_file (): config_path . write_text ( '{\"version\": \"1.0.0\"}' ) config_file_str = str ( config_path ) typer . echo ( \"Opening config directory\" ) typer . launch ( config_file_str , locate = True ) if __name__ == \"__main__\" : typer . run ( main ) Tip The rest of the code in this example is just making sure the app directory exists and creating the config file. But the most important part is the typer.launch(config_file_str, locate=True) with the argument locate=True . Check it: $ python main.py Opening config directory // Opens a file browser indicating where the config file is located","title":"Locating a file"},{"location":"tutorial/package/","text":"When you create a CLI program with Typer you probably want to create your own Python package. That's what allows your users to install it and have it as an independent program that they can use in their terminal. And that's also required for shell auto completion to work (unless you use your program through Typer CLI ). Nowadays, there are several ways and tools to create Python packages (what you install with pip install something ). You might even have your favorite already. Here's a very opinionated, short guide, showing one of the alternative ways of creating a Python package with a Typer app, from scratch. Tip If you already have a favorite way of creating Python packages, feel free to skip this. Prerequisites \u00b6 For this guide we'll use Poetry . Poetry's docs are great, so go ahead, check them and install it. Create a project \u00b6 Let's say we want to create a CLI application called portal-gun . To make sure your package doesn't collide with the package created by someone else, we'll name it with a prefix of your name. So, if your name is Rick, we'll call it rick-portal-gun . Create a project with Poetry: $ poetry new rick-portal-gun Created package rick_portal_gun in rick-portal-gun // Enter the new project directory cd ./rick-portal-gun Dependencies and environment \u00b6 Add typer[all] to your dependencies: $ poetry add typer [ all ] // It creates a virtual environment for your project Creating virtualenv rick-portal-gun-w31dJa0b-py3.6 in /home/rick/.cache/pypoetry/virtualenvs Using version ^0.1.0 for typer Updating dependencies Resolving dependencies... (1.2s) Writing lock file ---> 100% Package operations: 15 installs, 0 updates, 0 removals - Installing zipp (3.1.0) - Installing importlib-metadata (1.5.0) - Installing pyparsing (2.4.6) - Installing six (1.14.0) - Installing attrs (19.3.0) - Installing click (7.1.1) - Installing colorama (0.4.3) - Installing more-itertools (8.2.0) - Installing packaging (20.3) - Installing pluggy (0.13.1) - Installing py (1.8.1) - Installing shellingham (1.3.2) - Installing wcwidth (0.1.8) - Installing pytest (5.4.1) - Installing typer (0.0.11) // Activate that new virtual environment $ poetry shell Spawning shell within /home/rick/.cache/pypoetry/virtualenvs/rick-portal-gun-w31dJa0b-py3.6 // Open an editor using this new environment, for example VS Code $ code ./ You can see that you have a generated project structure that looks like: . \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.rst \u251c\u2500\u2500 rick_portal_gun \u2502 \u2514\u2500\u2500 __init__.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_rick_portal_gun.py Create your app \u00b6 Now let's create an extremely simple Typer app. Create a file rick_portal_gun/main.py with: import typer app = typer . Typer () @app . callback () def callback (): \"\"\" Awesome Portal Gun \"\"\" @app . command () def shoot (): \"\"\" Shoot the portal gun \"\"\" typer . echo ( \"Shooting portal gun\" ) @app . command () def load (): \"\"\" Load the portal gun \"\"\" typer . echo ( \"Loading portal gun\" ) Tip As we are creating an installable Python package, there's no need to add a section with if __name__ == \"__main__: . Modify the README \u00b6 Let's change the README. By default it's a file README.rst . Let's change it to README.md . So, change the extension from .rst to .md . So that we can use Markdown instead of reStructuredText. And change the file to have something like: # Portal Gun The awesome Portal Gun Modify your project metadata \u00b6 Edit your file pyproject.toml . It would look something like: [tool.poetry] name = \"rick-portal-gun\" version = \"0.1.0\" description = \"\" authors = [\"Rick Sanchez <rick@example.com>\"] [tool.poetry.dependencies] python = \"^3.6\" typer = { extras = [ \"all\" ], version = \"^0.1.0\" } [tool.poetry.dev-dependencies] pytest = \"^5.2\" [build-system] requires = [\"poetry>=0.12\"] build-backend = \"poetry.masonry.api\" We changed the default README, so let's make it use the new README.md . Add the line: [tool.poetry] name = \"rick-portal-gun\" version = \"0.1.0\" description = \"\" authors = [\"Rick Sanchez <rick@example.com>\"] readme = \"README.md\" [tool.poetry.dependencies] python = \"^3.6\" typer = { extras = [ \"all\" ], version = \"^0.1.0\" } [tool.poetry.dev-dependencies] pytest = \"^5.2\" [build-system] requires = [\"poetry>=0.12\"] build-backend = \"poetry.masonry.api\" Add a \"script\" \u00b6 We are creating a Python package that can be installed with pip install . But we want it to provide a CLI program that can be executed in the shell. To do that, we add a configuration to the pyproject.toml in the section [tool.poetry.scripts] : [tool.poetry] name = \"rick-portal-gun\" version = \"0.1.0\" description = \"\" authors = [\"Rick Sanchez <rick@example.com>\"] readme = \"README.md\" [tool.poetry.scripts] rick-portal-gun = \"rick_portal_gun.main:app\" [tool.poetry.dependencies] python = \"^3.6\" typer = { extras = [ \"all\" ], version = \"^0.1.0\" } [tool.poetry.dev-dependencies] pytest = \"^5.2\" [build-system] requires = [\"poetry>=0.12\"] build-backend = \"poetry.masonry.api\" Here's what that line means: rick-portal-gun : will be the name of the CLI program. That's how we will call it in the terminal once it is installed. Like: $ rick-portal-gun // Something happens here \u2728 rick_portal_gun.main , in the part \"rick_portal_gun.main:app\" , with underscores, refers to the Python module to import. That's what someone would use in a section like: from rick_portal_gun.main import # something goes here The app in \"rick_portal_gun.main:app\" is the thing to import from the module, and to call as a function, like: from rick_portal_gun.main import app app () That config section tells Poetry that when this package is installed we want it to create a command line program called rick-portal-gun . And that the object to call (like a function) is the one in the variable app inside of the module rick_portal_gun.main . Install your package \u00b6 That's what we need to create a package. You can now install it: $ poetry install Installing dependencies from lock file No dependencies to install or update - Installing rick-portal-gun (0.1.0) Try your CLI program \u00b6 Your package is installed in the environment created by Poetry, but you can already use it. // You can use the which program to check which rick-portal-gun program is available (if any) $ which rick-portal-gun // You get the one from your environment /home/rick/.cache/pypoetry/virtualenvs/rick-portal-gun-w31dJa0b-py3.6/bin/rick-portal-gun // Try it $ rick-portal-gun // You get all the standard help Usage: rick-portal-gun [OPTIONS] COMMAND [ARGS]... Awesome Portal Gun Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: load Load the portal gun shoot Shoot the portal gun Create a wheel package \u00b6 Python packages have a standard format called a \"wheel\". It's a file that ends in .whl . You can create a wheel with Poetry: $ poetry build Building rick-portal-gun (0.1.0) - Building sdist - Built rick-portal-gun-0.1.0.tar.gz - Building wheel - Built rick_portal_gun-0.1.0-py3-none-any.whl After that, if you check in your project directory, you should now have a couple of extra files at ./dist/ : . \u251c\u2500\u2500 dist \u2502 \u251c\u2500\u2500 rick_portal_gun-0.1.0-py3-none-any.whl \u2502 \u2514\u2500\u2500 rick-portal-gun-0.1.0.tar.gz \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.md \u251c\u2500\u2500 ... The .whl is the wheel file. You can send that wheel file to anyone and they can use it to install your program (we'll see how to upload it to PyPI in a bit). Test your wheel package \u00b6 Now you can open another terminal and install that package from the file for your own user with: $ pip install --user /home/rock/code/rick-portal-gun/dist/rick_portal_gun-0.1.0-py3-none-any.whl ---> 100% Warning The --user is important, that ensures you install it in your user's directory and not in the global system. If you installed it in the global system (e.g. with sudo ) you could install a version of a library (e.g. a sub-dependency) that is incompatible with your system. Tip Bonus points if you use pipx to install it while keeping an isolated environment for your Python CLI programs \ud83d\ude80 Now you have your CLI program installed. And you can use it freely: $ rick-portal-gun shoot // It works \ud83c\udf89 Shooting portal gun Having it installed globally (and not in a single environment), you can now install completion globally for it: $ rick-portal-gun --install-completion zsh completion installed in /home/user/.zshrc. Completion will take effect once you restart the terminal. Tip If you want to remove completion you can just delete the added line in that file. And after you restart the terminal you will get completion for your new CLI program: $ rick-portal-gun [ TAB ][ TAB ] // You get completion for your CLI program \u2728 load -- Load the portal gun shoot -- Shoot the portal gun Support python -m (optional) \u00b6 You may have seen that you can call many Python modules as scripts with python -m some-module . For example, one way to call pip is: $ pip install fastapi But you can also call Python with the -m CLI Option and pass a module for it to execute as if it was a script, like: $ python -m pip install fastapi Here we pass pip as the value for -m , so, Python will execute the module pip as if it was a script. And then it will pass the rest of the CLI Parameters ( install fastapi ) to it. These two are more or less equivalent, the install fastapi will be passed to pip . Tip In the case of pip , in many occasions it's actually recommended that you run it with python -m , because if you create a virtual environment with its own python , that will ensure that you use the pip from that environment. Add a __main__.py \u00b6 You can support that same style of calling the package/module for your own package, simply by adding a file __main__.py . Python will look for that file and execute it. The file would live right beside __init__.py : . \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.rst \u251c\u2500\u2500 rick_portal_gun \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 __main__.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_rick_portal_gun.py No other file has to import it, you don't have to reference it in your pyproject.toml or anything else, it just works by default, as it is standard Python behavior. Then in that file you can execute your Typer program: from .main import app app () Now, after installing your package, if you call it with python -m it will work (for the main part): $ python -m rick_portal_gun Usage: __main__.py [OPTIONS] COMMAND [ARGS]... Awesome Portal Gun Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: load Load the portal gun shoot Shoot the portal gun Tip Notice that you have to pass the importable version of the package name, so rick_portal_gun instead of rick-portal-gun . That works! \ud83d\ude80 Sort of... \ud83e\udd14 See the __main__.py in the help instead of rick-portal-gun ? We'll fix that next. Set a program name in __main__.py \u00b6 We are setting the program name in the file pyproject.toml in the line like: [tool.poetry.scripts] rick-portal-gun = \"rick_portal_gun.main:app\" But when Python runs our package as a script with python -m , it doesn't have the information of the program name. So, to fix the help text to use the correct program name when called with python -m , we can pass it to the app in __main__.py : from .main import app app ( prog_name = \"rick-portal-gun\" ) Tip You can pass all the arguments and keyword arguments you could pass to a Click application, including prog_name . $ python -m rick_portal_gun Usage: rick-portal-gun [OPTIONS] COMMAND [ARGS]... Awesome Portal Gun Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: load Load the portal gun shoot Shoot the portal gun Great! That works correctly! \ud83c\udf89 \u2705 Notice that now it uses rick-portal-gun instead of __main__.py in the help. Autocompletion and python -m \u00b6 Have in mind that TAB completion (shell auto-completion) won't work when using python -m . Auto-completion depends on the name of the program called, it's tied to each specific program name. So, to have shell completion for rick-portal-gun you would have to call it directly: $ rick-portal-gun [ TAB ][ TAB ] But you can still support python -m for the cases where it's useful. Publish to PyPI (optional) \u00b6 You can publish that new package to PyPI to make it public, so others can install it easily. So, go ahead and create an account there (it's free). PyPI API token \u00b6 To do it, you first need to configure a PyPI auth token. Login to PyPI . And then go to https://pypi.org/manage/account/token/ to create a new token. Let's say your new API token is: pypi-wubalubadubdub-deadbeef1234 Now configure Poetry to use this token with the command poetry config pypi-token.pypi : $ poetry config pypi-token.pypi pypi-wubalubadubdub-deadbeef1234 // It won't show any output, but it's already configured Publish to PyPI \u00b6 Now you can publish your package with Poetry. You could build the package (as we did above) and then publish later, or you could tell poetry to build it before publishing in one go: $ poetry publish --build # There are 2 files ready for publishing. Build anyway? ( yes/no ) [ no ] $ yes ---> 100% Building rick-portal-gun (0.1.0) - Building sdist - Built rick-portal-gun-0.1.0.tar.gz - Building wheel - Built rick_portal_gun-0.1.0-py3-none-any.whl Publishing rick-portal-gun (0.1.0) to PyPI - Uploading rick-portal-gun-0.1.0.tar.gz 100% - Uploading rick_portal_gun-0.1.0-py3-none-any.whl 100% Now you can go to PyPI and check your projects at https://pypi.org/manage/projects/ . You should now see your new \"rick-portal-gun\" package. Install from PyPI \u00b6 Now to see that we can install it form PyPI, open another terminal, and uninstall the currently installed package. $ pip uninstall rick-portal-gun Found existing installation: rick-portal-gun 0.1.0 Uninstalling rick-portal-gun-0.1.0: Would remove: /home/user/.local/bin/rick-portal-gun /home/user/.local/lib/python3.6/site-packages/rick_portal_gun-0.1.0.dist-info/* /home/user/.local/lib/python3.6/site-packages/rick_portal_gun/* # Proceed ( y/n ) ? $ y Successfully uninstalled rick-portal-gun-0.1.0 And now install it again, but this time using just the name, so that pip pulls it from PyPI: $ pip install --user rick-portal-gun // Notice that it says \"Downloading\" \ud83d\ude80 Collecting rick-portal-gun Downloading rick_portal_gun-0.1.0-py3-none-any.whl (1.8 kB) Requirement already satisfied: typer[all]<0.0.12,>=0.0.11 in ./.local/lib/python3.6/site-packages (from rick-portal-gun) (0.0.11) Requirement already satisfied: click<7.2.0,>=7.1.1 in ./anaconda3/lib/python3.6/site-packages (from typer[all]<0.0.12,>=0.0.11->rick-portal-gun) (7.1.1) Requirement already satisfied: colorama; extra == \"all\" in ./anaconda3/lib/python3.6/site-packages (from typer[all]<0.0.12,>=0.0.11->rick-portal-gun) (0.4.3) Requirement already satisfied: shellingham; extra == \"all\" in ./anaconda3/lib/python3.6/site-packages (from typer[all]<0.0.12,>=0.0.11->rick-portal-gun) (1.3.1) Installing collected packages: rick-portal-gun Successfully installed rick-portal-gun-0.1.0 And now test the newly installed package from PyPI: $ rick-portal-gun load // It works! \ud83c\udf89 Loading portal gun Generate docs with Typer CLI (optional) \u00b6 You can install and use Typer CLI to generate docs for your package. After installing it, you can use it to generate a new README.md : $ typer rick_portal_gun.main utils docs --output README.md --name rick-portal-gun Docs saved to: README.md You just have to pass it the module to import ( rick_portal_gun.main ) and it will detect the typer.Typer app automatically. By specifying the --name of the program it will be able to use it while generating the docs. Publish a new version with the docs \u00b6 Now you can publish a new version with the updated docs. For that you need to first increase the version in pyproject.toml : [tool.poetry] name = \"rick-portal-gun\" version = \"0.2.0\" description = \"\" authors = [\"Rick Sanchez <rick@example.com>\"] readme = \"README.md\" [tool.poetry.scripts] rick-portal-gun = \"rick_portal_gun.main:app\" [tool.poetry.dependencies] python = \"^3.6\" typer = { extras = [ \"all\" ], version = \"^0.1.0\" } [tool.poetry.dev-dependencies] pytest = \"^5.2\" [build-system] requires = [\"poetry>=0.12\"] build-backend = \"poetry.masonry.api\" And in the file rick_portal_gun/__init__.py : __version__ = '0.2.0' And then build and publish again: $ poetry publish --build ---> 100% Building rick-portal-gun (0.2.0) - Building sdist - Built rick-portal-gun-0.2.0.tar.gz - Building wheel - Built rick_portal_gun-0.2.0-py3-none-any.whl Publishing rick-portal-gun (0.2.0) to PyPI - Uploading rick-portal-gun-0.2.0.tar.gz 100% - Uploading rick_portal_gun-0.2.0-py3-none-any.whl 100% And now you can go to PyPI, to the project page, and reload it, and it will now have your new generated docs. What's next \u00b6 This is a very simple guide. You could add many more steps. For example, you should use Git , the version control system, to save your code. You can add a lot of extra metadata to your pyproject.toml , check the docs for Poetry: Libraries . You could use pipx to manage your installed CLI Python programs in isolated environments. Maybe use automatic formatting with Black . You'll probably want to publish your code as open source to GitHub . And then you could integrate a CI tool to run your tests and deploy your package automatically. And there's a long etc. But now you have the basics and you can continue on your own \ud83d\ude80.","title":"Building a Package"},{"location":"tutorial/package/#prerequisites","text":"For this guide we'll use Poetry . Poetry's docs are great, so go ahead, check them and install it.","title":"Prerequisites"},{"location":"tutorial/package/#create-a-project","text":"Let's say we want to create a CLI application called portal-gun . To make sure your package doesn't collide with the package created by someone else, we'll name it with a prefix of your name. So, if your name is Rick, we'll call it rick-portal-gun . Create a project with Poetry: $ poetry new rick-portal-gun Created package rick_portal_gun in rick-portal-gun // Enter the new project directory cd ./rick-portal-gun","title":"Create a project"},{"location":"tutorial/package/#dependencies-and-environment","text":"Add typer[all] to your dependencies: $ poetry add typer [ all ] // It creates a virtual environment for your project Creating virtualenv rick-portal-gun-w31dJa0b-py3.6 in /home/rick/.cache/pypoetry/virtualenvs Using version ^0.1.0 for typer Updating dependencies Resolving dependencies... (1.2s) Writing lock file ---> 100% Package operations: 15 installs, 0 updates, 0 removals - Installing zipp (3.1.0) - Installing importlib-metadata (1.5.0) - Installing pyparsing (2.4.6) - Installing six (1.14.0) - Installing attrs (19.3.0) - Installing click (7.1.1) - Installing colorama (0.4.3) - Installing more-itertools (8.2.0) - Installing packaging (20.3) - Installing pluggy (0.13.1) - Installing py (1.8.1) - Installing shellingham (1.3.2) - Installing wcwidth (0.1.8) - Installing pytest (5.4.1) - Installing typer (0.0.11) // Activate that new virtual environment $ poetry shell Spawning shell within /home/rick/.cache/pypoetry/virtualenvs/rick-portal-gun-w31dJa0b-py3.6 // Open an editor using this new environment, for example VS Code $ code ./ You can see that you have a generated project structure that looks like: . \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.rst \u251c\u2500\u2500 rick_portal_gun \u2502 \u2514\u2500\u2500 __init__.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_rick_portal_gun.py","title":"Dependencies and environment"},{"location":"tutorial/package/#create-your-app","text":"Now let's create an extremely simple Typer app. Create a file rick_portal_gun/main.py with: import typer app = typer . Typer () @app . callback () def callback (): \"\"\" Awesome Portal Gun \"\"\" @app . command () def shoot (): \"\"\" Shoot the portal gun \"\"\" typer . echo ( \"Shooting portal gun\" ) @app . command () def load (): \"\"\" Load the portal gun \"\"\" typer . echo ( \"Loading portal gun\" ) Tip As we are creating an installable Python package, there's no need to add a section with if __name__ == \"__main__: .","title":"Create your app"},{"location":"tutorial/package/#modify-the-readme","text":"Let's change the README. By default it's a file README.rst . Let's change it to README.md . So, change the extension from .rst to .md . So that we can use Markdown instead of reStructuredText. And change the file to have something like: # Portal Gun The awesome Portal Gun","title":"Modify the README"},{"location":"tutorial/package/#modify-your-project-metadata","text":"Edit your file pyproject.toml . It would look something like: [tool.poetry] name = \"rick-portal-gun\" version = \"0.1.0\" description = \"\" authors = [\"Rick Sanchez <rick@example.com>\"] [tool.poetry.dependencies] python = \"^3.6\" typer = { extras = [ \"all\" ], version = \"^0.1.0\" } [tool.poetry.dev-dependencies] pytest = \"^5.2\" [build-system] requires = [\"poetry>=0.12\"] build-backend = \"poetry.masonry.api\" We changed the default README, so let's make it use the new README.md . Add the line: [tool.poetry] name = \"rick-portal-gun\" version = \"0.1.0\" description = \"\" authors = [\"Rick Sanchez <rick@example.com>\"] readme = \"README.md\" [tool.poetry.dependencies] python = \"^3.6\" typer = { extras = [ \"all\" ], version = \"^0.1.0\" } [tool.poetry.dev-dependencies] pytest = \"^5.2\" [build-system] requires = [\"poetry>=0.12\"] build-backend = \"poetry.masonry.api\"","title":"Modify your project metadata"},{"location":"tutorial/package/#add-a-script","text":"We are creating a Python package that can be installed with pip install . But we want it to provide a CLI program that can be executed in the shell. To do that, we add a configuration to the pyproject.toml in the section [tool.poetry.scripts] : [tool.poetry] name = \"rick-portal-gun\" version = \"0.1.0\" description = \"\" authors = [\"Rick Sanchez <rick@example.com>\"] readme = \"README.md\" [tool.poetry.scripts] rick-portal-gun = \"rick_portal_gun.main:app\" [tool.poetry.dependencies] python = \"^3.6\" typer = { extras = [ \"all\" ], version = \"^0.1.0\" } [tool.poetry.dev-dependencies] pytest = \"^5.2\" [build-system] requires = [\"poetry>=0.12\"] build-backend = \"poetry.masonry.api\" Here's what that line means: rick-portal-gun : will be the name of the CLI program. That's how we will call it in the terminal once it is installed. Like: $ rick-portal-gun // Something happens here \u2728 rick_portal_gun.main , in the part \"rick_portal_gun.main:app\" , with underscores, refers to the Python module to import. That's what someone would use in a section like: from rick_portal_gun.main import # something goes here The app in \"rick_portal_gun.main:app\" is the thing to import from the module, and to call as a function, like: from rick_portal_gun.main import app app () That config section tells Poetry that when this package is installed we want it to create a command line program called rick-portal-gun . And that the object to call (like a function) is the one in the variable app inside of the module rick_portal_gun.main .","title":"Add a \"script\""},{"location":"tutorial/package/#install-your-package","text":"That's what we need to create a package. You can now install it: $ poetry install Installing dependencies from lock file No dependencies to install or update - Installing rick-portal-gun (0.1.0)","title":"Install your package"},{"location":"tutorial/package/#try-your-cli-program","text":"Your package is installed in the environment created by Poetry, but you can already use it. // You can use the which program to check which rick-portal-gun program is available (if any) $ which rick-portal-gun // You get the one from your environment /home/rick/.cache/pypoetry/virtualenvs/rick-portal-gun-w31dJa0b-py3.6/bin/rick-portal-gun // Try it $ rick-portal-gun // You get all the standard help Usage: rick-portal-gun [OPTIONS] COMMAND [ARGS]... Awesome Portal Gun Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: load Load the portal gun shoot Shoot the portal gun","title":"Try your CLI program"},{"location":"tutorial/package/#create-a-wheel-package","text":"Python packages have a standard format called a \"wheel\". It's a file that ends in .whl . You can create a wheel with Poetry: $ poetry build Building rick-portal-gun (0.1.0) - Building sdist - Built rick-portal-gun-0.1.0.tar.gz - Building wheel - Built rick_portal_gun-0.1.0-py3-none-any.whl After that, if you check in your project directory, you should now have a couple of extra files at ./dist/ : . \u251c\u2500\u2500 dist \u2502 \u251c\u2500\u2500 rick_portal_gun-0.1.0-py3-none-any.whl \u2502 \u2514\u2500\u2500 rick-portal-gun-0.1.0.tar.gz \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.md \u251c\u2500\u2500 ... The .whl is the wheel file. You can send that wheel file to anyone and they can use it to install your program (we'll see how to upload it to PyPI in a bit).","title":"Create a wheel package"},{"location":"tutorial/package/#test-your-wheel-package","text":"Now you can open another terminal and install that package from the file for your own user with: $ pip install --user /home/rock/code/rick-portal-gun/dist/rick_portal_gun-0.1.0-py3-none-any.whl ---> 100% Warning The --user is important, that ensures you install it in your user's directory and not in the global system. If you installed it in the global system (e.g. with sudo ) you could install a version of a library (e.g. a sub-dependency) that is incompatible with your system. Tip Bonus points if you use pipx to install it while keeping an isolated environment for your Python CLI programs \ud83d\ude80 Now you have your CLI program installed. And you can use it freely: $ rick-portal-gun shoot // It works \ud83c\udf89 Shooting portal gun Having it installed globally (and not in a single environment), you can now install completion globally for it: $ rick-portal-gun --install-completion zsh completion installed in /home/user/.zshrc. Completion will take effect once you restart the terminal. Tip If you want to remove completion you can just delete the added line in that file. And after you restart the terminal you will get completion for your new CLI program: $ rick-portal-gun [ TAB ][ TAB ] // You get completion for your CLI program \u2728 load -- Load the portal gun shoot -- Shoot the portal gun","title":"Test your wheel package"},{"location":"tutorial/package/#support-python-m-optional","text":"You may have seen that you can call many Python modules as scripts with python -m some-module . For example, one way to call pip is: $ pip install fastapi But you can also call Python with the -m CLI Option and pass a module for it to execute as if it was a script, like: $ python -m pip install fastapi Here we pass pip as the value for -m , so, Python will execute the module pip as if it was a script. And then it will pass the rest of the CLI Parameters ( install fastapi ) to it. These two are more or less equivalent, the install fastapi will be passed to pip . Tip In the case of pip , in many occasions it's actually recommended that you run it with python -m , because if you create a virtual environment with its own python , that will ensure that you use the pip from that environment.","title":"Support python -m (optional)"},{"location":"tutorial/package/#add-a-__main__py","text":"You can support that same style of calling the package/module for your own package, simply by adding a file __main__.py . Python will look for that file and execute it. The file would live right beside __init__.py : . \u251c\u2500\u2500 poetry.lock \u251c\u2500\u2500 pyproject.toml \u251c\u2500\u2500 README.rst \u251c\u2500\u2500 rick_portal_gun \u2502 \u251c\u2500\u2500 __init__.py \u2502 \u2514\u2500\u2500 __main__.py \u2514\u2500\u2500 tests \u251c\u2500\u2500 __init__.py \u2514\u2500\u2500 test_rick_portal_gun.py No other file has to import it, you don't have to reference it in your pyproject.toml or anything else, it just works by default, as it is standard Python behavior. Then in that file you can execute your Typer program: from .main import app app () Now, after installing your package, if you call it with python -m it will work (for the main part): $ python -m rick_portal_gun Usage: __main__.py [OPTIONS] COMMAND [ARGS]... Awesome Portal Gun Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: load Load the portal gun shoot Shoot the portal gun Tip Notice that you have to pass the importable version of the package name, so rick_portal_gun instead of rick-portal-gun . That works! \ud83d\ude80 Sort of... \ud83e\udd14 See the __main__.py in the help instead of rick-portal-gun ? We'll fix that next.","title":"Add a __main__.py"},{"location":"tutorial/package/#set-a-program-name-in-__main__py","text":"We are setting the program name in the file pyproject.toml in the line like: [tool.poetry.scripts] rick-portal-gun = \"rick_portal_gun.main:app\" But when Python runs our package as a script with python -m , it doesn't have the information of the program name. So, to fix the help text to use the correct program name when called with python -m , we can pass it to the app in __main__.py : from .main import app app ( prog_name = \"rick-portal-gun\" ) Tip You can pass all the arguments and keyword arguments you could pass to a Click application, including prog_name . $ python -m rick_portal_gun Usage: rick-portal-gun [OPTIONS] COMMAND [ARGS]... Awesome Portal Gun Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: load Load the portal gun shoot Shoot the portal gun Great! That works correctly! \ud83c\udf89 \u2705 Notice that now it uses rick-portal-gun instead of __main__.py in the help.","title":"Set a program name in __main__.py"},{"location":"tutorial/package/#autocompletion-and-python-m","text":"Have in mind that TAB completion (shell auto-completion) won't work when using python -m . Auto-completion depends on the name of the program called, it's tied to each specific program name. So, to have shell completion for rick-portal-gun you would have to call it directly: $ rick-portal-gun [ TAB ][ TAB ] But you can still support python -m for the cases where it's useful.","title":"Autocompletion and python -m"},{"location":"tutorial/package/#publish-to-pypi-optional","text":"You can publish that new package to PyPI to make it public, so others can install it easily. So, go ahead and create an account there (it's free).","title":"Publish to PyPI (optional)"},{"location":"tutorial/package/#pypi-api-token","text":"To do it, you first need to configure a PyPI auth token. Login to PyPI . And then go to https://pypi.org/manage/account/token/ to create a new token. Let's say your new API token is: pypi-wubalubadubdub-deadbeef1234 Now configure Poetry to use this token with the command poetry config pypi-token.pypi : $ poetry config pypi-token.pypi pypi-wubalubadubdub-deadbeef1234 // It won't show any output, but it's already configured","title":"PyPI API token"},{"location":"tutorial/package/#publish-to-pypi","text":"Now you can publish your package with Poetry. You could build the package (as we did above) and then publish later, or you could tell poetry to build it before publishing in one go: $ poetry publish --build # There are 2 files ready for publishing. Build anyway? ( yes/no ) [ no ] $ yes ---> 100% Building rick-portal-gun (0.1.0) - Building sdist - Built rick-portal-gun-0.1.0.tar.gz - Building wheel - Built rick_portal_gun-0.1.0-py3-none-any.whl Publishing rick-portal-gun (0.1.0) to PyPI - Uploading rick-portal-gun-0.1.0.tar.gz 100% - Uploading rick_portal_gun-0.1.0-py3-none-any.whl 100% Now you can go to PyPI and check your projects at https://pypi.org/manage/projects/ . You should now see your new \"rick-portal-gun\" package.","title":"Publish to PyPI"},{"location":"tutorial/package/#install-from-pypi","text":"Now to see that we can install it form PyPI, open another terminal, and uninstall the currently installed package. $ pip uninstall rick-portal-gun Found existing installation: rick-portal-gun 0.1.0 Uninstalling rick-portal-gun-0.1.0: Would remove: /home/user/.local/bin/rick-portal-gun /home/user/.local/lib/python3.6/site-packages/rick_portal_gun-0.1.0.dist-info/* /home/user/.local/lib/python3.6/site-packages/rick_portal_gun/* # Proceed ( y/n ) ? $ y Successfully uninstalled rick-portal-gun-0.1.0 And now install it again, but this time using just the name, so that pip pulls it from PyPI: $ pip install --user rick-portal-gun // Notice that it says \"Downloading\" \ud83d\ude80 Collecting rick-portal-gun Downloading rick_portal_gun-0.1.0-py3-none-any.whl (1.8 kB) Requirement already satisfied: typer[all]<0.0.12,>=0.0.11 in ./.local/lib/python3.6/site-packages (from rick-portal-gun) (0.0.11) Requirement already satisfied: click<7.2.0,>=7.1.1 in ./anaconda3/lib/python3.6/site-packages (from typer[all]<0.0.12,>=0.0.11->rick-portal-gun) (7.1.1) Requirement already satisfied: colorama; extra == \"all\" in ./anaconda3/lib/python3.6/site-packages (from typer[all]<0.0.12,>=0.0.11->rick-portal-gun) (0.4.3) Requirement already satisfied: shellingham; extra == \"all\" in ./anaconda3/lib/python3.6/site-packages (from typer[all]<0.0.12,>=0.0.11->rick-portal-gun) (1.3.1) Installing collected packages: rick-portal-gun Successfully installed rick-portal-gun-0.1.0 And now test the newly installed package from PyPI: $ rick-portal-gun load // It works! \ud83c\udf89 Loading portal gun","title":"Install from PyPI"},{"location":"tutorial/package/#generate-docs-with-typer-cli-optional","text":"You can install and use Typer CLI to generate docs for your package. After installing it, you can use it to generate a new README.md : $ typer rick_portal_gun.main utils docs --output README.md --name rick-portal-gun Docs saved to: README.md You just have to pass it the module to import ( rick_portal_gun.main ) and it will detect the typer.Typer app automatically. By specifying the --name of the program it will be able to use it while generating the docs.","title":"Generate docs with Typer CLI (optional)"},{"location":"tutorial/package/#publish-a-new-version-with-the-docs","text":"Now you can publish a new version with the updated docs. For that you need to first increase the version in pyproject.toml : [tool.poetry] name = \"rick-portal-gun\" version = \"0.2.0\" description = \"\" authors = [\"Rick Sanchez <rick@example.com>\"] readme = \"README.md\" [tool.poetry.scripts] rick-portal-gun = \"rick_portal_gun.main:app\" [tool.poetry.dependencies] python = \"^3.6\" typer = { extras = [ \"all\" ], version = \"^0.1.0\" } [tool.poetry.dev-dependencies] pytest = \"^5.2\" [build-system] requires = [\"poetry>=0.12\"] build-backend = \"poetry.masonry.api\" And in the file rick_portal_gun/__init__.py : __version__ = '0.2.0' And then build and publish again: $ poetry publish --build ---> 100% Building rick-portal-gun (0.2.0) - Building sdist - Built rick-portal-gun-0.2.0.tar.gz - Building wheel - Built rick_portal_gun-0.2.0-py3-none-any.whl Publishing rick-portal-gun (0.2.0) to PyPI - Uploading rick-portal-gun-0.2.0.tar.gz 100% - Uploading rick_portal_gun-0.2.0-py3-none-any.whl 100% And now you can go to PyPI, to the project page, and reload it, and it will now have your new generated docs.","title":"Publish a new version with the docs"},{"location":"tutorial/package/#whats-next","text":"This is a very simple guide. You could add many more steps. For example, you should use Git , the version control system, to save your code. You can add a lot of extra metadata to your pyproject.toml , check the docs for Poetry: Libraries . You could use pipx to manage your installed CLI Python programs in isolated environments. Maybe use automatic formatting with Black . You'll probably want to publish your code as open source to GitHub . And then you could integrate a CI tool to run your tests and deploy your package automatically. And there's a long etc. But now you have the basics and you can continue on your own \ud83d\ude80.","title":"What's next"},{"location":"tutorial/printing/","text":"You can use typer.echo() to print to the screen: import typer def main (): typer . echo ( \"Hello World\" ) if __name__ == \"__main__\" : typer . run ( main ) The reason to use typer.echo() instead of just print() is that it applies some error corrections in case the terminal is misconfigured, and it will properly output color if it's supported. Info typer.echo() comes directly from Click, you can read more about it in Click's docs . Check it: $ python main.py Hello World Color \u00b6 Info For colors to work correctly on Windows you need to also install colorama . You don't need to call colorama.init() . Typer (actually Click) will handle it underneath. And make sure you use typer.echo() instead of print() . Technical Details The way color works in terminals is by using some codes (ASCII codes) as part of the text. So, a colored text is still just a str . You can create colored strings to output to the terminal with typer.style() , that gives you str s that you can then pass to typer.echo() : import typer def main ( good : bool = True ): message_start = \"everything is \" if good : ending = typer . style ( \"good\" , fg = typer . colors . GREEN , bold = True ) else : ending = typer . style ( \"bad\" , fg = typer . colors . WHITE , bg = typer . colors . RED ) message = message_start + ending typer . echo ( message ) if __name__ == \"__main__\" : typer . run ( main ) Tip The parameters fg and bg receive strings with the color names for the \" f ore g round\" and \" b ack g round\" colors. You could simply pass fg=\"green\" and bg=\"red\" . But Typer provides them all as variables like typer.colors.GREEN just so you can use autocompletion while selecting them. Check it: python main.py everything is good python main.py --no-good everything is bad You can pass these function arguments to typer.style() : fg : the foreground color. bg : the background color. bold : enable or disable bold mode. dim : enable or disable dim mode. This is badly supported. underline : enable or disable underline. blink : enable or disable blinking. reverse : enable or disable inverse rendering (foreground becomes background and the other way round). reset : by default a reset-all code is added at the end of the string which means that styles do not carry over. This can be disabled to compose styles. Info You can read more about it in Click's docs about style() typer.secho() - style and print \u00b6 There's a shorter form to style and print at the same time with typer.secho() it's like typer.echo() but also adds style like typer.style() : import typer def main ( name : str ): typer . secho ( f \"Welcome here { name } \" , fg = typer . colors . MAGENTA ) if __name__ == \"__main__\" : typer . run ( main ) Check it: python main.py Camila Welcome here Camila \"Standard Output\" and \"Standard Error\" \u00b6 The way printing works underneath is that the operating system (Linux, Windows, macOS) treats what we print as if our CLI program was writing text to a \" virtual file \" called \" standard output \". When our code \"prints\" things it is actually \"writing\" to this \"virtual file\" of \"standard output\". This might seem strange, but that's how the CLI program and the operating system interact with each other. And then the operating system shows on the screen whatever our CLI program \" wrote \" to that \" virtual file \" called \" standard output \". Standard Error \u00b6 And there's another \" virtual file \" called \" standard error \" that is normally only used for errors. But we can also \"print\" to \"standard error\". And both are shown on the terminal to the users. Info If you use PowerShell it's quite possible that what you print to \"standard error\" won't be shown in the terminal. In PowerShell, to see \"standard error\" you would have to check the variable $Error . But it will work normally in Bash, Zsh, and Fish. Printing to \"standard error\" \u00b6 You can print to \"standard error\" with typer.echo(\"some text\", err=True) . Using err=True tells Typer (actually Click) that the output should be shown in \"standard error\". import typer def main (): typer . echo ( f \"Here is something written to standard error\" , err = True ) if __name__ == \"__main__\" : typer . run ( main ) When you try it in the terminal, it will probably just look the same: $ python main.py Here is something written to standard error \"Standard Input\" \u00b6 As a final detail, when you type text in your keyboard to your terminal, the operating system also considers it another \" virtual file \" that you are writing text to. This virtual file is called \" standard input \". What is this for \u00b6 Right now this probably seems quite useless \ud83e\udd37\u200d\u2642. But understanding that will come handy in the future, for example for autocompletion and testing.","title":"Printing and Colors"},{"location":"tutorial/printing/#color","text":"Info For colors to work correctly on Windows you need to also install colorama . You don't need to call colorama.init() . Typer (actually Click) will handle it underneath. And make sure you use typer.echo() instead of print() . Technical Details The way color works in terminals is by using some codes (ASCII codes) as part of the text. So, a colored text is still just a str . You can create colored strings to output to the terminal with typer.style() , that gives you str s that you can then pass to typer.echo() : import typer def main ( good : bool = True ): message_start = \"everything is \" if good : ending = typer . style ( \"good\" , fg = typer . colors . GREEN , bold = True ) else : ending = typer . style ( \"bad\" , fg = typer . colors . WHITE , bg = typer . colors . RED ) message = message_start + ending typer . echo ( message ) if __name__ == \"__main__\" : typer . run ( main ) Tip The parameters fg and bg receive strings with the color names for the \" f ore g round\" and \" b ack g round\" colors. You could simply pass fg=\"green\" and bg=\"red\" . But Typer provides them all as variables like typer.colors.GREEN just so you can use autocompletion while selecting them. Check it: python main.py everything is good python main.py --no-good everything is bad You can pass these function arguments to typer.style() : fg : the foreground color. bg : the background color. bold : enable or disable bold mode. dim : enable or disable dim mode. This is badly supported. underline : enable or disable underline. blink : enable or disable blinking. reverse : enable or disable inverse rendering (foreground becomes background and the other way round). reset : by default a reset-all code is added at the end of the string which means that styles do not carry over. This can be disabled to compose styles. Info You can read more about it in Click's docs about style()","title":"Color"},{"location":"tutorial/printing/#typersecho-style-and-print","text":"There's a shorter form to style and print at the same time with typer.secho() it's like typer.echo() but also adds style like typer.style() : import typer def main ( name : str ): typer . secho ( f \"Welcome here { name } \" , fg = typer . colors . MAGENTA ) if __name__ == \"__main__\" : typer . run ( main ) Check it: python main.py Camila Welcome here Camila","title":"typer.secho() - style and print"},{"location":"tutorial/printing/#standard-output-and-standard-error","text":"The way printing works underneath is that the operating system (Linux, Windows, macOS) treats what we print as if our CLI program was writing text to a \" virtual file \" called \" standard output \". When our code \"prints\" things it is actually \"writing\" to this \"virtual file\" of \"standard output\". This might seem strange, but that's how the CLI program and the operating system interact with each other. And then the operating system shows on the screen whatever our CLI program \" wrote \" to that \" virtual file \" called \" standard output \".","title":"\"Standard Output\" and \"Standard Error\""},{"location":"tutorial/printing/#standard-error","text":"And there's another \" virtual file \" called \" standard error \" that is normally only used for errors. But we can also \"print\" to \"standard error\". And both are shown on the terminal to the users. Info If you use PowerShell it's quite possible that what you print to \"standard error\" won't be shown in the terminal. In PowerShell, to see \"standard error\" you would have to check the variable $Error . But it will work normally in Bash, Zsh, and Fish.","title":"Standard Error"},{"location":"tutorial/printing/#printing-to-standard-error","text":"You can print to \"standard error\" with typer.echo(\"some text\", err=True) . Using err=True tells Typer (actually Click) that the output should be shown in \"standard error\". import typer def main (): typer . echo ( f \"Here is something written to standard error\" , err = True ) if __name__ == \"__main__\" : typer . run ( main ) When you try it in the terminal, it will probably just look the same: $ python main.py Here is something written to standard error","title":"Printing to \"standard error\""},{"location":"tutorial/printing/#standard-input","text":"As a final detail, when you type text in your keyboard to your terminal, the operating system also considers it another \" virtual file \" that you are writing text to. This virtual file is called \" standard input \".","title":"\"Standard Input\""},{"location":"tutorial/printing/#what-is-this-for","text":"Right now this probably seems quite useless \ud83e\udd37\u200d\u2642. But understanding that will come handy in the future, for example for autocompletion and testing.","title":"What is this for"},{"location":"tutorial/progressbar/","text":"If you are executing an operation that can take some time, you can inform it to the user with a progress bar. For this, you can use typer.progressbar() : import time import typer def main (): total = 0 with typer . progressbar ( range ( 100 )) as progress : for value in progress : # Fake processing time time . sleep ( 0.01 ) total += 1 typer . echo ( f \"Processed { total } things.\" ) if __name__ == \"__main__\" : typer . run ( main ) You use typer.progressbar() with a with statement, as in: with typer . progressbar ( something ) as progress : pass And you pass as function argument to typer.progressbar() the thing that you would normally iterate over. So, if you have a list of users, this could be: users = [ \"Camila\" , \"Rick\" , \"Morty\" ] with typer . progressbar ( users ) as progress : pass And the with statement using typer.progressbar() gives you an object that you can iterate over, just like if it was the same thing that you would iterate over normally. But by iterating over this object Typer (actually Click) will know to update the progress bar: users = [ \"Camila\" , \"Rick\" , \"Morty\" ] with typer . progressbar ( users ) as progress : for user in progress : typer . echo ( user ) Tip Notice that there are 2 levels of code blocks. One for the with statement and one for the for statement. Info This is mostly useful for operations that take some time. In the example above we are faking it with time.sleep() . Check it: $ python main.py ---> 100% Processed 100 things. Setting a Progress Bar length \u00b6 The progress bar is generated from the length of the iterable (e.g. the list of users). But if the length is not available (for example, with something that fetches a new user from a web API each time) you can pass an explicit length to typer.progressbar() . import time import typer def iterate_user_ids (): # Let's imagine this is a web API, not a range() for i in range ( 100 ): yield i def main (): total = 0 with typer . progressbar ( iterate_user_ids (), length = 100 ) as progress : for value in progress : # Fake processing time time . sleep ( 0.01 ) total += 1 typer . echo ( f \"Processed { total } user IDs.\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py ---> 100% Processed 100 user IDs. About the function with yield \u00b6 If you hadn't seen something like that yield above, that's a \" generator \". You can iterate over that function with a for and at each iteration it will give you the value at yield . yield is like a return that gives values multiple times and let's you use the function in a for loop. For example: def iterate_user_ids (): # Let's imagine this is a web API, not a range() for i in range ( 100 ): yield i for i in iterate_user_ids (): print ( i ) would print each of the \"user IDs\" (here it's just the numbers from 0 to 99 ). Add a label \u00b6 You can also set a label : import time import typer def main (): total = 0 with typer . progressbar ( range ( 100 ), label = \"Processing\" ) as progress : for value in progress : # Fake processing time time . sleep ( 0.01 ) total += 1 typer . echo ( f \"Processed { total } things.\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: python main.py Processed 100 things. Iterate manually \u00b6 If you need to manually iterate over something and update the progress bar irregularly, you can do it by not passing an iterable but just a length to typer.progressbar() . And then calling the .update() method in the object from the with statement: import time import typer def main (): total = 1000 with typer . progressbar ( length = total ) as progress : for batch in range ( 4 ): # Fake processing time time . sleep ( 1 ) progress . update ( 250 ) typer . echo ( f \"Processed { total } things in batches.\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: python main.py Processed 100 things in batches.","title":"Progress Bar"},{"location":"tutorial/progressbar/#setting-a-progress-bar-length","text":"The progress bar is generated from the length of the iterable (e.g. the list of users). But if the length is not available (for example, with something that fetches a new user from a web API each time) you can pass an explicit length to typer.progressbar() . import time import typer def iterate_user_ids (): # Let's imagine this is a web API, not a range() for i in range ( 100 ): yield i def main (): total = 0 with typer . progressbar ( iterate_user_ids (), length = 100 ) as progress : for value in progress : # Fake processing time time . sleep ( 0.01 ) total += 1 typer . echo ( f \"Processed { total } user IDs.\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py ---> 100% Processed 100 user IDs.","title":"Setting a Progress Bar length"},{"location":"tutorial/progressbar/#about-the-function-with-yield","text":"If you hadn't seen something like that yield above, that's a \" generator \". You can iterate over that function with a for and at each iteration it will give you the value at yield . yield is like a return that gives values multiple times and let's you use the function in a for loop. For example: def iterate_user_ids (): # Let's imagine this is a web API, not a range() for i in range ( 100 ): yield i for i in iterate_user_ids (): print ( i ) would print each of the \"user IDs\" (here it's just the numbers from 0 to 99 ).","title":"About the function with yield"},{"location":"tutorial/progressbar/#add-a-label","text":"You can also set a label : import time import typer def main (): total = 0 with typer . progressbar ( range ( 100 ), label = \"Processing\" ) as progress : for value in progress : # Fake processing time time . sleep ( 0.01 ) total += 1 typer . echo ( f \"Processed { total } things.\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: python main.py Processed 100 things.","title":"Add a label"},{"location":"tutorial/progressbar/#iterate-manually","text":"If you need to manually iterate over something and update the progress bar irregularly, you can do it by not passing an iterable but just a length to typer.progressbar() . And then calling the .update() method in the object from the with statement: import time import typer def main (): total = 1000 with typer . progressbar ( length = total ) as progress : for batch in range ( 4 ): # Fake processing time time . sleep ( 1 ) progress . update ( 250 ) typer . echo ( f \"Processed { total } things in batches.\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: python main.py Processed 100 things in batches.","title":"Iterate manually"},{"location":"tutorial/prompt/","text":"When you need to ask the user for info interactively you should normally use CLI Option s with Prompt , because they allow using the CLI program in a non-interactive way (for example, a Bash script could use it). But if you absolutely need to ask for interactive information without using a CLI option , you can use typer.prompt() : import typer def main (): person_name = typer . prompt ( \"What's your name?\" ) typer . echo ( f \"Hello { person_name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py # What ' s your name?:$ Camila Hello Camila Confirm \u00b6 There's also an alternative to ask for confirmation. Again, if possible, you should use a CLI Option with a confirmation prompt : import typer def main (): delete = typer . confirm ( \"Are you sure you want to delete it?\" ) if not delete : typer . echo ( \"Not deleting\" ) raise typer . Abort () typer . echo ( \"Deleting it!\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py # Are you sure you want to delete it? [ y/N ] :$ y Deleting it! // This time cancel it $ python main.py # Are you sure you want to delete it? [ y/N ] :$ n Not deleting Aborted! Confirm or abort \u00b6 As it's very common to abort if the user doesn't confirm, there's an integrated parameter abort that does it automatically: import typer def main (): delete = typer . confirm ( \"Are you sure you want to delete it?\" , abort = True ) typer . echo ( \"Deleting it!\" ) if __name__ == \"__main__\" : typer . run ( main ) $ python main.py # Are you sure you want to delete it? [ y/N ] :$ y Deleting it! // This time cancel it $ python main.py # Are you sure you want to delete it? [ y/N ] :$ n Aborted!","title":"Ask with Prompt"},{"location":"tutorial/prompt/#confirm","text":"There's also an alternative to ask for confirmation. Again, if possible, you should use a CLI Option with a confirmation prompt : import typer def main (): delete = typer . confirm ( \"Are you sure you want to delete it?\" ) if not delete : typer . echo ( \"Not deleting\" ) raise typer . Abort () typer . echo ( \"Deleting it!\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py # Are you sure you want to delete it? [ y/N ] :$ y Deleting it! // This time cancel it $ python main.py # Are you sure you want to delete it? [ y/N ] :$ n Not deleting Aborted!","title":"Confirm"},{"location":"tutorial/prompt/#confirm-or-abort","text":"As it's very common to abort if the user doesn't confirm, there's an integrated parameter abort that does it automatically: import typer def main (): delete = typer . confirm ( \"Are you sure you want to delete it?\" , abort = True ) typer . echo ( \"Deleting it!\" ) if __name__ == \"__main__\" : typer . run ( main ) $ python main.py # Are you sure you want to delete it? [ y/N ] :$ y Deleting it! // This time cancel it $ python main.py # Are you sure you want to delete it? [ y/N ] :$ n Aborted!","title":"Confirm or abort"},{"location":"tutorial/terminating/","text":"There are some cases where you might want to terminate a command at some point, and stop all subsequent execution. It could be that your code determined that the program completed successfully, or it could be an operation aborted. Exit a CLI program \u00b6 You can normally just let the code of your CLI program finish its execution, but in some scenarios, you might want to terminate at some point in the middle of it. And prevent any subsequent code to run. This doesn't have to mean that there's an error, just that nothing else needs to be executed. In that case, you can raise a typer.Exit() exception: import typer existing_usernames = [ \"rick\" , \"morty\" ] def maybe_create_user ( username : str ): if username in existing_usernames : typer . echo ( \"The user already exists\" ) raise typer . Exit () else : typer . echo ( f \"User created: { username } \" ) def send_new_user_notification ( username : str ): # Somehow send a notification here for the new user, maybe an email typer . echo ( f \"Notification sent for new user: { username } \" ) def main ( username : str ): maybe_create_user ( username = username ) send_new_user_notification ( username = username ) if __name__ == \"__main__\" : typer . run ( main ) There are several things to see in this example. The CLI program is the function main() , not the others. This is the one that takes a CLI argument . The function maybe_create_user() can terminate the program by raising typer.Exit() . If the program is terminated by maybe_create_user() then send_new_user_notification() will never execute inside of main() . Check it: $ python main.py Camila User created: Camila Notification sent for new user: Camila // Try with an existing user $ python main.py rick The user already exists // Notice that the notification code was never run, the second message is not printed Tip Even though you are rasing an exception, it doesn't necessarily mean there's an error. This is done with an exception because it works as an \"error\" and stops all execution. But then Typer (actually Click) catches it and just terminates the program normally. Exit with an error \u00b6 typer.Exit() takes an optional code parameter. By default, code is 0 , meaning there was no error. You can pass a code with a number other than 0 to tell the terminal that there was an error in the execution of the program: import typer def main ( username : str ): if username == \"root\" : typer . echo ( \"The root user is reserved\" ) raise typer . Exit ( code = 1 ) typer . echo ( f \"New user created: { username } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py Camila New user created: Camila // Print the result code of the last program executed $ echo $? 0 // Now make it exit with an error $ python main.py root The root user is reserved // Print the result code of the last program executed $ echo $? 1 // 1 means there was an error, 0 means no errors. Tip The error code might be used by other programs (for example a Bash script) that execute your CLI program. Abort \u00b6 There's a special exception that you can use to \"abort\" a program. It works more or less the same as typer.Exit() but will print \"Aborted!\" to the screen and can be useful in certain cases later to make it explicit that the execution was aborted: import typer def main ( username : str ): if username == \"root\" : typer . echo ( \"The root user is reserved\" ) raise typer . Abort () typer . echo ( f \"New user created: { username } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py Camila New user created: Camila // Now make it exit with an error $ python main.py root The root user is reserved Aborted!","title":"Terminating"},{"location":"tutorial/terminating/#exit-a-cli-program","text":"You can normally just let the code of your CLI program finish its execution, but in some scenarios, you might want to terminate at some point in the middle of it. And prevent any subsequent code to run. This doesn't have to mean that there's an error, just that nothing else needs to be executed. In that case, you can raise a typer.Exit() exception: import typer existing_usernames = [ \"rick\" , \"morty\" ] def maybe_create_user ( username : str ): if username in existing_usernames : typer . echo ( \"The user already exists\" ) raise typer . Exit () else : typer . echo ( f \"User created: { username } \" ) def send_new_user_notification ( username : str ): # Somehow send a notification here for the new user, maybe an email typer . echo ( f \"Notification sent for new user: { username } \" ) def main ( username : str ): maybe_create_user ( username = username ) send_new_user_notification ( username = username ) if __name__ == \"__main__\" : typer . run ( main ) There are several things to see in this example. The CLI program is the function main() , not the others. This is the one that takes a CLI argument . The function maybe_create_user() can terminate the program by raising typer.Exit() . If the program is terminated by maybe_create_user() then send_new_user_notification() will never execute inside of main() . Check it: $ python main.py Camila User created: Camila Notification sent for new user: Camila // Try with an existing user $ python main.py rick The user already exists // Notice that the notification code was never run, the second message is not printed Tip Even though you are rasing an exception, it doesn't necessarily mean there's an error. This is done with an exception because it works as an \"error\" and stops all execution. But then Typer (actually Click) catches it and just terminates the program normally.","title":"Exit a CLI program"},{"location":"tutorial/terminating/#exit-with-an-error","text":"typer.Exit() takes an optional code parameter. By default, code is 0 , meaning there was no error. You can pass a code with a number other than 0 to tell the terminal that there was an error in the execution of the program: import typer def main ( username : str ): if username == \"root\" : typer . echo ( \"The root user is reserved\" ) raise typer . Exit ( code = 1 ) typer . echo ( f \"New user created: { username } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py Camila New user created: Camila // Print the result code of the last program executed $ echo $? 0 // Now make it exit with an error $ python main.py root The root user is reserved // Print the result code of the last program executed $ echo $? 1 // 1 means there was an error, 0 means no errors. Tip The error code might be used by other programs (for example a Bash script) that execute your CLI program.","title":"Exit with an error"},{"location":"tutorial/terminating/#abort","text":"There's a special exception that you can use to \"abort\" a program. It works more or less the same as typer.Exit() but will print \"Aborted!\" to the screen and can be useful in certain cases later to make it explicit that the execution was aborted: import typer def main ( username : str ): if username == \"root\" : typer . echo ( \"The root user is reserved\" ) raise typer . Abort () typer . echo ( f \"New user created: { username } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py Camila New user created: Camila // Now make it exit with an error $ python main.py root The root user is reserved Aborted!","title":"Abort"},{"location":"tutorial/testing/","text":"Testing Typer applications is very easy with pytest . Let's say you have an application app/main.py with: from typing import Optional import typer app = typer . Typer () @app . command () def main ( name : str , city : Optional [ str ] = None ): typer . echo ( f \"Hello { name } \" ) if city : typer . echo ( f \"Let's have a coffee in { city } \" ) if __name__ == \"__main__\" : app () So, you would use it like: $ python main.py Camila --city Berlin Hello Camila Let's have a coffee in Berlin And the directory also has an empty app/__init__.py file. So, the app is a \"Python package\". Test the app \u00b6 Import and create a CliRunner \u00b6 Create another file/module app/test_main.py . Import CliRunner and create a runner object. This runner is what will \"invoke\" or \"call\" your command line application. from typer.testing import CliRunner from .main import app runner = CliRunner () def test_app (): result = runner . invoke ( app , [ \"Camila\" , \"--city\" , \"Berlin\" ]) assert result . exit_code == 0 assert \"Hello Camila\" in result . stdout assert \"Let's have a coffee in Berlin\" in result . stdout Tip It's important that the name of the file starts with test_ , that way pytest will be able to detect it and use it automatically. Call the app \u00b6 Then create a function test_app() . And inside of the function, use the runner to invoke the application. The first parameter to runner.invoke() is a Typer app. The second parameter is a list of str , with all the text you would pass in the command line, right as you would pass it: from typer.testing import CliRunner from .main import app runner = CliRunner () def test_app (): result = runner . invoke ( app , [ \"Camila\" , \"--city\" , \"Berlin\" ]) assert result . exit_code == 0 assert \"Hello Camila\" in result . stdout assert \"Let's have a coffee in Berlin\" in result . stdout Tip The name of the function has to start with test_ , that way pytest can detect it and use it automatically. Check the result \u00b6 Then, inside of the test function, add assert statements to ensure that everything in the result of the call is as it should be. from typer.testing import CliRunner from .main import app runner = CliRunner () def test_app (): result = runner . invoke ( app , [ \"Camila\" , \"--city\" , \"Berlin\" ]) assert result . exit_code == 0 assert \"Hello Camila\" in result . stdout assert \"Let's have a coffee in Berlin\" in result . stdout Here we are checking that the exit code is 0, as it is for programs that exit without errors. Then we check that the text printed to \"standard output\" contains the text that our CLI program prints. Tip You could also check result.stderr for \"standard error\". Info If you need a refresher about what is \"standard output\" and \"standard error\" check the section in Printing and Colors: \"Standard Output\" and \"Standard Error\" . Call pytest \u00b6 Then you can call pytest in your directory and it will run your tests: $ pytest ================ test session starts ================ platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1 rootdir: /home/user/code/superawesome-cli/app plugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1 collected 1 item ---> 100% test_main.py <span style=\"color: green; white-space: pre;\">. [100%]</span> <span style=\"color: green;\">================= 1 passed in 0.03s =================</span> Testing input \u00b6 If you have a CLI with prompts, like: import typer app = typer . Typer () @app . command () def main ( name : str , email : str = typer . Option ( ... , prompt = True )): typer . echo ( f \"Hello { name } , your email is: { email } \" ) if __name__ == \"__main__\" : app () That you would use like: $ python main.py Camila # Email: $ camila@example.com Hello Camila, your email is: camila@example.com You can test the input typed in the terminal using input=\"camila@example.com\\n\" . This is because what you type in the terminal goes to \" standard input \" and is handled by the operating system as if it was a \"virtual file\". Info If you need a refresher about what is \"standard output\", \"standard error\", and \"standard input\" check the section in Printing and Colors: \"Standard Output\" and \"Standard Error\" . When you hit the ENTER key after typing the email, that is just a \"new line character\". And in Python that is represented with \"\\n\" . So, if you use input=\"camila@example.com\\n\" it means: \"type camila@example.com in the terminal, then hit the ENTER key\": from typer.testing import CliRunner from .main import app runner = CliRunner () def test_app (): result = runner . invoke ( app , [ \"Camila\" ], input = \"camila@example.com \\n \" ) assert result . exit_code == 0 assert \"Hello Camila, your email is: camila@example.com\" in result . stdout Test a function \u00b6 If you have a script and you never created an explicit typer.Typer app, like: import typer def main ( name : str = \"World\" ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) ...you can still test it, by creating an app during testing: import typer from typer.testing import CliRunner from .main import main app = typer . Typer () app . command ()( main ) runner = CliRunner () def test_app (): result = runner . invoke ( app , [ \"--name\" , \"Camila\" ]) assert result . exit_code == 0 assert \"Hello Camila\" in result . stdout Of course, if you are testing that script, it's probably easier/cleaner to just create the explicit typer.Typer app in main.py instead of creating it just during the test. But if you want to keep it that way, e.g. because it's a simple example in documentation, then you can use that trick. About the app.command decorator \u00b6 Notice the app.command()(main) . If it's not obvious what it's doing, continue reading... You would normally write something like: @app . command () def main ( name : str = \"World\" ): # Some code here But @app.command() is just a decorator. That's equivalent to: def main ( name : str = \"World\" ): # Some code here decorator = app . command () new_main = decorator ( main ) main = new_main app.command() returns a function ( decorator ) that takes another function as it's only parameter ( main ). And by using the @something you normally tell Python to replace the thing below (the function main ) with the return of the decorator function ( new_main ). Now, in the specific case of Typer , the decorator doesn't change the original function. It registers it internally and returns it unmodified. So, new_main is actually the same original main . So, in the case of Typer , as it doesn't really modify the decorated function, that would be equivalent to: def main ( name : str = \"World\" ): # Some code here decorator = app . command () decorator ( main ) But then we don't need to create the variable decorator to use it below, we can just use it directly: def main ( name : str = \"World\" ): # Some code here app . command ()( main ) ...that's it. It's still probably simpler to just create the explicit typer.Typer in the main.py file \ud83d\ude05.","title":"Testing"},{"location":"tutorial/testing/#test-the-app","text":"","title":"Test the app"},{"location":"tutorial/testing/#import-and-create-a-clirunner","text":"Create another file/module app/test_main.py . Import CliRunner and create a runner object. This runner is what will \"invoke\" or \"call\" your command line application. from typer.testing import CliRunner from .main import app runner = CliRunner () def test_app (): result = runner . invoke ( app , [ \"Camila\" , \"--city\" , \"Berlin\" ]) assert result . exit_code == 0 assert \"Hello Camila\" in result . stdout assert \"Let's have a coffee in Berlin\" in result . stdout Tip It's important that the name of the file starts with test_ , that way pytest will be able to detect it and use it automatically.","title":"Import and create a CliRunner"},{"location":"tutorial/testing/#call-the-app","text":"Then create a function test_app() . And inside of the function, use the runner to invoke the application. The first parameter to runner.invoke() is a Typer app. The second parameter is a list of str , with all the text you would pass in the command line, right as you would pass it: from typer.testing import CliRunner from .main import app runner = CliRunner () def test_app (): result = runner . invoke ( app , [ \"Camila\" , \"--city\" , \"Berlin\" ]) assert result . exit_code == 0 assert \"Hello Camila\" in result . stdout assert \"Let's have a coffee in Berlin\" in result . stdout Tip The name of the function has to start with test_ , that way pytest can detect it and use it automatically.","title":"Call the app"},{"location":"tutorial/testing/#check-the-result","text":"Then, inside of the test function, add assert statements to ensure that everything in the result of the call is as it should be. from typer.testing import CliRunner from .main import app runner = CliRunner () def test_app (): result = runner . invoke ( app , [ \"Camila\" , \"--city\" , \"Berlin\" ]) assert result . exit_code == 0 assert \"Hello Camila\" in result . stdout assert \"Let's have a coffee in Berlin\" in result . stdout Here we are checking that the exit code is 0, as it is for programs that exit without errors. Then we check that the text printed to \"standard output\" contains the text that our CLI program prints. Tip You could also check result.stderr for \"standard error\". Info If you need a refresher about what is \"standard output\" and \"standard error\" check the section in Printing and Colors: \"Standard Output\" and \"Standard Error\" .","title":"Check the result"},{"location":"tutorial/testing/#call-pytest","text":"Then you can call pytest in your directory and it will run your tests: $ pytest ================ test session starts ================ platform linux -- Python 3.6.9, pytest-5.3.5, py-1.8.1, pluggy-0.13.1 rootdir: /home/user/code/superawesome-cli/app plugins: forked-1.1.3, xdist-1.31.0, cov-2.8.1 collected 1 item ---> 100% test_main.py <span style=\"color: green; white-space: pre;\">. [100%]</span> <span style=\"color: green;\">================= 1 passed in 0.03s =================</span>","title":"Call pytest"},{"location":"tutorial/testing/#testing-input","text":"If you have a CLI with prompts, like: import typer app = typer . Typer () @app . command () def main ( name : str , email : str = typer . Option ( ... , prompt = True )): typer . echo ( f \"Hello { name } , your email is: { email } \" ) if __name__ == \"__main__\" : app () That you would use like: $ python main.py Camila # Email: $ camila@example.com Hello Camila, your email is: camila@example.com You can test the input typed in the terminal using input=\"camila@example.com\\n\" . This is because what you type in the terminal goes to \" standard input \" and is handled by the operating system as if it was a \"virtual file\". Info If you need a refresher about what is \"standard output\", \"standard error\", and \"standard input\" check the section in Printing and Colors: \"Standard Output\" and \"Standard Error\" . When you hit the ENTER key after typing the email, that is just a \"new line character\". And in Python that is represented with \"\\n\" . So, if you use input=\"camila@example.com\\n\" it means: \"type camila@example.com in the terminal, then hit the ENTER key\": from typer.testing import CliRunner from .main import app runner = CliRunner () def test_app (): result = runner . invoke ( app , [ \"Camila\" ], input = \"camila@example.com \\n \" ) assert result . exit_code == 0 assert \"Hello Camila, your email is: camila@example.com\" in result . stdout","title":"Testing input"},{"location":"tutorial/testing/#test-a-function","text":"If you have a script and you never created an explicit typer.Typer app, like: import typer def main ( name : str = \"World\" ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) ...you can still test it, by creating an app during testing: import typer from typer.testing import CliRunner from .main import main app = typer . Typer () app . command ()( main ) runner = CliRunner () def test_app (): result = runner . invoke ( app , [ \"--name\" , \"Camila\" ]) assert result . exit_code == 0 assert \"Hello Camila\" in result . stdout Of course, if you are testing that script, it's probably easier/cleaner to just create the explicit typer.Typer app in main.py instead of creating it just during the test. But if you want to keep it that way, e.g. because it's a simple example in documentation, then you can use that trick.","title":"Test a function"},{"location":"tutorial/testing/#about-the-appcommand-decorator","text":"Notice the app.command()(main) . If it's not obvious what it's doing, continue reading... You would normally write something like: @app . command () def main ( name : str = \"World\" ): # Some code here But @app.command() is just a decorator. That's equivalent to: def main ( name : str = \"World\" ): # Some code here decorator = app . command () new_main = decorator ( main ) main = new_main app.command() returns a function ( decorator ) that takes another function as it's only parameter ( main ). And by using the @something you normally tell Python to replace the thing below (the function main ) with the return of the decorator function ( new_main ). Now, in the specific case of Typer , the decorator doesn't change the original function. It registers it internally and returns it unmodified. So, new_main is actually the same original main . So, in the case of Typer , as it doesn't really modify the decorated function, that would be equivalent to: def main ( name : str = \"World\" ): # Some code here decorator = app . command () decorator ( main ) But then we don't need to create the variable decorator to use it below, we can just use it directly: def main ( name : str = \"World\" ): # Some code here app . command ()( main ) ...that's it. It's still probably simpler to just create the explicit typer.Typer in the main.py file \ud83d\ude05.","title":"About the app.command decorator"},{"location":"tutorial/using-click/","text":"Warning This is a more advanced topic, if you are starting with Typer , feel free to skip it. It will be mostly useful for people that already work with Click and have questions around it. Typer is powered by Click . It does all the work underneath. Here is some more information related to using both together. A single app with both Click and Typer \u00b6 If you already have a Click application and want to migrate to Typer , or to add some Typer components, you can get a Click Command from your Typer application and then use Click directly. How Click works \u00b6 Before knowing how to combine Click and Typer , let's first check a little about how Click works. Click Command \u00b6 Any Click application has an object of class Command . That's, more or less, the most basic Click object. A Command can have its own CLI arguments and CLI options , and it has a function that it calls. For example, in this Click app: import click @click . command () @click . option ( \"--count\" , default = 1 , help = \"Number of greetings.\" ) @click . option ( \"--name\" , prompt = \"Your name\" , help = \"The person to greet.\" ) def hello ( count , name ): \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\" for x in range ( count ): click . echo ( \"Hello %s !\" % name ) if __name__ == \"__main__\" : hello () The original hello variable is converted by Click from a function to a Command object. And the original hello function is used by that Command internally, but it is no longer named hello (as hello is now a Click Command ). Click Group \u00b6 Then Click also has a Group class, it inherits from Command . So, a Group object is also a Command . A Group can also have its own CLI arguments and CLI options . A Group can have subcommands of class Command or sub groups of class Group as well. And a Group can also have a function that it calls, right before calling the function for any specific subcommand. For example: import click @click . group () def cli (): pass @click . command () def initdb (): click . echo ( \"Initialized the database\" ) @click . command () def dropdb (): click . echo ( \"Dropped the database\" ) cli . add_command ( initdb ) cli . add_command ( dropdb ) if __name__ == \"__main__\" : cli () The cli variable is converted by Click from a function to a Group object. And the original cli function is used by that Group internally. Tip The original cli function would be the equivalent of a Typer Callback . Then the cli variable, that now is a Group object, is used to add sub-commands. How Typer works \u00b6 Typer doesn't modify the functions. You create an explicit variable of class typer.Typer and use it to register those functions. And then, when you call the app, Typer goes and creates a Click Command (or Group ), and then calls it. If your app only has one command, then when you call it, Typer creates a single Click Command object and calls it. But Typer creates a Click Group object if your app has any of: More than one command. A callback. Sub-Typer apps (sub commands). Tip If you want to learn more about this check the section One or Multiple Commands . Combine Click and Typer \u00b6 Typer uses an internal function typer.main.get_command() to generate a Click Command (or Group ) from a typer.Typer object. You can use it directly, and use the Click object with other Click applications. Including a Click app in a Typer app \u00b6 For example, you could have a Typer app, generate a Click Group from it, and then include other Click apps in it: import click import typer app = typer . Typer () @app . command () def top (): \"\"\" Top level command, form Typer \"\"\" typer . echo ( \"The Typer app is at the top level\" ) @app . callback () def callback (): \"\"\" Typer app, including Click subapp \"\"\" @click . command () @click . option ( \"--name\" , prompt = \"Your name\" , help = \"The person to greet.\" ) def hello ( name ): \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\" click . echo ( \"Hello %s !\" % name ) typer_click_object = typer . main . get_command ( app ) typer_click_object . add_command ( hello , \"hello\" ) if __name__ == \"__main__\" : typer_click_object () Notice that we add a callback that does nothing (only document the CLI program), to make sure Typer creates a Click Group . That way we can add sub-commands to that Click Group . Then we generate a Click object from our typer.Typer app ( typer_click_object ), and then we can include another Click object ( hello ) in this Click Group . And that way, our Typer app will have a subcommand top built with Typer, and a subcommand hello built with Click. Check it: $ python main.py // Notice we have both subcommands, top and hello Usage: main.py [OPTIONS] COMMAND [ARGS]... Typer app, including Click subapp Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: hello Simple program that greets NAME for a total of COUNT times. top Top level command, form Typer // Call the Typer part $ python main.py top The Typer app is at the top level // Call the Click part $ python main.py hello --name Camila Hello Camila! Including a Typer app in a Click app \u00b6 The same way, you can do the contrary and include a Typer sub app in a bigger Click app: import click import typer @click . group () def cli (): pass @cli . command () def initdb (): click . echo ( \"Initialized the database\" ) @cli . command () def dropdb (): click . echo ( \"Dropped the database\" ) app = typer . Typer () @app . command () def sub (): \"\"\" A single-command Typer sub app \"\"\" typer . echo ( \"Typer is now below Click, the Click app is the top level\" ) typer_click_object = typer . main . get_command ( app ) cli . add_command ( typer_click_object , \"sub\" ) if __name__ == \"__main__\" : cli () Notice that we don't have to add a callback or more commands, we can just create a Typer app that generates a single Click Command , as we don't need to include anything under the Typer app. Then we generate a Click object from our typer.Typer app ( typer_click_object ), and then we use the Click cli to include our Click object from our Typer app. In this case, the original Click app includes the Typer app. And then we call the original Click app, not the Typer app. Check it: $ python main.py // We get our Typer app down there in the sub command Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: dropdb initdb sub A single-command Typer sub app // Use the Click part $ python main.py initdb Initialized the database // And use the Typer part $ python main.py sub Typer is now below Click, the Click app is the top level About Click decorators \u00b6 Typer apps don't work with Click decorators directly. This is because Typer doesn't modify functions to add metadata or to convert them to another object like Click does. So, things like @click.pass_context won't work. Most of the functionality provided by decorators in Click has an alternative way of doing it in Typer . For example, to access the context, you can just declare a function parameter of type typer.Context . Tip You can read more about using the context in the docs: Commands: Using the Context But if you need to use something based on Click decorators, you can always generate a Click object using the methods described above, and use it as you would normally use Click.","title":"Using Click"},{"location":"tutorial/using-click/#a-single-app-with-both-click-and-typer","text":"If you already have a Click application and want to migrate to Typer , or to add some Typer components, you can get a Click Command from your Typer application and then use Click directly.","title":"A single app with both Click and Typer"},{"location":"tutorial/using-click/#how-click-works","text":"Before knowing how to combine Click and Typer , let's first check a little about how Click works.","title":"How Click works"},{"location":"tutorial/using-click/#click-command","text":"Any Click application has an object of class Command . That's, more or less, the most basic Click object. A Command can have its own CLI arguments and CLI options , and it has a function that it calls. For example, in this Click app: import click @click . command () @click . option ( \"--count\" , default = 1 , help = \"Number of greetings.\" ) @click . option ( \"--name\" , prompt = \"Your name\" , help = \"The person to greet.\" ) def hello ( count , name ): \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\" for x in range ( count ): click . echo ( \"Hello %s !\" % name ) if __name__ == \"__main__\" : hello () The original hello variable is converted by Click from a function to a Command object. And the original hello function is used by that Command internally, but it is no longer named hello (as hello is now a Click Command ).","title":"Click Command"},{"location":"tutorial/using-click/#click-group","text":"Then Click also has a Group class, it inherits from Command . So, a Group object is also a Command . A Group can also have its own CLI arguments and CLI options . A Group can have subcommands of class Command or sub groups of class Group as well. And a Group can also have a function that it calls, right before calling the function for any specific subcommand. For example: import click @click . group () def cli (): pass @click . command () def initdb (): click . echo ( \"Initialized the database\" ) @click . command () def dropdb (): click . echo ( \"Dropped the database\" ) cli . add_command ( initdb ) cli . add_command ( dropdb ) if __name__ == \"__main__\" : cli () The cli variable is converted by Click from a function to a Group object. And the original cli function is used by that Group internally. Tip The original cli function would be the equivalent of a Typer Callback . Then the cli variable, that now is a Group object, is used to add sub-commands.","title":"Click Group"},{"location":"tutorial/using-click/#how-typer-works","text":"Typer doesn't modify the functions. You create an explicit variable of class typer.Typer and use it to register those functions. And then, when you call the app, Typer goes and creates a Click Command (or Group ), and then calls it. If your app only has one command, then when you call it, Typer creates a single Click Command object and calls it. But Typer creates a Click Group object if your app has any of: More than one command. A callback. Sub-Typer apps (sub commands). Tip If you want to learn more about this check the section One or Multiple Commands .","title":"How Typer works"},{"location":"tutorial/using-click/#combine-click-and-typer","text":"Typer uses an internal function typer.main.get_command() to generate a Click Command (or Group ) from a typer.Typer object. You can use it directly, and use the Click object with other Click applications.","title":"Combine Click and Typer"},{"location":"tutorial/using-click/#including-a-click-app-in-a-typer-app","text":"For example, you could have a Typer app, generate a Click Group from it, and then include other Click apps in it: import click import typer app = typer . Typer () @app . command () def top (): \"\"\" Top level command, form Typer \"\"\" typer . echo ( \"The Typer app is at the top level\" ) @app . callback () def callback (): \"\"\" Typer app, including Click subapp \"\"\" @click . command () @click . option ( \"--name\" , prompt = \"Your name\" , help = \"The person to greet.\" ) def hello ( name ): \"\"\"Simple program that greets NAME for a total of COUNT times.\"\"\" click . echo ( \"Hello %s !\" % name ) typer_click_object = typer . main . get_command ( app ) typer_click_object . add_command ( hello , \"hello\" ) if __name__ == \"__main__\" : typer_click_object () Notice that we add a callback that does nothing (only document the CLI program), to make sure Typer creates a Click Group . That way we can add sub-commands to that Click Group . Then we generate a Click object from our typer.Typer app ( typer_click_object ), and then we can include another Click object ( hello ) in this Click Group . And that way, our Typer app will have a subcommand top built with Typer, and a subcommand hello built with Click. Check it: $ python main.py // Notice we have both subcommands, top and hello Usage: main.py [OPTIONS] COMMAND [ARGS]... Typer app, including Click subapp Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: hello Simple program that greets NAME for a total of COUNT times. top Top level command, form Typer // Call the Typer part $ python main.py top The Typer app is at the top level // Call the Click part $ python main.py hello --name Camila Hello Camila!","title":"Including a Click app in a Typer app"},{"location":"tutorial/using-click/#including-a-typer-app-in-a-click-app","text":"The same way, you can do the contrary and include a Typer sub app in a bigger Click app: import click import typer @click . group () def cli (): pass @cli . command () def initdb (): click . echo ( \"Initialized the database\" ) @cli . command () def dropdb (): click . echo ( \"Dropped the database\" ) app = typer . Typer () @app . command () def sub (): \"\"\" A single-command Typer sub app \"\"\" typer . echo ( \"Typer is now below Click, the Click app is the top level\" ) typer_click_object = typer . main . get_command ( app ) cli . add_command ( typer_click_object , \"sub\" ) if __name__ == \"__main__\" : cli () Notice that we don't have to add a callback or more commands, we can just create a Typer app that generates a single Click Command , as we don't need to include anything under the Typer app. Then we generate a Click object from our typer.Typer app ( typer_click_object ), and then we use the Click cli to include our Click object from our Typer app. In this case, the original Click app includes the Typer app. And then we call the original Click app, not the Typer app. Check it: $ python main.py // We get our Typer app down there in the sub command Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: dropdb initdb sub A single-command Typer sub app // Use the Click part $ python main.py initdb Initialized the database // And use the Typer part $ python main.py sub Typer is now below Click, the Click app is the top level","title":"Including a Typer app in a Click app"},{"location":"tutorial/using-click/#about-click-decorators","text":"Typer apps don't work with Click decorators directly. This is because Typer doesn't modify functions to add metadata or to convert them to another object like Click does. So, things like @click.pass_context won't work. Most of the functionality provided by decorators in Click has an alternative way of doing it in Typer . For example, to access the context, you can just declare a function parameter of type typer.Context . Tip You can read more about using the context in the docs: Commands: Using the Context But if you need to use something based on Click decorators, you can always generate a Click object using the methods described above, and use it as you would normally use Click.","title":"About Click decorators"},{"location":"tutorial/arguments/","text":"In the next few sections we'll see some ways to modify how CLI arguments work. We'll create optional CLI arguments , we'll add integrated help for CLI arguments , etc.","title":"CLI Arguments Intro"},{"location":"tutorial/arguments/default/","text":"We can also use the same typer.Argument() to set a default value. That way the CLI argument will be optional and also have a default value. An optional CLI argument with a default \u00b6 We can also use typer.Argument() to make a CLI argument have a default value other than None : import typer def main ( name : str = typer . Argument ( \"Wade Wilson\" )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Because now the value will be a str passed by the user or the default value of \"Wade Wilson\" which is also a str , we know the value will never be None , so we don't have to (and shouldn't) use Optional[str] . Have in mind that the Optional[something] tells Python that a value \"could be None \". But the use of Optional doesn't affect Typer in any way, e.g. it doesn't tell Typer if a value is required or not. Check it: // Check the help $ python main.py --help // Notice the [default: Wade Wilson] \u2728 Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] [default: Wade Wilson] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // With no optional CLI argument $ python main.py Hello Wade Wilson // With one CLI argument $ python main.py Camila Hello Camila Dynamic default value \u00b6 And we can even make the default value be dynamically generated by passing a function as the first function argument: import random import typer def get_name (): return random . choice ([ \"Deadpool\" , \"Rick\" , \"Morty\" , \"Hiro\" ]) def main ( name : str = typer . Argument ( get_name )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) In this case, we created the function get_name that will just return a random str each time. And we pass it as the first function argument to typer.Argument() . Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] [default: (dynamic)] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it several times, it will use a random default each time $ python main.py Hello Deadpool $ python main.py Hello Hiro $ python main.py Hello Rick // Now pass a value for the CLI argument $ python main.py Camila Hello Camila","title":"CLI Arguments with Default"},{"location":"tutorial/arguments/default/#an-optional-cli-argument-with-a-default","text":"We can also use typer.Argument() to make a CLI argument have a default value other than None : import typer def main ( name : str = typer . Argument ( \"Wade Wilson\" )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Because now the value will be a str passed by the user or the default value of \"Wade Wilson\" which is also a str , we know the value will never be None , so we don't have to (and shouldn't) use Optional[str] . Have in mind that the Optional[something] tells Python that a value \"could be None \". But the use of Optional doesn't affect Typer in any way, e.g. it doesn't tell Typer if a value is required or not. Check it: // Check the help $ python main.py --help // Notice the [default: Wade Wilson] \u2728 Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] [default: Wade Wilson] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // With no optional CLI argument $ python main.py Hello Wade Wilson // With one CLI argument $ python main.py Camila Hello Camila","title":"An optional CLI argument with a default"},{"location":"tutorial/arguments/default/#dynamic-default-value","text":"And we can even make the default value be dynamically generated by passing a function as the first function argument: import random import typer def get_name (): return random . choice ([ \"Deadpool\" , \"Rick\" , \"Morty\" , \"Hiro\" ]) def main ( name : str = typer . Argument ( get_name )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) In this case, we created the function get_name that will just return a random str each time. And we pass it as the first function argument to typer.Argument() . Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] [default: (dynamic)] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it several times, it will use a random default each time $ python main.py Hello Deadpool $ python main.py Hello Hiro $ python main.py Hello Rick // Now pass a value for the CLI argument $ python main.py Camila Hello Camila","title":"Dynamic default value"},{"location":"tutorial/arguments/envvar/","text":"You can also configure a CLI argument to read a value from an environment variable if it is not provided in the command line as a CLI argument . To do that, use the envvar parameter for typer.Argument() : import typer def main ( name : str = typer . Argument ( \"World\" , envvar = \"AWESOME_NAME\" )): typer . echo ( f \"Hello Mr. { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) In this case, the CLI argument name will have a default value of \"World\" , but will also read any value passed to the environment variable AWESOME_NAME if no value is provided in the command line: // Check the help $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] [env var: AWESOME_NAME;default: World] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Call it without a CLI argument $ python main.py Hello Mr. World // Now pass a value for the CLI argument $ python main.py Czernobog Hello Mr. Czernobog // And now use the environment variable $ AWESOME_NAME = Wednesday python main.py Hello Mr. Wednesday // CLI arguments take precedence over env vars $ AWESOME_NAME = Wednesday python main.py Czernobog Hello Mr. Czernobog Multiple environment variables \u00b6 You are not restricted to a single environment variable, you can declare a list of environment variables that could be used to get a value if it was not passed in the command line: import typer def main ( name : str = typer . Argument ( \"World\" , envvar = [ \"AWESOME_NAME\" , \"GOD_NAME\" ])): typer . echo ( f \"Hello Mr. { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] [env var: AWESOME_NAME, GOD_NAME;default: World] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try the first env var $ AWESOME_NAME = Wednesday python main.py Hello Mr. Wednesday // Try the second env var $ GOD_NAME = Anubis python main.py Hello Mr. Anubis Hide an env var from the help text \u00b6 By default, environment variables used will be shown in the help text, but you can disable them with show_envvar=False : import typer def main ( name : str = typer . Argument ( \"World\" , envvar = \"AWESOME_NAME\" , show_envvar = False )): typer . echo ( f \"Hello Mr. { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: //Check the help $ python main.py --help // It won't show the env var Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] [default: World] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // But it will still be able to use it $ AWESOME_NAME = Wednesday python main.py Hello Mr. Wednesday Technical Details In Click applications the env vars are hidden by default. \ud83d\ude48 In Typer these env vars are shown by default. \ud83d\udc40","title":"CLI Arguments with Environment Variables"},{"location":"tutorial/arguments/envvar/#multiple-environment-variables","text":"You are not restricted to a single environment variable, you can declare a list of environment variables that could be used to get a value if it was not passed in the command line: import typer def main ( name : str = typer . Argument ( \"World\" , envvar = [ \"AWESOME_NAME\" , \"GOD_NAME\" ])): typer . echo ( f \"Hello Mr. { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] [env var: AWESOME_NAME, GOD_NAME;default: World] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try the first env var $ AWESOME_NAME = Wednesday python main.py Hello Mr. Wednesday // Try the second env var $ GOD_NAME = Anubis python main.py Hello Mr. Anubis","title":"Multiple environment variables"},{"location":"tutorial/arguments/envvar/#hide-an-env-var-from-the-help-text","text":"By default, environment variables used will be shown in the help text, but you can disable them with show_envvar=False : import typer def main ( name : str = typer . Argument ( \"World\" , envvar = \"AWESOME_NAME\" , show_envvar = False )): typer . echo ( f \"Hello Mr. { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: //Check the help $ python main.py --help // It won't show the env var Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] [default: World] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // But it will still be able to use it $ AWESOME_NAME = Wednesday python main.py Hello Mr. Wednesday Technical Details In Click applications the env vars are hidden by default. \ud83d\ude48 In Typer these env vars are shown by default. \ud83d\udc40","title":"Hide an env var from the help text"},{"location":"tutorial/arguments/help/","text":"In the First Steps section you saw how to add help for a CLI app/command by adding it to a function's docstring . Here's how that last example looked like: import typer def main ( name : str , lastname : str = \"\" , formal : bool = False ): \"\"\" Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. \"\"\" if formal : typer . echo ( f \"Good day Ms. { name } { lastname } .\" ) else : typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) Now that you also know how to use typer.Argument() , let's use it to add documentation specific for a CLI argument . Add a help text for a CLI argument \u00b6 You can use the help parameter to add a help text for a CLI argument : import typer def main ( name : str = typer . Argument ( ... , help = \"The name of the user to greet\" )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And it will be used in the automatic --help option: $ python main.py --help // Check the section with Arguments below \ud83d\ude80 Usage: main.py [OPTIONS] NAME Arguments: NAME The name of the user to greet [required] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Combine help text and docstrings \u00b6 And of course, you can also combine that help with the docstring : import typer def main ( name : str = typer . Argument ( ... , help = \"The name of the user to greet\" )): \"\"\" Say hi to NAME very gently, like Dirk. \"\"\" typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And the --help option will combine all the information: $ python main.py --help // Notice that we have the help text from the docstring and also the Arguments \ud83d\udcdd Usage: main.py [OPTIONS] NAME Say hi to NAME very gently, like Dirk. Arguments: NAME The name of the user to greet [required] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Help with defaults \u00b6 If you have a CLI argument with a default value, like \"World\" : import typer def main ( name : str = typer . Argument ( \"World\" , help = \"Who to greet\" )): \"\"\" Say hi to NAME very gently, like Dirk. \"\"\" typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) It will show that default value in the help text: $ python main.py --help // Notice the [default: World] \ud83d\udd0d Usage: main.py [OPTIONS] [NAME] Say hi to NAME very gently, like Dirk. Arguments: [NAME] Who to greet [default: World] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. But you can disable that if you want to, with show_default=False : import typer def main ( name : str = typer . Argument ( \"World\" , help = \"Who to greet\" , show_default = False )): \"\"\" Say hi to NAME very gently, like Dirk. \"\"\" typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And then it won't show the default value: $ python main.py --help // Notice the there's no [default: World] now \ud83d\udd25 Usage: main.py [OPTIONS] [NAME] Say hi to NAME very gently, like Dirk. Arguments: [NAME] Who to greet Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Technical Details In Click applications the default values are hidden by default. \ud83d\ude48 In Typer these default values are shown by default. \ud83d\udc40 Custom default string \u00b6 You can use the same show_default to pass a custom string (instead of a bool ) to customize the default value to be shown in the help text: import typer def main ( name : str = typer . Argument ( \"Wade Wilson\" , help = \"Who to greet\" , show_default = \"Deadpoolio the amazing's name\" ) ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And it will be used in the help text: $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] Who to greet [default: (Deadpoolio the amazing's name)] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // See it shows \"(Deadpoolio the amazing's name)\" instead of the actual default of \"Wade Wilson\" Custom help name ( metavar ) \u00b6 You can also customize the text used in the generated help text to represent a CLI argument . By default, it will be the same name you declared, in uppercase letters. So, if you declare it as: name : str It will be shown as: NAME But you can customize it with the metavar parameter for typer.Argument() . For example, let's say you don't want to have the default of NAME , you want to have username , in lowercase, and you really want \u2728 emojis \u2728 everywhere: import typer def main ( name : str = typer . Argument ( \"World\" , metavar = \"\u2728username\u2728\" )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Now the generated help text will have \u2728username\u2728 instead of NAME : $ python main.py --help Usage: main.py [OPTIONS] \u2728username\u2728 Arguments: \u2728username\u2728 [default: World] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Hide a CLI argument from the help text \u00b6 If you want, you can make a CLI argument not show up in the Arguments section in the help text. You will probably not want to do this normally, but it's possible: import typer def main ( name : str = typer . Argument ( \"World\" , hidden = True )): \"\"\" Say hi to NAME very gently, like Dirk. \"\"\" typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --help // Notice there's no Arguments section at all \ud83d\udd25 Usage: main.py [OPTIONS] [NAME] Say hi to NAME very gently, like Dirk. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Info Have in mind that the CLI argument will still show up in the first line with Usage . But it won't show up in the main help text under the Arguments section. Help text for CLI arguments in Click \u00b6 Click itself doesn't support adding help for CLI arguments , and it doesn't generate help for them as in the \" Arguments: \" sections in the examples above. Not supporting help in CLI arguments is an intentional design decision in Click : This is to follow the general convention of Unix tools of using arguments for only the most necessary things, and to document them in the command help text by referring to them by name. So, in Click applications, you are expected to write all the documentation for CLI arguments by hand in the docstring . Nevertheless, Typer supports help for CLI arguments . \u2728 \ud83e\udd37\u200d\u2642 Typer doesn't follow that convention and instead supports help to make it easier to have consistent help texts with a consistent format for your CLI programs. \ud83c\udfa8 This is also to help you create CLI programs that are \u2728 awesome \u2728 by default . With very little code. If you want to keep Click's convention in a Typer app, you can do it with the hidden parameter as described above. Technical Details To support help in CLI arguments Typer does a lot of internal work in its own sub-classes of Click's internal classes.","title":"CLI Arguments with Help"},{"location":"tutorial/arguments/help/#add-a-help-text-for-a-cli-argument","text":"You can use the help parameter to add a help text for a CLI argument : import typer def main ( name : str = typer . Argument ( ... , help = \"The name of the user to greet\" )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And it will be used in the automatic --help option: $ python main.py --help // Check the section with Arguments below \ud83d\ude80 Usage: main.py [OPTIONS] NAME Arguments: NAME The name of the user to greet [required] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit.","title":"Add a help text for a CLI argument"},{"location":"tutorial/arguments/help/#combine-help-text-and-docstrings","text":"And of course, you can also combine that help with the docstring : import typer def main ( name : str = typer . Argument ( ... , help = \"The name of the user to greet\" )): \"\"\" Say hi to NAME very gently, like Dirk. \"\"\" typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And the --help option will combine all the information: $ python main.py --help // Notice that we have the help text from the docstring and also the Arguments \ud83d\udcdd Usage: main.py [OPTIONS] NAME Say hi to NAME very gently, like Dirk. Arguments: NAME The name of the user to greet [required] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit.","title":"Combine help text and docstrings"},{"location":"tutorial/arguments/help/#help-with-defaults","text":"If you have a CLI argument with a default value, like \"World\" : import typer def main ( name : str = typer . Argument ( \"World\" , help = \"Who to greet\" )): \"\"\" Say hi to NAME very gently, like Dirk. \"\"\" typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) It will show that default value in the help text: $ python main.py --help // Notice the [default: World] \ud83d\udd0d Usage: main.py [OPTIONS] [NAME] Say hi to NAME very gently, like Dirk. Arguments: [NAME] Who to greet [default: World] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. But you can disable that if you want to, with show_default=False : import typer def main ( name : str = typer . Argument ( \"World\" , help = \"Who to greet\" , show_default = False )): \"\"\" Say hi to NAME very gently, like Dirk. \"\"\" typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And then it won't show the default value: $ python main.py --help // Notice the there's no [default: World] now \ud83d\udd25 Usage: main.py [OPTIONS] [NAME] Say hi to NAME very gently, like Dirk. Arguments: [NAME] Who to greet Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Technical Details In Click applications the default values are hidden by default. \ud83d\ude48 In Typer these default values are shown by default. \ud83d\udc40","title":"Help with defaults"},{"location":"tutorial/arguments/help/#custom-default-string","text":"You can use the same show_default to pass a custom string (instead of a bool ) to customize the default value to be shown in the help text: import typer def main ( name : str = typer . Argument ( \"Wade Wilson\" , help = \"Who to greet\" , show_default = \"Deadpoolio the amazing's name\" ) ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And it will be used in the help text: $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] Who to greet [default: (Deadpoolio the amazing's name)] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // See it shows \"(Deadpoolio the amazing's name)\" instead of the actual default of \"Wade Wilson\"","title":"Custom default string"},{"location":"tutorial/arguments/help/#custom-help-name-metavar","text":"You can also customize the text used in the generated help text to represent a CLI argument . By default, it will be the same name you declared, in uppercase letters. So, if you declare it as: name : str It will be shown as: NAME But you can customize it with the metavar parameter for typer.Argument() . For example, let's say you don't want to have the default of NAME , you want to have username , in lowercase, and you really want \u2728 emojis \u2728 everywhere: import typer def main ( name : str = typer . Argument ( \"World\" , metavar = \"\u2728username\u2728\" )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Now the generated help text will have \u2728username\u2728 instead of NAME : $ python main.py --help Usage: main.py [OPTIONS] \u2728username\u2728 Arguments: \u2728username\u2728 [default: World] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit.","title":"Custom help name (metavar)"},{"location":"tutorial/arguments/help/#hide-a-cli-argument-from-the-help-text","text":"If you want, you can make a CLI argument not show up in the Arguments section in the help text. You will probably not want to do this normally, but it's possible: import typer def main ( name : str = typer . Argument ( \"World\" , hidden = True )): \"\"\" Say hi to NAME very gently, like Dirk. \"\"\" typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --help // Notice there's no Arguments section at all \ud83d\udd25 Usage: main.py [OPTIONS] [NAME] Say hi to NAME very gently, like Dirk. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Info Have in mind that the CLI argument will still show up in the first line with Usage . But it won't show up in the main help text under the Arguments section.","title":"Hide a CLI argument from the help text"},{"location":"tutorial/arguments/help/#help-text-for-cli-arguments-in-click","text":"Click itself doesn't support adding help for CLI arguments , and it doesn't generate help for them as in the \" Arguments: \" sections in the examples above. Not supporting help in CLI arguments is an intentional design decision in Click : This is to follow the general convention of Unix tools of using arguments for only the most necessary things, and to document them in the command help text by referring to them by name. So, in Click applications, you are expected to write all the documentation for CLI arguments by hand in the docstring . Nevertheless, Typer supports help for CLI arguments . \u2728 \ud83e\udd37\u200d\u2642 Typer doesn't follow that convention and instead supports help to make it easier to have consistent help texts with a consistent format for your CLI programs. \ud83c\udfa8 This is also to help you create CLI programs that are \u2728 awesome \u2728 by default . With very little code. If you want to keep Click's convention in a Typer app, you can do it with the hidden parameter as described above. Technical Details To support help in CLI arguments Typer does a lot of internal work in its own sub-classes of Click's internal classes.","title":"Help text for CLI arguments in Click"},{"location":"tutorial/arguments/optional/","text":"We said before that by default : CLI options are optional CLI arguments are required Again, that's how they work by default , and that's the convention in many CLI programs and systems. But you can change that. In fact, it's very common to have optional CLI arguments , it's way more common than having required CLI options . As an example of how it could be useful, let's see how the ls CLI program works. // If you just type $ ls // ls will \"list\" the files and directories in the current directory typer tests README.md LICENSE // But it also receives an optional CLI argument $ ls ./tests/ // And then ls will list the files and directories inside of that directory from the CLI argument __init__.py test_tutorial An alternative CLI argument declaration \u00b6 In the First Steps you saw how to add a CLI argument : import typer def main ( name : str ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Now let's see an alternative way to create the same CLI argument : import typer def main ( name : str = typer . Argument ( ... )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Before, you had this function parameter: name : str And because name didn't have any default value it would be a required parameter for the Python function, in Python terms. Typer does the same and makes it a required CLI argument . And then we changed it to: name : str = typer . Argument ( ... ) But now as typer.Argument() is the \"default value\" of the function's parameter, it would mean that \"it is no longer required\" (in Python terms). As we no longer have the Python function default value (or its absence) to tell if something is required or not and what is the default value, the first parameter to typer.Argument() serves the same purpose of defining that default value, or making it required. To make it required , we pass ... as the first function argument passed to typer.Argument(...) . Info If you hadn't seen that ... before: it is a special single value, it is part of Python and is called \"Ellipsis\" . All we did there achieves the same thing as before, a required CLI argument : $ python main.py Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument 'NAME'. It's still not very useful, but it works correctly. And being able to declare a required CLI argument using name: str = typer.Argument(...) that works exactly the same as name: str will come handy later. Make an optional CLI argument \u00b6 Now, finally what we came for, an optional CLI argument . To make a CLI argument optional, use typer.Argument() and pass a different \"default\" as the first parameter to typer.Argument() , for example None : from typing import Optional import typer def main ( name : Optional [ str ] = typer . Argument ( None )): if name is None : typer . echo ( \"Hello World!\" ) else : typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Now we have: name : Optional [ str ] = typer . Argument ( None ) Because we are using typer.Argument() Typer will know that this is a CLI argument (no matter if required or optional ). And because the first parameter passed to typer.Argument(None) (the new \"default\" value) is None , Typer knows that this is an optional CLI argument , if no value is provided when calling it in the command line, it will have that default value of None . Tip By using Optional your editor will be able to know that the value could be None , and will be able to warn you if you do something assuming it is a str that would break if it was None . Check the help: // First check the help $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip Notice that NAME is still a CLI argument , it's shown up there in the \" Usage: main.py ...\". Also notice that now [NAME] has brackets (\" [ \" and \" ] \") around (before it was just NAME ) to denote that it's optional , not required . Now run it and test it: // With no CLI argument $ python main.py Hello World! // With one optional CLI argument $ python main.py Camila Hello Camila Tip Notice that \" Camila \" here is an optional CLI argument , not a CLI option , because we didn't use something like \" --name Camila \", we just passed \" Camila \" directly to the program.","title":"Optional CLI Arguments"},{"location":"tutorial/arguments/optional/#an-alternative-cli-argument-declaration","text":"In the First Steps you saw how to add a CLI argument : import typer def main ( name : str ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Now let's see an alternative way to create the same CLI argument : import typer def main ( name : str = typer . Argument ( ... )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Before, you had this function parameter: name : str And because name didn't have any default value it would be a required parameter for the Python function, in Python terms. Typer does the same and makes it a required CLI argument . And then we changed it to: name : str = typer . Argument ( ... ) But now as typer.Argument() is the \"default value\" of the function's parameter, it would mean that \"it is no longer required\" (in Python terms). As we no longer have the Python function default value (or its absence) to tell if something is required or not and what is the default value, the first parameter to typer.Argument() serves the same purpose of defining that default value, or making it required. To make it required , we pass ... as the first function argument passed to typer.Argument(...) . Info If you hadn't seen that ... before: it is a special single value, it is part of Python and is called \"Ellipsis\" . All we did there achieves the same thing as before, a required CLI argument : $ python main.py Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument 'NAME'. It's still not very useful, but it works correctly. And being able to declare a required CLI argument using name: str = typer.Argument(...) that works exactly the same as name: str will come handy later.","title":"An alternative CLI argument declaration"},{"location":"tutorial/arguments/optional/#make-an-optional-cli-argument","text":"Now, finally what we came for, an optional CLI argument . To make a CLI argument optional, use typer.Argument() and pass a different \"default\" as the first parameter to typer.Argument() , for example None : from typing import Optional import typer def main ( name : Optional [ str ] = typer . Argument ( None )): if name is None : typer . echo ( \"Hello World!\" ) else : typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Now we have: name : Optional [ str ] = typer . Argument ( None ) Because we are using typer.Argument() Typer will know that this is a CLI argument (no matter if required or optional ). And because the first parameter passed to typer.Argument(None) (the new \"default\" value) is None , Typer knows that this is an optional CLI argument , if no value is provided when calling it in the command line, it will have that default value of None . Tip By using Optional your editor will be able to know that the value could be None , and will be able to warn you if you do something assuming it is a str that would break if it was None . Check the help: // First check the help $ python main.py --help Usage: main.py [OPTIONS] [NAME] Arguments: [NAME] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip Notice that NAME is still a CLI argument , it's shown up there in the \" Usage: main.py ...\". Also notice that now [NAME] has brackets (\" [ \" and \" ] \") around (before it was just NAME ) to denote that it's optional , not required . Now run it and test it: // With no CLI argument $ python main.py Hello World! // With one optional CLI argument $ python main.py Camila Hello Camila Tip Notice that \" Camila \" here is an optional CLI argument , not a CLI option , because we didn't use something like \" --name Camila \", we just passed \" Camila \" directly to the program.","title":"Make an optional CLI argument"},{"location":"tutorial/arguments/other-uses/","text":"typer.Argument() has several other use cases. Such as for data validation, to enable other features, etc. You will see about these use cases later in the docs.","title":"Other uses"},{"location":"tutorial/commands/","text":"We have seen how to create a CLI program with possibly several CLI options and CLI arguments . But Typer allows you to create CLI programs with several commands (also known as subcommands). For example, the program git has several commands. One command of git is git push . And git push in turn takes its own CLI arguments and CLI options . For example: // The push command with no parameters $ git push ---> 100% // The push command with one CLI option --set-upstream and 2 CLI arguments $ git push --set-upstream origin master ---> 100% Another command of git is git pull , it also has some CLI parameters . It's like if the same big program git had several small programs inside. Tip A command looks the same as a CLI argument , it's just some name without a preceding -- . But commands have a predefined name, and are used to group different sets of functionalities into the same CLI application. Command or subcommand \u00b6 It's common to call a CLI program a \"command\". But when one of these programs have subcommands, those subcommands are also frequently called just \"commands\". Have that in mind so you don't get confused. Here I'll use CLI application or program to refer to the program you are building in Python with Typer, and command to refer to one of these \"subcommands\" of your program. Explicit application \u00b6 Before creating CLI applications with multiple commands/subcommands we need to understand how to create an explicit typer.Typer() application. In the CLI options and CLI argument tutorials you have seen how to create a single function and then pass that function to typer.run() . For example: import typer def main ( name : str ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) But that is actually a shortcut. Under the hood, Typer converts that to a CLI application with typer.Typer() and executes it. All that inside of typer.run() . There's also a more explicit way to achieve the same: import typer app = typer . Typer () @app . command () def main ( name : str ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : app () When you use typer.run() , Typer is doing more or less the same as above, it will: Create a new typer.Typer() \"application\". Create a new \" command \" with your function. Call the same \"application\" as if it was a function with \" app() \". @decorator Info That @something syntax in Python is called a \"decorator\". You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from). A \"decorator\" takes the function below and does something with it. In our case, this decorator tells Typer that the function below is a \" command \". Both ways, with typer.run() and creating the explicit application, achieve the same. Tip If your use case is solved with just typer.run() , that's fine, you don't have to create the explicit app and use @app.command() , etc. You might want to do that later when your app needs the extra features, but if it doesn't need them yet, that's fine. If you run the second example, with the explicit app , it works exactly the same: // Without a CLI argument $ python main.py Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument 'NAME'. // With the NAME CLI argument $ python main.py Camila Hello Camila // Asking for help $ python main.py --help Usage: main.py [OPTIONS] NAME Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. A CLI application with multiple commands \u00b6 Coming back to the CLI applications with multiple commands/subcommands, Typer allows creating CLI applications with multiple of them. Now that you know how to create an explicit typer.Typer() application and add one command, let's see how to add multiple commands. Let's say that we have a CLI application to manage users. We'll have a command to create users and another command to delete them. To begin, let's say it can only create and delete one single predefined user: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . command () def delete (): typer . echo ( \"Deleting user: Hiro Hamada\" ) if __name__ == \"__main__\" : app () Now we have a CLI application with 2 commands, create and delete : // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Test them $ python main.py create Creating user: Hiro Hamada $ python main.py delete Deleting user: Hiro Hamada // Now we have 2 commands! \ud83c\udf89 Notice that the help text now shows the 2 commands: create and delete . Tip By default, the names of the commands are generated from the function name. Click Group \u00b6 If you come from Click, a typer.Typer app with subcommands is more or less the equivalent of a Click Group . Technical Details A typer.Typer app is not a Click Group, but it provides the equivalent functionality. And it creates a Click Group when calling it. It is not directly a Group because Typer doesn't modify the functions in your code to convert them to another type of object, it only registers them. Decorator Technical Details \u00b6 When you use @app.command() the function under the decorator is registered in the Typer application and is then used later by the application. But Typer doesn't modify that function itself, the function is left as is. That means that if your function is simple enough that you could create it without using typer.Option() or typer.Argument() , you could use the same function for a Typer application and a FastAPI application putting both decorators on top, or similar tricks. Click Technical Details This behavior is a design difference with Click. In Click, when you add a @click.command() decorator it actually modifies the function underneath and replaces it with an object.","title":"Commands Intro"},{"location":"tutorial/commands/#command-or-subcommand","text":"It's common to call a CLI program a \"command\". But when one of these programs have subcommands, those subcommands are also frequently called just \"commands\". Have that in mind so you don't get confused. Here I'll use CLI application or program to refer to the program you are building in Python with Typer, and command to refer to one of these \"subcommands\" of your program.","title":"Command or subcommand"},{"location":"tutorial/commands/#explicit-application","text":"Before creating CLI applications with multiple commands/subcommands we need to understand how to create an explicit typer.Typer() application. In the CLI options and CLI argument tutorials you have seen how to create a single function and then pass that function to typer.run() . For example: import typer def main ( name : str ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) But that is actually a shortcut. Under the hood, Typer converts that to a CLI application with typer.Typer() and executes it. All that inside of typer.run() . There's also a more explicit way to achieve the same: import typer app = typer . Typer () @app . command () def main ( name : str ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : app () When you use typer.run() , Typer is doing more or less the same as above, it will: Create a new typer.Typer() \"application\". Create a new \" command \" with your function. Call the same \"application\" as if it was a function with \" app() \". @decorator Info That @something syntax in Python is called a \"decorator\". You put it on top of a function. Like a pretty decorative hat (I guess that's where the term came from). A \"decorator\" takes the function below and does something with it. In our case, this decorator tells Typer that the function below is a \" command \". Both ways, with typer.run() and creating the explicit application, achieve the same. Tip If your use case is solved with just typer.run() , that's fine, you don't have to create the explicit app and use @app.command() , etc. You might want to do that later when your app needs the extra features, but if it doesn't need them yet, that's fine. If you run the second example, with the explicit app , it works exactly the same: // Without a CLI argument $ python main.py Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument 'NAME'. // With the NAME CLI argument $ python main.py Camila Hello Camila // Asking for help $ python main.py --help Usage: main.py [OPTIONS] NAME Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit.","title":"Explicit application"},{"location":"tutorial/commands/#a-cli-application-with-multiple-commands","text":"Coming back to the CLI applications with multiple commands/subcommands, Typer allows creating CLI applications with multiple of them. Now that you know how to create an explicit typer.Typer() application and add one command, let's see how to add multiple commands. Let's say that we have a CLI application to manage users. We'll have a command to create users and another command to delete them. To begin, let's say it can only create and delete one single predefined user: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . command () def delete (): typer . echo ( \"Deleting user: Hiro Hamada\" ) if __name__ == \"__main__\" : app () Now we have a CLI application with 2 commands, create and delete : // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Test them $ python main.py create Creating user: Hiro Hamada $ python main.py delete Deleting user: Hiro Hamada // Now we have 2 commands! \ud83c\udf89 Notice that the help text now shows the 2 commands: create and delete . Tip By default, the names of the commands are generated from the function name.","title":"A CLI application with multiple commands"},{"location":"tutorial/commands/#click-group","text":"If you come from Click, a typer.Typer app with subcommands is more or less the equivalent of a Click Group . Technical Details A typer.Typer app is not a Click Group, but it provides the equivalent functionality. And it creates a Click Group when calling it. It is not directly a Group because Typer doesn't modify the functions in your code to convert them to another type of object, it only registers them.","title":"Click Group"},{"location":"tutorial/commands/#decorator-technical-details","text":"When you use @app.command() the function under the decorator is registered in the Typer application and is then used later by the application. But Typer doesn't modify that function itself, the function is left as is. That means that if your function is simple enough that you could create it without using typer.Option() or typer.Argument() , you could use the same function for a Typer application and a FastAPI application putting both decorators on top, or similar tricks. Click Technical Details This behavior is a design difference with Click. In Click, when you add a @click.command() decorator it actually modifies the function underneath and replaces it with an object.","title":"Decorator Technical Details"},{"location":"tutorial/commands/arguments/","text":"The same way as with a CLI application with a single command, subcommands (or just \"commands\") can also have their own CLI arguments : import typer app = typer . Typer () @app . command () def create ( username : str ): typer . echo ( f \"Creating user: { username } \" ) @app . command () def delete ( username : str ): typer . echo ( f \"Deleting user: { username } \" ) if __name__ == \"__main__\" : app () // Check the help for create $ python main.py create --help Usage: main.py create [OPTIONS] USERNAME Options: --help Show this message and exit. // Call it with a CLI argument $ python main.py create Camila Creating user: Camila // The same for delete $ python main.py delete Camila Deleting user: Camila Tip Everything to the right of the command are CLI parameters ( CLI arguments and CLI options ) for that command. Technical Details Actually, it's everything to the right of that command, before any subcommand . It's possible to have groups of subcommands , it's like if one command also had subcommands . And then those subcommands could have their own CLI parameters , taking their own CLI parameters . You will see about them later in another section.","title":"Command CLI Arguments"},{"location":"tutorial/commands/callback/","text":"When you create an app = typer.Typer() it works as a group of commands. And you can create multiple commands with it. Each of those commands can have their own CLI parameters . But as those CLI parameters are handled by each of those commands, they don't allow us to create CLI parameters for the main CLI application itself. But we can use @app.callback() for that. It's very similar to @app.command() , but it declares the CLI parameters for the main CLI application (before the commands): import typer app = typer . Typer () state = { \"verbose\" : False } @app . command () def create ( username : str ): if state [ \"verbose\" ]: typer . echo ( \"About to create a user\" ) typer . echo ( f \"Creating user: { username } \" ) if state [ \"verbose\" ]: typer . echo ( \"Just created a user\" ) @app . command () def delete ( username : str ): if state [ \"verbose\" ]: typer . echo ( \"About to delete a user\" ) typer . echo ( f \"Deleting user: { username } \" ) if state [ \"verbose\" ]: typer . echo ( \"Just deleted a user\" ) @app . callback () def main ( verbose : bool = False ): \"\"\" Manage users in the awesome CLI app. \"\"\" if verbose : typer . echo ( \"Will write verbose output\" ) state [ \"verbose\" ] = True if __name__ == \"__main__\" : app () Here we create a callback with a --verbose CLI option . Tip After getting the --verbose flag, we modify a global state , and we use it in the other commands. There are other ways to achieve the same, but this will suffice for this example. And as we added a docstring to the callback function, by default it will be extracted and used as the help text. Check it: // Check the help $ python main.py --help // Notice the main help text, extracted from the callback function: \"Manage users in the awesome CLI app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Manage users in the awesome CLI app. Options: --verbose / --no-verbose [default: False] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Check the new top level CLI option --verbose // Try it normally $ python main.py create Camila Creating user: Camila // And now with --verbose $ python main.py --verbose create Camila Will write verbose output About to create a user Creating user: Camila Just created a user // Notice that --verbose belongs to the callback, it has to go before create or delete \u26d4\ufe0f $ python main.py create --verbose Camila Usage: main.py create [OPTIONS] USERNAME Try \"main.py create --help\" for help. Error: no such option: --verbose Adding a callback on creation \u00b6 It's also possible to add a callback when creating the typer.Typer() app: import typer def callback (): typer . echo ( \"Running a command\" ) app = typer . Typer ( callback = callback ) @app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () That achieves the same as with @app.callback() . Check it: $ python main.py create Camila Running a command Creating user: Camila Overriding a callback \u00b6 If you added a callback when creating the typer.Typer() app, it's possible to override it with @app.callback() : import typer def callback (): typer . echo ( \"Running a command\" ) app = typer . Typer ( callback = callback ) @app . callback () def new_callback (): typer . echo ( \"Override callback, running a command\" ) @app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Now new_callback() will be the one used. Check it: $ python main.py create Camila // Notice that the message is the one from new_callback() Override callback, running a command Creating user: Camila Adding a callback only for documentation \u00b6 You can also add a callback just to add the documentation in the docstring. It can be convenient especially if you have several lines of text, as the indentation will be automatically handled for you: import typer app = typer . Typer () @app . callback () def callback (): \"\"\" Manage users CLI app. Use it with the create command. A new user with the given NAME will be created. \"\"\" @app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Now the callback will be used mainly to extract the docstring for the help text. Check it: $ python main.py --help // Notice all the help text extracted from the callback docstring Usage: main.py [OPTIONS] COMMAND [ARGS]... Manage users CLI app. Use it with the create command. A new user with the given NAME will be created. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // And it just works as normally $ python main.py create Camila Creating user: Camila Click Group \u00b6 If you come from Click, this Typer callback is the equivalent of the function in a Click Group . For example: import click @click . group () def cli (): pass The original function cli would be the equivalent of a Typer callback. Technical Details When using Click, it converts that cli variable to a Click Group object. And then the original function no longer exists in that variable. Typer doesn't do that, the callback function is not modified, only registered in the typer.Typer app. This is intentional, it's part of Typer 's design, to allow having editor auto completion and type checks.","title":"Typer Callback"},{"location":"tutorial/commands/callback/#adding-a-callback-on-creation","text":"It's also possible to add a callback when creating the typer.Typer() app: import typer def callback (): typer . echo ( \"Running a command\" ) app = typer . Typer ( callback = callback ) @app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () That achieves the same as with @app.callback() . Check it: $ python main.py create Camila Running a command Creating user: Camila","title":"Adding a callback on creation"},{"location":"tutorial/commands/callback/#overriding-a-callback","text":"If you added a callback when creating the typer.Typer() app, it's possible to override it with @app.callback() : import typer def callback (): typer . echo ( \"Running a command\" ) app = typer . Typer ( callback = callback ) @app . callback () def new_callback (): typer . echo ( \"Override callback, running a command\" ) @app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Now new_callback() will be the one used. Check it: $ python main.py create Camila // Notice that the message is the one from new_callback() Override callback, running a command Creating user: Camila","title":"Overriding a callback"},{"location":"tutorial/commands/callback/#adding-a-callback-only-for-documentation","text":"You can also add a callback just to add the documentation in the docstring. It can be convenient especially if you have several lines of text, as the indentation will be automatically handled for you: import typer app = typer . Typer () @app . callback () def callback (): \"\"\" Manage users CLI app. Use it with the create command. A new user with the given NAME will be created. \"\"\" @app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Now the callback will be used mainly to extract the docstring for the help text. Check it: $ python main.py --help // Notice all the help text extracted from the callback docstring Usage: main.py [OPTIONS] COMMAND [ARGS]... Manage users CLI app. Use it with the create command. A new user with the given NAME will be created. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // And it just works as normally $ python main.py create Camila Creating user: Camila","title":"Adding a callback only for documentation"},{"location":"tutorial/commands/callback/#click-group","text":"If you come from Click, this Typer callback is the equivalent of the function in a Click Group . For example: import click @click . group () def cli (): pass The original function cli would be the equivalent of a Typer callback. Technical Details When using Click, it converts that cli variable to a Click Group object. And then the original function no longer exists in that variable. Typer doesn't do that, the callback function is not modified, only registered in the typer.Typer app. This is intentional, it's part of Typer 's design, to allow having editor auto completion and type checks.","title":"Click Group"},{"location":"tutorial/commands/context/","text":"When you create a Typer application it uses Click underneath. And every Click application has a special object called a \"Context\" that is normally hidden. But you can access the context by declaring a function parameter of type typer.Context . You might have read it in CLI Option Callback and Context . The same way, in commands or in the main Typer callback you can access the context by declaring a function parameter of type typer.Context . Getting the context \u00b6 For example, let's say that you want to execute some logic in a Typer callback depending on the subcommand that is being called. You can get the name of the subcommand from the context: import typer app = typer . Typer () @app . command () def create ( username : str ): typer . echo ( f \"Creating user: { username } \" ) @app . command () def delete ( username : str ): typer . echo ( f \"Deleting user: { username } \" ) @app . callback () def main ( ctx : typer . Context ): \"\"\" Manage users in the awesome CLI app. \"\"\" typer . echo ( f \"About to execute command: { ctx . invoked_subcommand } \" ) if __name__ == \"__main__\" : app () Check it: $ python main.py create Camila // We get the message from the callback About to execute command: create Creating user: Camila $ python main.py delete Camila // We get the message from the callback, this time with delete About to execute command: delete Deleting user: Camila Executable callback \u00b6 By default, the callback is only executed right before executing a command. And if no command is provided, the help message is shown. But we could make it run even without a subcommand with invoke_without_command=True : import typer app = typer . Typer () @app . command () def create ( username : str ): typer . echo ( f \"Creating user: { username } \" ) @app . command () def delete ( username : str ): typer . echo ( f \"Deleting user: { username } \" ) @app . callback ( invoke_without_command = True ) def main (): \"\"\" Manage users in the awesome CLI app. \"\"\" typer . echo ( \"Initializing database\" ) if __name__ == \"__main__\" : app () Check it: $ python main.py // The callback is executed, we don't get the default help message Initializing database // Try with a command $ python main.py create Camila // The callback is still executed Initializing database Creating user: Camila Exclusive executable callback \u00b6 We might not want the callback to be executed if there's already other command that will be executed. For that, we can get the typer.Context and check if there's an invoked command in ctx.invoked_subcommand . If it's None , it means that we are not calling a subcommand but the main program (the callback) directly: import typer app = typer . Typer () @app . command () def create ( username : str ): typer . echo ( f \"Creating user: { username } \" ) @app . command () def delete ( username : str ): typer . echo ( f \"Deleting user: { username } \" ) @app . callback ( invoke_without_command = True ) def main ( ctx : typer . Context ): \"\"\" Manage users in the awesome CLI app. \"\"\" if ctx . invoked_subcommand is None : typer . echo ( \"Initializing database\" ) if __name__ == \"__main__\" : app () Check it: $ python main.py // The callback is executed Initializing database // Check it with a subcommand $ python main.py create Camila // This time the callback is not executed Creating user: Camila Configuring the context \u00b6 You can pass configurations for the context when creating a command or callback. To read more about the available configurations check the docs for Click's Context . For example, you could keep additional CLI parameters not declared in your CLI program with ignore_unknown_options and allow_extra_args . Then you can access those extra raw CLI parameters as a list of str in ctx.args : import typer app = typer . Typer () @app . command ( context_settings = { \"allow_extra_args\" : True , \"ignore_unknown_options\" : True } ) def main ( ctx : typer . Context ): for extra_arg in ctx . args : typer . echo ( f \"Got extra arg: { extra_arg } \" ) if __name__ == \"__main__\" : app () $ python main.py --name Camila --city Berlin Got extra arg: --name Got extra arg: Camila Got extra arg: --city Got extra arg: Berlin Tip Notice that it saves all the extra CLI parameters as a raw list of str , including the CLI option names and values, everything together.","title":"Using the Context"},{"location":"tutorial/commands/context/#getting-the-context","text":"For example, let's say that you want to execute some logic in a Typer callback depending on the subcommand that is being called. You can get the name of the subcommand from the context: import typer app = typer . Typer () @app . command () def create ( username : str ): typer . echo ( f \"Creating user: { username } \" ) @app . command () def delete ( username : str ): typer . echo ( f \"Deleting user: { username } \" ) @app . callback () def main ( ctx : typer . Context ): \"\"\" Manage users in the awesome CLI app. \"\"\" typer . echo ( f \"About to execute command: { ctx . invoked_subcommand } \" ) if __name__ == \"__main__\" : app () Check it: $ python main.py create Camila // We get the message from the callback About to execute command: create Creating user: Camila $ python main.py delete Camila // We get the message from the callback, this time with delete About to execute command: delete Deleting user: Camila","title":"Getting the context"},{"location":"tutorial/commands/context/#executable-callback","text":"By default, the callback is only executed right before executing a command. And if no command is provided, the help message is shown. But we could make it run even without a subcommand with invoke_without_command=True : import typer app = typer . Typer () @app . command () def create ( username : str ): typer . echo ( f \"Creating user: { username } \" ) @app . command () def delete ( username : str ): typer . echo ( f \"Deleting user: { username } \" ) @app . callback ( invoke_without_command = True ) def main (): \"\"\" Manage users in the awesome CLI app. \"\"\" typer . echo ( \"Initializing database\" ) if __name__ == \"__main__\" : app () Check it: $ python main.py // The callback is executed, we don't get the default help message Initializing database // Try with a command $ python main.py create Camila // The callback is still executed Initializing database Creating user: Camila","title":"Executable callback"},{"location":"tutorial/commands/context/#exclusive-executable-callback","text":"We might not want the callback to be executed if there's already other command that will be executed. For that, we can get the typer.Context and check if there's an invoked command in ctx.invoked_subcommand . If it's None , it means that we are not calling a subcommand but the main program (the callback) directly: import typer app = typer . Typer () @app . command () def create ( username : str ): typer . echo ( f \"Creating user: { username } \" ) @app . command () def delete ( username : str ): typer . echo ( f \"Deleting user: { username } \" ) @app . callback ( invoke_without_command = True ) def main ( ctx : typer . Context ): \"\"\" Manage users in the awesome CLI app. \"\"\" if ctx . invoked_subcommand is None : typer . echo ( \"Initializing database\" ) if __name__ == \"__main__\" : app () Check it: $ python main.py // The callback is executed Initializing database // Check it with a subcommand $ python main.py create Camila // This time the callback is not executed Creating user: Camila","title":"Exclusive executable callback"},{"location":"tutorial/commands/context/#configuring-the-context","text":"You can pass configurations for the context when creating a command or callback. To read more about the available configurations check the docs for Click's Context . For example, you could keep additional CLI parameters not declared in your CLI program with ignore_unknown_options and allow_extra_args . Then you can access those extra raw CLI parameters as a list of str in ctx.args : import typer app = typer . Typer () @app . command ( context_settings = { \"allow_extra_args\" : True , \"ignore_unknown_options\" : True } ) def main ( ctx : typer . Context ): for extra_arg in ctx . args : typer . echo ( f \"Got extra arg: { extra_arg } \" ) if __name__ == \"__main__\" : app () $ python main.py --name Camila --city Berlin Got extra arg: --name Got extra arg: Camila Got extra arg: --city Got extra arg: Berlin Tip Notice that it saves all the extra CLI parameters as a raw list of str , including the CLI option names and values, everything together.","title":"Configuring the context"},{"location":"tutorial/commands/help/","text":"The same as before, you can add help for the commands in the docstrings and the CLI options . And the typer.Typer() application receives a parameter help that you can pass with the main help text for your CLI program: import typer app = typer . Typer ( help = \"Awesome CLI user manager.\" ) @app . command () def create ( username : str ): \"\"\" Create a new user with USERNAME. \"\"\" typer . echo ( f \"Creating user: { username } \" ) @app . command () def delete ( username : str , force : bool = typer . Option ( ... , prompt = \"Are you sure you want to delete the user?\" , help = \"Force deletion without confirmation.\" , ), ): \"\"\" Delete a user with USERNAME. If --force is not used, will ask for confirmation. \"\"\" if force : typer . echo ( f \"Deleting user: { username } \" ) else : typer . echo ( \"Operation cancelled\" ) @app . command () def delete_all ( force : bool = typer . Option ( ... , prompt = \"Are you sure you want to delete ALL users?\" , help = \"Force deletion without confirmation.\" , ) ): \"\"\" Delete ALL users in the database. If --force is not used, will ask for confirmation. \"\"\" if force : typer . echo ( \"Deleting all users\" ) else : typer . echo ( \"Operation cancelled\" ) @app . command () def init (): \"\"\" Initialize the users database. \"\"\" typer . echo ( \"Initializing user database\" ) if __name__ == \"__main__\" : app () Check it: // Check the new help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Awesome CLI user manager. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create Create a new user with USERNAME. delete Delete a user with USERNAME. delete-all Delete ALL users in the database. init Initialize the users database. // Now the commands have inline help \ud83c\udf89 // Check the help for create $ python main.py create --help Usage: main.py create [OPTIONS] USERNAME Create a new user with USERNAME. Options: --help Show this message and exit. // Check the help for delete $ python main.py delete --help Usage: main.py delete [OPTIONS] USERNAME Delete a user with USERNAME. If --force is not used, will ask for confirmation. Options: --force / --no-force Force deletion without confirmation. [required] --help Show this message and exit. // Check the help for delete-all $ python main.py delete-all --help Usage: main.py delete-all [OPTIONS] Delete ALL users in the database. If --force is not used, will ask for confirmation. Options: --force / --no-force Force deletion without confirmation. [required] --help Show this message and exit. // Check the help for init $ python main.py init --help Usage: main.py init [OPTIONS] Initialize the users database. Options: --help Show this message and exit. Tip typer.Typer() receives several other parameters for other things, we'll see that later. You will also see how to use \"Callbacks\" later, and those include a way to add this same help message in a function docstring. Overwrite command help \u00b6 You will probably be better adding the help text as a docstring to your functions, but if for some reason you wanted to overwrite it, you can use the help function argument passed to @app.command() : import typer app = typer . Typer () @app . command ( help = \"Create a new user with USERNAME.\" ) def create ( username : str ): \"\"\" Some internal utility function to create. \"\"\" typer . echo ( f \"Creating user: { username } \" ) @app . command ( help = \"Delete a user with USERNAME.\" ) def delete ( username : str ): \"\"\" Some internal utility function to delete. \"\"\" typer . echo ( f \"Deleting user: { username } \" ) if __name__ == \"__main__\" : app () Check it: // Check the help $ python main.py --help // Notice it uses the help passed to @app.command() Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create Create a new user with USERNAME. delete Delete a user with USERNAME. // It uses \"Create a new user with USERNAME.\" instead of \"Some internal utility function to create.\"","title":"Command Help"},{"location":"tutorial/commands/help/#overwrite-command-help","text":"You will probably be better adding the help text as a docstring to your functions, but if for some reason you wanted to overwrite it, you can use the help function argument passed to @app.command() : import typer app = typer . Typer () @app . command ( help = \"Create a new user with USERNAME.\" ) def create ( username : str ): \"\"\" Some internal utility function to create. \"\"\" typer . echo ( f \"Creating user: { username } \" ) @app . command ( help = \"Delete a user with USERNAME.\" ) def delete ( username : str ): \"\"\" Some internal utility function to delete. \"\"\" typer . echo ( f \"Deleting user: { username } \" ) if __name__ == \"__main__\" : app () Check it: // Check the help $ python main.py --help // Notice it uses the help passed to @app.command() Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create Create a new user with USERNAME. delete Delete a user with USERNAME. // It uses \"Create a new user with USERNAME.\" instead of \"Some internal utility function to create.\"","title":"Overwrite command help"},{"location":"tutorial/commands/name/","text":"By default, the command names are generated from the function name. So, if your function is something like: def create ( username : str ): ... Then the command name will be create . But if you already had a function called create() somewhere in your code, you would have to name your CLI function differently. And what if you wanted the command to still be named create ? For this, you can set the name of the command in the first parameter for the @app.command() decorator: import typer app = typer . Typer () @app . command ( \"create\" ) def cli_create_user ( username : str ): typer . echo ( f \"Creating user: { username } \" ) @app . command ( \"delete\" ) def cli_delete_user ( username : str ): typer . echo ( f \"Deleting user: { username } \" ) if __name__ == \"__main__\" : app () Now, even though the functions are named cli_create_user() and cli_delete_user() , the commands will still be named create and delete : $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Test it $ python main.py create Camila Creating user: Camila","title":"Custom Command Name"},{"location":"tutorial/commands/one-or-multiple/","text":"You might have noticed that if you create a single command, as in the first example: import typer app = typer . Typer () @app . command () def main ( name : str ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : app () Typer is smart enough to create a CLI application with that single function as the main CLI application, not as a command/subcommand: // Without a CLI argument $ python main.py Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing argument 'NAME'. // With the NAME CLI argument $ python main.py Camila Hello Camila // Asking for help $ python main.py Usage: main.py [OPTIONS] NAME Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Tip Notice that it doesn't show a command main , even though the function name is main . But if you add multiple commands, Typer will create one CLI command for each one of them: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . command () def delete (): typer . echo ( \"Deleting user: Hiro Hamada\" ) if __name__ == \"__main__\" : app () Here we have 2 commands create and delete : // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete // Test the commands $ python main.py create Creating user: Hiro Hamada $ python main.py delete Deleting user: Hiro Hamada One command and one callback \u00b6 If you want to create a CLI app with one single command but you still want it to be a command/subcommand you can just add a callback: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . callback () def callback (): pass if __name__ == \"__main__\" : app () And now your CLI program will have a single command. Check it: // Check the help $ python main.py --help // Notice the single command create Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // Try it $ python main.py create Creating user: Hiro Hamada Using the callback to document \u00b6 Now that you are using a callback just to have a single command, you might as well use it to add documentation for your app: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . callback () def callback (): \"\"\" Creates a single user Hiro Hamada. In the next version it will create 5 users more. \"\"\" if __name__ == \"__main__\" : app () And now the docstring from the callback will be used as the help text: $ python main.py --help // Notice the help text from the docstring Usage: main.py [OPTIONS] COMMAND [ARGS]... Creates a single user Hiro Hamada. In the next version it will create 5 users more. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // And it still works the same, the callback does nothing $ python main.py create Creating user: Hiro Hamada","title":"One or Multiple Commands"},{"location":"tutorial/commands/one-or-multiple/#one-command-and-one-callback","text":"If you want to create a CLI app with one single command but you still want it to be a command/subcommand you can just add a callback: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . callback () def callback (): pass if __name__ == \"__main__\" : app () And now your CLI program will have a single command. Check it: // Check the help $ python main.py --help // Notice the single command create Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // Try it $ python main.py create Creating user: Hiro Hamada","title":"One command and one callback"},{"location":"tutorial/commands/one-or-multiple/#using-the-callback-to-document","text":"Now that you are using a callback just to have a single command, you might as well use it to add documentation for your app: import typer app = typer . Typer () @app . command () def create (): typer . echo ( \"Creating user: Hiro Hamada\" ) @app . callback () def callback (): \"\"\" Creates a single user Hiro Hamada. In the next version it will create 5 users more. \"\"\" if __name__ == \"__main__\" : app () And now the docstring from the callback will be used as the help text: $ python main.py --help // Notice the help text from the docstring Usage: main.py [OPTIONS] COMMAND [ARGS]... Creates a single user Hiro Hamada. In the next version it will create 5 users more. Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create // And it still works the same, the callback does nothing $ python main.py create Creating user: Hiro Hamada","title":"Using the callback to document"},{"location":"tutorial/commands/options/","text":"Commands can also have their own CLI options . In fact, each command can have different CLI arguments and CLI options : import typer app = typer . Typer () @app . command () def create ( username : str ): typer . echo ( f \"Creating user: { username } \" ) @app . command () def delete ( username : str , force : bool = typer . Option ( ... , prompt = \"Are you sure you want to delete the user?\" ), ): if force : typer . echo ( f \"Deleting user: { username } \" ) else : typer . echo ( \"Operation cancelled\" ) @app . command () def delete_all ( force : bool = typer . Option ( ... , prompt = \"Are you sure you want to delete ALL users?\" ) ): if force : typer . echo ( \"Deleting all users\" ) else : typer . echo ( \"Operation cancelled\" ) @app . command () def init (): typer . echo ( \"Initializing user database\" ) if __name__ == \"__main__\" : app () Here we have multiple commands, with different CLI parameters : create : username : a CLI argument . delete : username : a CLI argument . --force : a CLI option , if not provided, it's prompted. delete-all : --force : a CLI option , if not provided, it's prompted. init : Doesn't take any CLI parameters . // Check the help python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: create delete delete-all info Tip Check the command delete-all , by default command names are generated from the function name, replacing _ with - . Test it: // Check the command create $ python main.py create Camila Creating user: Camila // Now test the command delete $ python main.py delete Camila # Are you sure you want to delete the user? [ y/N ] : $ y Deleting user: Camila $ python main.py delete Wade # Are you sure you want to delete the user? [ y/N ] : $ n Operation cancelled // And finally, the command delete-all // Notice it doesn't have CLI arguments, only a CLI option $ python main.py delete-all # Are you sure you want to delete ALL users? [ y/N ] : $ y Deleting all users $ python main.py delete-all # Are you sure you want to delete ALL users? [ y/N ] : $ n Operation cancelled // And if you pass the --force CLI option, it doesn't need to confirm $ python main.py delete-all --force Deleting all users // And init that doesn't take any CLI parameter $ python main.py init Initializing user database","title":"Command CLI Options"},{"location":"tutorial/multiple-values/","text":"There are several ways to declare multiple values for CLI options and CLI arguments . We'll see them in the next short sections.","title":"Multiple Values Intro"},{"location":"tutorial/multiple-values/arguments-with-multiple-values/","text":"CLI arguments can also receive multiple values. You can define the type of a CLI argument using typing.List . from pathlib import Path from typing import List import typer def main ( files : List [ Path ], celebration : str ): for path in files : if path . is_file (): typer . echo ( f \"This file exists: { path . name } \" ) typer . echo ( celebration ) if __name__ == \"__main__\" : typer . run ( main ) And then you can pass it as many CLI arguments of that type as you want: $ python main.py ./index.md ./first-steps.md woohoo! This file exists: index.md woohoo! This file exists: first-steps.md woohoo! Tip We also declared a final CLI argument celebration , and it's correctly used even if we pass an arbitrary number of files first. Info A List can only be used in the last command (if there are subcommands), as this will take anything to the right and assume it's part of the expected CLI arguments . CLI arguments with tuples \u00b6 If you want a specific number of values and types, you can use a tuple, and it can even have default values: from typing import Tuple import typer def main ( names : Tuple [ str , str , str ] = typer . Argument ( ( \"Harry\" , \"Hermione\" , \"Ron\" ), help = \"Select 3 characters to play with\" ) ): for name in names : typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] [NAMES]... Arguments: [NAMES]... Select 3 characters to play with [default: Harry, Hermione, Ron] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Use it with its defaults $ python main.py Hello Harry Hello Hermione Hello Ron // If you pass an invalid number of arguments you will get an error $ python main.py Draco Hagrid Error: argument names takes 3 values // And if you pass the exact number of values it will work correctly $ python main.py Draco Hagrid Dobby Hello Draco Hello Hagrid Hello Dobby","title":"CLI Arguments with Multiple Values"},{"location":"tutorial/multiple-values/arguments-with-multiple-values/#cli-arguments-with-tuples","text":"If you want a specific number of values and types, you can use a tuple, and it can even have default values: from typing import Tuple import typer def main ( names : Tuple [ str , str , str ] = typer . Argument ( ( \"Harry\" , \"Hermione\" , \"Ron\" ), help = \"Select 3 characters to play with\" ) ): for name in names : typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] [NAMES]... Arguments: [NAMES]... Select 3 characters to play with [default: Harry, Hermione, Ron] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Use it with its defaults $ python main.py Hello Harry Hello Hermione Hello Ron // If you pass an invalid number of arguments you will get an error $ python main.py Draco Hagrid Error: argument names takes 3 values // And if you pass the exact number of values it will work correctly $ python main.py Draco Hagrid Dobby Hello Draco Hello Hagrid Hello Dobby","title":"CLI arguments with tuples"},{"location":"tutorial/multiple-values/multiple-options/","text":"You can declare a CLI option that can be used multiple times, and then get all the values. For example, let's say you want to accept several users in a single execution. For this, use the standard Python typing.List to declare it as a list of str : from typing import List , Optional import typer def main ( user : Optional [ List [ str ]] = typer . Option ( None )): if not user : typer . echo ( \"No provided users\" ) raise typer . Abort () for u in user : typer . echo ( f \"Processing user: { u } \" ) if __name__ == \"__main__\" : typer . run ( main ) You will receive the values as you declared them, as a list of str . Check it: $ python main.py No provided users Aborted! // Now pass a user $ python main.py --user Camila Processing user: Camila // And now try with several users $ python main.py --user Camila --user Rick --user Morty Processing user: Camila Processing user: Rick Processing user: Morty Multiple float \u00b6 The same way, you can use other types and they will be converted by Typer to their declared type: from typing import List import typer def main ( number : List [ float ] = typer . Option ([])): typer . echo ( f \"The sum is { sum ( number ) } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py The sum is 0 // Try with some numbers $ python main.py --number 2 The sum is 2.0 // Try with some numbers $ python main.py --number 2 --number 3 --number 4 .5 The sum is 9.5","title":"Multiple CLI Options"},{"location":"tutorial/multiple-values/multiple-options/#multiple-float","text":"The same way, you can use other types and they will be converted by Typer to their declared type: from typing import List import typer def main ( number : List [ float ] = typer . Option ([])): typer . echo ( f \"The sum is { sum ( number ) } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py The sum is 0 // Try with some numbers $ python main.py --number 2 The sum is 2.0 // Try with some numbers $ python main.py --number 2 --number 3 --number 4 .5 The sum is 9.5","title":"Multiple float"},{"location":"tutorial/multiple-values/options-with-multiple-values/","text":"You can also declare a CLI option that takes several values of different types. You can set the number of values and types to anything you want, but it has to be a fixed number of values. For this, use the standard Python typing.Tuple : from typing import Tuple import typer def main ( user : Tuple [ str , int , bool ] = typer . Option (( None , None , None ))): username , coins , is_wizard = user if not username : typer . echo ( \"No user provided\" ) raise typer . Abort () typer . echo ( f \"The username { username } has { coins } coins\" ) if is_wizard : typer . echo ( \"And this user is a wizard!\" ) if __name__ == \"__main__\" : typer . run ( main ) Each of the internal types defines the type of each value in the tuple. So: user : Tuple [ str , int , bool ] means that the parameter user is a tuple of 3 values. The first value is a str . The second value is an int . The third value is a bool . Later we do: username , coins , is_wizard = user If you hadn't seen that, it means that user is a tuple with 3 values, and we are assigning each of the values to a new variable: The first value in the tuple user (a str ) goes to the variable username . The second value in the tuple user (an int ) goes to the variable coins . The third value in the tuple user (a bool ) goes to the variable is_wizard . So, this: username , coins , is_wizard = user is equivalent to this: username = user [ 0 ] coins = user [ 1 ] is_wizard = user [ 2 ] Tip Notice that the default is a tuple with (None, None, None) . You cannot simply use None here as the default because Click doesn't support it . Check it \u00b6 Now let's see how this works in the terminal: // check the help $ python main.py --help // Notice the &lt;TEXT INTEGER BOOLEAN&gt; Usage: main.py [OPTIONS] Options: --user &lt;TEXT INTEGER BOOLEAN&gt;... --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Now try it $ python main.py --user Camila 50 yes The username Camila has 50 coins And this user is a wizard! // With other values $ python main.py --user Morty 3 no The username Morty has 3 coins // Try with invalid values (not enough) $ python main.py --user Camila 50 Error: --user option requires 3 arguments","title":"CLI Options with Multiple Values"},{"location":"tutorial/multiple-values/options-with-multiple-values/#check-it","text":"Now let's see how this works in the terminal: // check the help $ python main.py --help // Notice the &lt;TEXT INTEGER BOOLEAN&gt; Usage: main.py [OPTIONS] Options: --user &lt;TEXT INTEGER BOOLEAN&gt;... --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Now try it $ python main.py --user Camila 50 yes The username Camila has 50 coins And this user is a wizard! // With other values $ python main.py --user Morty 3 no The username Morty has 3 coins // Try with invalid values (not enough) $ python main.py --user Camila 50 Error: --user option requires 3 arguments","title":"Check it"},{"location":"tutorial/options/","text":"In the next short sections we will see how to modify CLI options using typer.Option() . typer.Option() works very similarly to typer.Argument() , but has some extra features that we'll see next.","title":"CLI Options Intro"},{"location":"tutorial/options/autocompletion/","text":"As you have seen, apps built with Typer have completion in your shell that works when you create a Python package or using Typer CLI . It normally completes CLI options , CLI arguments , and subcommands (that you will learn about later). But you can also provide auto completion for the values of CLI options and CLI arguments . We will learn about that here. Review completion \u00b6 Before checking how to provide custom completions, let's check again how it works. After installing completion (for your own Python package or for Typer CLI ), when you use your CLI program and start adding a CLI option with -- an then hit TAB , your shell will show you the available CLI options (the same for CLI arguments , etc). To check it quickly without creating a new Python package, install Typer CLI . Then let's create small example script: import typer def main ( name : str = typer . Option ( \"World\" , help = \"The name to say hi to.\" )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And let's try it with Typer CLI to get completion: // Hit the TAB key in your keyboard below where you see the: [TAB] $ typer ./main.py [ TAB ][ TAB ] // Depending on your terminal/shell you will get some completion like this \u2728 run -- Run the provided Typer app. utils -- Extra utility commands for Typer apps. // Then try with \"run\" and -- $ typer ./main.py run -- [ TAB ][ TAB ] // You will get completion for --name, depending on your terminal it will look something like this --name -- The name to say hi to. // And you can run it as if it was with Python directly $ typer ./main.py run --name Camila Hello Camila Custom completion for values \u00b6 Right now we get completion for the CLI option names, but not for the values. We can provide completion for the values creating an autocompletion function, similar to the callback functions from CLI Option Callback and Context : import typer def complete_name (): return [ \"Camila\" , \"Carlos\" , \"Sebastian\" ] def main ( name : str = typer . Option ( \"World\" , help = \"The name to say hi to.\" , autocompletion = complete_name ) ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) We return a list of strings from the complete_name() function. And then we get those values when using completion: $ typer ./main.py run --name [ TAB ][ TAB ] // We get the values returned from the function \ud83c\udf89 Camila Carlos Sebastian We got the basics working. Now let's improve it. Check the incomplete value \u00b6 Right now, we always return those values, even if users start typing Sebast and then hit TAB , they will also get the completion for Camila and Carlos (depending on the shell), while we should only get completion for Sebastian . But we can fix that so that it always works correctly. Modify the complete_name() function to receive a parameter of type str , it will contain the incomplete value. Then we can check and return only the values that start with the incomplete value from the command line: import typer valid_names = [ \"Camila\" , \"Carlos\" , \"Sebastian\" ] def complete_name ( incomplete : str ): completion = [] for name in valid_names : if name . startswith ( incomplete ): completion . append ( name ) return completion def main ( name : str = typer . Option ( \"World\" , help = \"The name to say hi to.\" , autocompletion = complete_name ) ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Now let's try it: $ typer ./main.py run --name Ca [ TAB ][ TAB ] // We get the values returned from the function that start with Ca \ud83c\udf89 Camila Carlos Now we are only returning the valid values, that start with Ca , we are no longer returning Sebastian as a completion option. Tip You have to declare the incomplete value of type str and that's what you will receive in the function. No matter if the actual value will be an int , or something else, when doing completion, you will only get a str as the incomplete value. And the same way, you can only return str , not int , etc. Add help to completions \u00b6 Right now we are returning a list of str . But some shells (Zsh, Fish, PowerShell) are capable of showing extra help text for completion. We can provide that extra help text so that those shells can show it. In the complete_name() function, instead of providing one str per completion element, we provide a tuple with 2 items. The first item is the actual completion string, and the second item is the help text. So, in the end, we return a list of tuples of str : import typer valid_completion_items = [ ( \"Camila\" , \"The reader of books.\" ), ( \"Carlos\" , \"The writer of scripts.\" ), ( \"Sebastian\" , \"The type hints guy.\" ), ] def complete_name ( incomplete : str ): completion = [] for name , help_text in valid_completion_items : if name . startswith ( incomplete ): completion_item = ( name , help_text ) completion . append ( completion_item ) return completion def main ( name : str = typer . Option ( \"World\" , help = \"The name to say hi to.\" , autocompletion = complete_name ) ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip If you want to have help text for each item, make sure each item in the list is a tuple . Not a list . Click checks specifically for a tuple when extracting the help text. So in the end, the return will be a list (or other iterable) of tuples of 2 str . Info The help text will be visible in Zsh, Fish, and PowerShell. Bash doesn't support showing the help text, but completion will still work the same. If you have a shell like Zsh, it would look like: $ typer ./main.py run --name [ TAB ][ TAB ] // We get the completion items with their help text \ud83c\udf89 Camila -- The reader of books. Carlos -- The writer of scripts. Sebastian -- The type hints guy. Simplify with yield \u00b6 Instead of creating and returning a list with values ( str or tuple ), we can use yield with each value that we want in the completion. That way our function will be a generator that Typer (actually Click) can iterate: import typer valid_completion_items = [ ( \"Camila\" , \"The reader of books.\" ), ( \"Carlos\" , \"The writer of scripts.\" ), ( \"Sebastian\" , \"The type hints guy.\" ), ] def complete_name ( incomplete : str ): for name , help_text in valid_completion_items : if name . startswith ( incomplete ): yield ( name , help_text ) def main ( name : str = typer . Option ( \"World\" , help = \"The name to say hi to.\" , autocompletion = complete_name ) ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) That simplifies our code a bit and works the same. Tip If all the yield part seems complex for you, don't worry, you can just use the version with the list above. In the end, that's just to save us a couple of lines of code. Info The function can use yield , so it doesn't have to return strictly a list , it just has to be iterable . But each of the elements for completion has to be a str or a tuple (when containing a help text). Access other CLI parameters with the Context \u00b6 Let's say that now we want to modify the program to be able to \"say hi\" to multiple people at the same time. So, we will allow multiple --name CLI options . Tip You will learn more about CLI parameters with multiple values later in the tutorial. So, for now, take this as a sneak peek \ud83d\ude09. For this we use a List of str : from typing import List import typer def main ( name : List [ str ] = typer . Option ([ \"World\" ], help = \"The name to say hi to.\" )): for each_name in name : typer . echo ( f \"Hello { each_name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And then we can use it like: $ typer ./main.py run --name Camila --name Sebastian Hello Camila Hello Sebastian Getting completion for multiple values \u00b6 And the same way as before, we want to provide completion for those names. But we don't want to provide the same names for completion if they were already given in previous parameters. For that, we will access and use the \"Context\". When you create a Typer application it uses Click underneath. And every Click application has a special object called a \"Context\" that is normally hidden. But you can access the context by declaring a function parameter of type typer.Context . And from that context you can get the current values for each parameter. from typing import List import typer valid_completion_items = [ ( \"Camila\" , \"The reader of books.\" ), ( \"Carlos\" , \"The writer of scripts.\" ), ( \"Sebastian\" , \"The type hints guy.\" ), ] def complete_name ( ctx : typer . Context , incomplete : str ): names = ctx . params . get ( \"name\" ) or [] for name , help_text in valid_completion_items : if name . startswith ( incomplete ) and name not in names : yield ( name , help_text ) def main ( name : List [ str ] = typer . Option ( [ \"World\" ], help = \"The name to say hi to.\" , autocompletion = complete_name ) ): for n in name : typer . echo ( f \"Hello { n } \" ) if __name__ == \"__main__\" : typer . run ( main ) We are getting the names already provided with --name in the command line before this completion was triggered. If there's no --name in the command line, it will be None , so we use or [] to make sure we have a list (even if empty) to check its contents later. Then, when we have a completion candidate, we check if each name was already provided with --name by checking if it's in that list of names with name not in names . And then we yield each item that has not being used yet. Check it: $ typer ./main.py run --name [ TAB ][ TAB ] // The first time we trigger completion, we get all the names Camila -- The reader of books. Carlos -- The writer of scripts. Sebastian -- The type hints guy. // Add a name and trigger completion again $ typer ./main.py run --name Sebastian --name Ca [ TAB ][ TAB ] // Now we get completion only for the names we haven't used \ud83c\udf89 Camila -- The reader of books. Carlos -- The writer of scripts. // And if we add another of the available names: $ typer ./main.py run --name Sebastian --name Camila --name [ TAB ][ TAB ] // We get completion for the only available one Carlos -- The writer of scripts. Tip It's quite possible that if there's only one option left, your shell will complete it right away instead of showing the option with the help text, to save you more typing. Getting the raw CLI parameters \u00b6 You can also get the raw CLI parameters , just a list of str with everything passed in the command line before the incomplete value. For example, something like [\"typer\", \"main.py\", \"run\", \"--name\"] . Tip This would be for advanced scenarios, in most use cases you would be better off using the context. But it's still possible if you need it. As a simple example, let's show it on the screen before completion. Because completion is based on the output printed by your program (handled internally by Typer ), during completion we can't just print something else as we normally do. Printing to \"standard error\" \u00b6 Tip If you need a refresher about what is \"standard output\" and \"standard error\" check the section in Printing and Colors: \"Standard Output\" and \"Standard Error\" . The completion system only reads from \"standard output\", so, printing to \"standard error\" won't break completion. \ud83d\ude80 You can print to \"standard error\" with typer.echo(\"some text\", err=True) . Using err=True tells Typer (actually Click) that the output should be shown in \"standard error\". from typing import List import typer valid_completion_items = [ ( \"Camila\" , \"The reader of books.\" ), ( \"Carlos\" , \"The writer of scripts.\" ), ( \"Sebastian\" , \"The type hints guy.\" ), ] def complete_name ( args : List [ str ], incomplete : str ): typer . echo ( f \" { args } \" , err = True ) for name , help_text in valid_completion_items : if name . startswith ( incomplete ): yield ( name , help_text ) def main ( name : List [ str ] = typer . Option ( [ \"World\" ], help = \"The name to say hi to.\" , autocompletion = complete_name ) ): for n in name : typer . echo ( f \"Hello { n } \" ) if __name__ == \"__main__\" : typer . run ( main ) We get all the CLI parameters as a raw list of str by declaring a parameter with type List[str] , here it's named args . Tip Here we name the list of all the raw CLI parameters args because that's the convention with Click. But it doesn't contain only CLI arguments , it has everything, including CLI options and values, as a raw list of str . And then we just print it to \"standard error\". $ typer ./main.py run --name [ TAB ][ TAB ] // First we see the raw CLI parameters ['./main.py', 'run', '--name'] // And then we see the actual completion Camila -- The reader of books. Carlos -- The writer of scripts. Sebastian -- The type hints guy. Tip This is a very simple (and quite useless) example, just so you know how it works and that you can use it. But it's probably useful only in very advanced use cases. Getting the Context and the raw CLI parameters \u00b6 Of course, you can declare everything if you need it, the context, the raw CLI parameters , and the incomplete str : from typing import List import typer valid_completion_items = [ ( \"Camila\" , \"The reader of books.\" ), ( \"Carlos\" , \"The writer of scripts.\" ), ( \"Sebastian\" , \"The type hints guy.\" ), ] def complete_name ( ctx : typer . Context , args : List [ str ], incomplete : str ): typer . echo ( f \" { args } \" , err = True ) names = ctx . params . get ( \"name\" ) or [] for name , help_text in valid_completion_items : if name . startswith ( incomplete ) and name not in names : yield ( name , help_text ) def main ( name : List [ str ] = typer . Option ( [ \"World\" ], help = \"The name to say hi to.\" , autocompletion = complete_name ) ): for n in name : typer . echo ( f \"Hello { n } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ typer ./main.py run --name [ TAB ][ TAB ] // First we see the raw CLI parameters ['./main.py', 'run', '--name'] // And then we see the actual completion Camila -- The reader of books. Carlos -- The writer of scripts. Sebastian -- The type hints guy. $ typer ./main.py run --name Sebastian --name Ca [ TAB ][ TAB ] // Again, we see the raw CLI parameters ['./main.py', 'run', '--name', 'Sebastian', '--name'] // And then we see the rest of the valid completion items Camila -- The reader of books. Carlos -- The writer of scripts. Types, types everywhere \u00b6 Typer uses the type declarations to detect what it has to provide to your autocompletion function. You can declare function parameters of these types: str : for the incomplete value. typer.Context : for the current context. List[str] : for the raw CLI parameters . It doesn't matter how you name them, in which order, or which ones of the 3 options you declare. It will all \" just work \" \u2728","title":"CLI Option autocompletion"},{"location":"tutorial/options/autocompletion/#review-completion","text":"Before checking how to provide custom completions, let's check again how it works. After installing completion (for your own Python package or for Typer CLI ), when you use your CLI program and start adding a CLI option with -- an then hit TAB , your shell will show you the available CLI options (the same for CLI arguments , etc). To check it quickly without creating a new Python package, install Typer CLI . Then let's create small example script: import typer def main ( name : str = typer . Option ( \"World\" , help = \"The name to say hi to.\" )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And let's try it with Typer CLI to get completion: // Hit the TAB key in your keyboard below where you see the: [TAB] $ typer ./main.py [ TAB ][ TAB ] // Depending on your terminal/shell you will get some completion like this \u2728 run -- Run the provided Typer app. utils -- Extra utility commands for Typer apps. // Then try with \"run\" and -- $ typer ./main.py run -- [ TAB ][ TAB ] // You will get completion for --name, depending on your terminal it will look something like this --name -- The name to say hi to. // And you can run it as if it was with Python directly $ typer ./main.py run --name Camila Hello Camila","title":"Review completion"},{"location":"tutorial/options/autocompletion/#custom-completion-for-values","text":"Right now we get completion for the CLI option names, but not for the values. We can provide completion for the values creating an autocompletion function, similar to the callback functions from CLI Option Callback and Context : import typer def complete_name (): return [ \"Camila\" , \"Carlos\" , \"Sebastian\" ] def main ( name : str = typer . Option ( \"World\" , help = \"The name to say hi to.\" , autocompletion = complete_name ) ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) We return a list of strings from the complete_name() function. And then we get those values when using completion: $ typer ./main.py run --name [ TAB ][ TAB ] // We get the values returned from the function \ud83c\udf89 Camila Carlos Sebastian We got the basics working. Now let's improve it.","title":"Custom completion for values"},{"location":"tutorial/options/autocompletion/#check-the-incomplete-value","text":"Right now, we always return those values, even if users start typing Sebast and then hit TAB , they will also get the completion for Camila and Carlos (depending on the shell), while we should only get completion for Sebastian . But we can fix that so that it always works correctly. Modify the complete_name() function to receive a parameter of type str , it will contain the incomplete value. Then we can check and return only the values that start with the incomplete value from the command line: import typer valid_names = [ \"Camila\" , \"Carlos\" , \"Sebastian\" ] def complete_name ( incomplete : str ): completion = [] for name in valid_names : if name . startswith ( incomplete ): completion . append ( name ) return completion def main ( name : str = typer . Option ( \"World\" , help = \"The name to say hi to.\" , autocompletion = complete_name ) ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Now let's try it: $ typer ./main.py run --name Ca [ TAB ][ TAB ] // We get the values returned from the function that start with Ca \ud83c\udf89 Camila Carlos Now we are only returning the valid values, that start with Ca , we are no longer returning Sebastian as a completion option. Tip You have to declare the incomplete value of type str and that's what you will receive in the function. No matter if the actual value will be an int , or something else, when doing completion, you will only get a str as the incomplete value. And the same way, you can only return str , not int , etc.","title":"Check the incomplete value"},{"location":"tutorial/options/autocompletion/#add-help-to-completions","text":"Right now we are returning a list of str . But some shells (Zsh, Fish, PowerShell) are capable of showing extra help text for completion. We can provide that extra help text so that those shells can show it. In the complete_name() function, instead of providing one str per completion element, we provide a tuple with 2 items. The first item is the actual completion string, and the second item is the help text. So, in the end, we return a list of tuples of str : import typer valid_completion_items = [ ( \"Camila\" , \"The reader of books.\" ), ( \"Carlos\" , \"The writer of scripts.\" ), ( \"Sebastian\" , \"The type hints guy.\" ), ] def complete_name ( incomplete : str ): completion = [] for name , help_text in valid_completion_items : if name . startswith ( incomplete ): completion_item = ( name , help_text ) completion . append ( completion_item ) return completion def main ( name : str = typer . Option ( \"World\" , help = \"The name to say hi to.\" , autocompletion = complete_name ) ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip If you want to have help text for each item, make sure each item in the list is a tuple . Not a list . Click checks specifically for a tuple when extracting the help text. So in the end, the return will be a list (or other iterable) of tuples of 2 str . Info The help text will be visible in Zsh, Fish, and PowerShell. Bash doesn't support showing the help text, but completion will still work the same. If you have a shell like Zsh, it would look like: $ typer ./main.py run --name [ TAB ][ TAB ] // We get the completion items with their help text \ud83c\udf89 Camila -- The reader of books. Carlos -- The writer of scripts. Sebastian -- The type hints guy.","title":"Add help to completions"},{"location":"tutorial/options/autocompletion/#simplify-with-yield","text":"Instead of creating and returning a list with values ( str or tuple ), we can use yield with each value that we want in the completion. That way our function will be a generator that Typer (actually Click) can iterate: import typer valid_completion_items = [ ( \"Camila\" , \"The reader of books.\" ), ( \"Carlos\" , \"The writer of scripts.\" ), ( \"Sebastian\" , \"The type hints guy.\" ), ] def complete_name ( incomplete : str ): for name , help_text in valid_completion_items : if name . startswith ( incomplete ): yield ( name , help_text ) def main ( name : str = typer . Option ( \"World\" , help = \"The name to say hi to.\" , autocompletion = complete_name ) ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) That simplifies our code a bit and works the same. Tip If all the yield part seems complex for you, don't worry, you can just use the version with the list above. In the end, that's just to save us a couple of lines of code. Info The function can use yield , so it doesn't have to return strictly a list , it just has to be iterable . But each of the elements for completion has to be a str or a tuple (when containing a help text).","title":"Simplify with yield"},{"location":"tutorial/options/autocompletion/#access-other-cli-parameters-with-the-context","text":"Let's say that now we want to modify the program to be able to \"say hi\" to multiple people at the same time. So, we will allow multiple --name CLI options . Tip You will learn more about CLI parameters with multiple values later in the tutorial. So, for now, take this as a sneak peek \ud83d\ude09. For this we use a List of str : from typing import List import typer def main ( name : List [ str ] = typer . Option ([ \"World\" ], help = \"The name to say hi to.\" )): for each_name in name : typer . echo ( f \"Hello { each_name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And then we can use it like: $ typer ./main.py run --name Camila --name Sebastian Hello Camila Hello Sebastian","title":"Access other CLI parameters with the Context"},{"location":"tutorial/options/autocompletion/#getting-completion-for-multiple-values","text":"And the same way as before, we want to provide completion for those names. But we don't want to provide the same names for completion if they were already given in previous parameters. For that, we will access and use the \"Context\". When you create a Typer application it uses Click underneath. And every Click application has a special object called a \"Context\" that is normally hidden. But you can access the context by declaring a function parameter of type typer.Context . And from that context you can get the current values for each parameter. from typing import List import typer valid_completion_items = [ ( \"Camila\" , \"The reader of books.\" ), ( \"Carlos\" , \"The writer of scripts.\" ), ( \"Sebastian\" , \"The type hints guy.\" ), ] def complete_name ( ctx : typer . Context , incomplete : str ): names = ctx . params . get ( \"name\" ) or [] for name , help_text in valid_completion_items : if name . startswith ( incomplete ) and name not in names : yield ( name , help_text ) def main ( name : List [ str ] = typer . Option ( [ \"World\" ], help = \"The name to say hi to.\" , autocompletion = complete_name ) ): for n in name : typer . echo ( f \"Hello { n } \" ) if __name__ == \"__main__\" : typer . run ( main ) We are getting the names already provided with --name in the command line before this completion was triggered. If there's no --name in the command line, it will be None , so we use or [] to make sure we have a list (even if empty) to check its contents later. Then, when we have a completion candidate, we check if each name was already provided with --name by checking if it's in that list of names with name not in names . And then we yield each item that has not being used yet. Check it: $ typer ./main.py run --name [ TAB ][ TAB ] // The first time we trigger completion, we get all the names Camila -- The reader of books. Carlos -- The writer of scripts. Sebastian -- The type hints guy. // Add a name and trigger completion again $ typer ./main.py run --name Sebastian --name Ca [ TAB ][ TAB ] // Now we get completion only for the names we haven't used \ud83c\udf89 Camila -- The reader of books. Carlos -- The writer of scripts. // And if we add another of the available names: $ typer ./main.py run --name Sebastian --name Camila --name [ TAB ][ TAB ] // We get completion for the only available one Carlos -- The writer of scripts. Tip It's quite possible that if there's only one option left, your shell will complete it right away instead of showing the option with the help text, to save you more typing.","title":"Getting completion for multiple values"},{"location":"tutorial/options/autocompletion/#getting-the-raw-cli-parameters","text":"You can also get the raw CLI parameters , just a list of str with everything passed in the command line before the incomplete value. For example, something like [\"typer\", \"main.py\", \"run\", \"--name\"] . Tip This would be for advanced scenarios, in most use cases you would be better off using the context. But it's still possible if you need it. As a simple example, let's show it on the screen before completion. Because completion is based on the output printed by your program (handled internally by Typer ), during completion we can't just print something else as we normally do.","title":"Getting the raw CLI parameters"},{"location":"tutorial/options/autocompletion/#printing-to-standard-error","text":"Tip If you need a refresher about what is \"standard output\" and \"standard error\" check the section in Printing and Colors: \"Standard Output\" and \"Standard Error\" . The completion system only reads from \"standard output\", so, printing to \"standard error\" won't break completion. \ud83d\ude80 You can print to \"standard error\" with typer.echo(\"some text\", err=True) . Using err=True tells Typer (actually Click) that the output should be shown in \"standard error\". from typing import List import typer valid_completion_items = [ ( \"Camila\" , \"The reader of books.\" ), ( \"Carlos\" , \"The writer of scripts.\" ), ( \"Sebastian\" , \"The type hints guy.\" ), ] def complete_name ( args : List [ str ], incomplete : str ): typer . echo ( f \" { args } \" , err = True ) for name , help_text in valid_completion_items : if name . startswith ( incomplete ): yield ( name , help_text ) def main ( name : List [ str ] = typer . Option ( [ \"World\" ], help = \"The name to say hi to.\" , autocompletion = complete_name ) ): for n in name : typer . echo ( f \"Hello { n } \" ) if __name__ == \"__main__\" : typer . run ( main ) We get all the CLI parameters as a raw list of str by declaring a parameter with type List[str] , here it's named args . Tip Here we name the list of all the raw CLI parameters args because that's the convention with Click. But it doesn't contain only CLI arguments , it has everything, including CLI options and values, as a raw list of str . And then we just print it to \"standard error\". $ typer ./main.py run --name [ TAB ][ TAB ] // First we see the raw CLI parameters ['./main.py', 'run', '--name'] // And then we see the actual completion Camila -- The reader of books. Carlos -- The writer of scripts. Sebastian -- The type hints guy. Tip This is a very simple (and quite useless) example, just so you know how it works and that you can use it. But it's probably useful only in very advanced use cases.","title":"Printing to \"standard error\""},{"location":"tutorial/options/autocompletion/#getting-the-context-and-the-raw-cli-parameters","text":"Of course, you can declare everything if you need it, the context, the raw CLI parameters , and the incomplete str : from typing import List import typer valid_completion_items = [ ( \"Camila\" , \"The reader of books.\" ), ( \"Carlos\" , \"The writer of scripts.\" ), ( \"Sebastian\" , \"The type hints guy.\" ), ] def complete_name ( ctx : typer . Context , args : List [ str ], incomplete : str ): typer . echo ( f \" { args } \" , err = True ) names = ctx . params . get ( \"name\" ) or [] for name , help_text in valid_completion_items : if name . startswith ( incomplete ) and name not in names : yield ( name , help_text ) def main ( name : List [ str ] = typer . Option ( [ \"World\" ], help = \"The name to say hi to.\" , autocompletion = complete_name ) ): for n in name : typer . echo ( f \"Hello { n } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ typer ./main.py run --name [ TAB ][ TAB ] // First we see the raw CLI parameters ['./main.py', 'run', '--name'] // And then we see the actual completion Camila -- The reader of books. Carlos -- The writer of scripts. Sebastian -- The type hints guy. $ typer ./main.py run --name Sebastian --name Ca [ TAB ][ TAB ] // Again, we see the raw CLI parameters ['./main.py', 'run', '--name', 'Sebastian', '--name'] // And then we see the rest of the valid completion items Camila -- The reader of books. Carlos -- The writer of scripts.","title":"Getting the Context and the raw CLI parameters"},{"location":"tutorial/options/autocompletion/#types-types-everywhere","text":"Typer uses the type declarations to detect what it has to provide to your autocompletion function. You can declare function parameters of these types: str : for the incomplete value. typer.Context : for the current context. List[str] : for the raw CLI parameters . It doesn't matter how you name them, in which order, or which ones of the 3 options you declare. It will all \" just work \" \u2728","title":"Types, types everywhere"},{"location":"tutorial/options/callback-and-context/","text":"In some occasions you might want to have some custom logic for a specific CLI parameter (for a CLI option or CLI argument ) that is executed with the value received from the terminal. In those cases you can use a CLI parameter callback function. Validate CLI parameters \u00b6 For example, you could do some validation before the rest of the code is executed. import typer def name_callback ( value : str ): if value != \"Camila\" : raise typer . BadParameter ( \"Only Camila is allowed\" ) return value def main ( name : str = typer . Option ( ... , callback = name_callback )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Here you pass a function to typer.Option() or typer.Argument() with the keyword argument callback . The function receives the value from the command line. It can do anything with it, and then return the value. In this case, if the --name is not Camila we raise a typer.BadParameter() exception. The BadParameter exception is special, it shows the error with the parameter that generated it. Check it: $ python main.py --name Camila Hello Camila $ python main.py --name Rick Usage: main.py [OPTIONS] // We get the error from the callback Error: Invalid value for '--name': Only Camila is allowed Handling completion \u00b6 There's something to be aware of with callbacks and completion that requires some small special handling. But first let's just use completion in your shell (Bash, Zsh, Fish, or PowerShell). After installing completion (for your own Python package or for Typer CLI ), when you use your CLI program and start adding a CLI option with -- an then hit TAB , your shell will show you the available CLI options (the same for CLI arguments , etc). To check it quickly without creating a new Python package, install Typer CLI and use it with the previous script: // Hit the TAB key in your keyboard below where you see the: [TAB] $ typer ./main.py [ TAB ][ TAB ] // Depending on your terminal/shell you will get some completion like this \u2728 run -- Run the provided Typer app. utils -- Extra utility commands for Typer apps. // Then try with \"run\" and --help $ typer ./main.py run --help // You get a help text with your CLI options as you normally would Usage: typer run [OPTIONS] Run the provided Typer app. Options: --name TEXT [required] --help Show this message and exit. // Then try completion with your program $ typer ./main.py run -- [ TAB ][ TAB ] // You get completion for CLI options --help -- Show this message and exit. --name // And you can run it as if it was with Python directly $ typer ./main.py run --name Camila Hello Camila How shell completion works \u00b6 The way it works internally is that the shell/terminal will call your CLI program with some special environment variables (that hold the current CLI parameters , etc) and your CLI program will print some special values that the shell will use to present completion. All this is handled for you by Typer behind the scenes. But the main important point is that it is all based on values printed by your program that the shell reads. Breaking completion in a callback \u00b6 Let's say that when the callback is running, we want to show a message saying that it's validating the name: import typer def name_callback ( value : str ): typer . echo ( \"Validating name\" ) if value != \"Camila\" : raise typer . BadParameter ( \"Only Camila is allowed\" ) return value def main ( name : str = typer . Option ( ... , callback = name_callback )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And because the callback will be called when the shell calls your program asking for completion, that message \"Validating name\" will be printed and it will break completion. It will look something like: // Run it normally $ typer ./main.py run --name Camila // See the extra message \"Validating name\" Validating name Hello Camila $ typer ./main.py run -- [ TAB ][ TAB ] // Some weird broken error message \u26d4\ufe0f (eval) :1: command not found: Validating rutyper ./main.pyed Typer app. Fix completion - using the Context \u00b6 When you create a Typer application it uses Click underneath. And every Click application has a special object called a \"Context\" that is normally hidden. But you can access the context by declaring a function parameter of type typer.Context . The \"context\" has some additional data about the current execution of your program: import typer def name_callback ( ctx : typer . Context , value : str ): if ctx . resilient_parsing : return typer . echo ( \"Validating name\" ) if value != \"Camila\" : raise typer . BadParameter ( \"Only Camila is allowed\" ) return value def main ( name : str = typer . Option ( ... , callback = name_callback )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) The ctx.resilient_parsing will be True when handling completion, so you can just return without printing anything else. But it will be False when calling the program normally. So you can continue the execution of your previous code. That's all is needed to fix completion \ud83d\ude80 Check it: $ typer ./main.py run -- [ TAB ][ TAB ] // Now it works correctly \ud83c\udf89 --help -- Show this message and exit. --name // And you can call it normally $ typer ./main.py run --name Camila Validating name Hello Camila Using the CallbackParam object \u00b6 The same way you can access the typer.Context by declaring a function parameter with its value, you can declare another function parameter with type typer.CallbackParam to get the specific Click Parameter object. import typer def name_callback ( ctx : typer . Context , param : typer . CallbackParam , value : str ): if ctx . resilient_parsing : return typer . echo ( f \"Validating param: { param . name } \" ) if value != \"Camila\" : raise typer . BadParameter ( \"Only Camila is allowed\" ) return value def main ( name : str = typer . Option ( ... , callback = name_callback )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) It's probably not very common, but you could do it if you need it. For example if you had a callback that could be used by several CLI parameters , that way the callback could know which parameter is each time. Check it: $ python main.py --name Camila Validating param: name Hello Camila Technical Details \u00b6 Because you get the relevant data in the callback function based on standard Python type annotations, you get type checks and autocompletion in your editor for free. And Typer will make sure you get the function parameters you want. You don't have to worry about their names, their order, etc. As it's based on standard Python types, it \" just works \". \u2728 Click's Parameter \u00b6 The typer.CallbackParam is actually just a sub-class of Click's Parameter , so you get all the right completion in your editor. Callback with type annotations \u00b6 You can get the typer.Context and the typer.CallbackParam simply by declaring a function parameter of each type. The order doesn't matter, the name of the function parameters doesn't matter. You could also get only the typer.CallbackParam and not the typer.Context , or vice versa, it will still work. value function parameter \u00b6 The value function parameter in the callback can also have any name (e.g. lastname ) and any type, but it should have the same type annotation as in the main function, because that's what it will receive. It's also possible to not declare its type. It will still work. And it's possible to not declare the value parameter at all, and, for example, only get the typer.Context . That will also work.","title":"CLI Option Callback and Context"},{"location":"tutorial/options/callback-and-context/#validate-cli-parameters","text":"For example, you could do some validation before the rest of the code is executed. import typer def name_callback ( value : str ): if value != \"Camila\" : raise typer . BadParameter ( \"Only Camila is allowed\" ) return value def main ( name : str = typer . Option ( ... , callback = name_callback )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Here you pass a function to typer.Option() or typer.Argument() with the keyword argument callback . The function receives the value from the command line. It can do anything with it, and then return the value. In this case, if the --name is not Camila we raise a typer.BadParameter() exception. The BadParameter exception is special, it shows the error with the parameter that generated it. Check it: $ python main.py --name Camila Hello Camila $ python main.py --name Rick Usage: main.py [OPTIONS] // We get the error from the callback Error: Invalid value for '--name': Only Camila is allowed","title":"Validate CLI parameters"},{"location":"tutorial/options/callback-and-context/#handling-completion","text":"There's something to be aware of with callbacks and completion that requires some small special handling. But first let's just use completion in your shell (Bash, Zsh, Fish, or PowerShell). After installing completion (for your own Python package or for Typer CLI ), when you use your CLI program and start adding a CLI option with -- an then hit TAB , your shell will show you the available CLI options (the same for CLI arguments , etc). To check it quickly without creating a new Python package, install Typer CLI and use it with the previous script: // Hit the TAB key in your keyboard below where you see the: [TAB] $ typer ./main.py [ TAB ][ TAB ] // Depending on your terminal/shell you will get some completion like this \u2728 run -- Run the provided Typer app. utils -- Extra utility commands for Typer apps. // Then try with \"run\" and --help $ typer ./main.py run --help // You get a help text with your CLI options as you normally would Usage: typer run [OPTIONS] Run the provided Typer app. Options: --name TEXT [required] --help Show this message and exit. // Then try completion with your program $ typer ./main.py run -- [ TAB ][ TAB ] // You get completion for CLI options --help -- Show this message and exit. --name // And you can run it as if it was with Python directly $ typer ./main.py run --name Camila Hello Camila","title":"Handling completion"},{"location":"tutorial/options/callback-and-context/#how-shell-completion-works","text":"The way it works internally is that the shell/terminal will call your CLI program with some special environment variables (that hold the current CLI parameters , etc) and your CLI program will print some special values that the shell will use to present completion. All this is handled for you by Typer behind the scenes. But the main important point is that it is all based on values printed by your program that the shell reads.","title":"How shell completion works"},{"location":"tutorial/options/callback-and-context/#breaking-completion-in-a-callback","text":"Let's say that when the callback is running, we want to show a message saying that it's validating the name: import typer def name_callback ( value : str ): typer . echo ( \"Validating name\" ) if value != \"Camila\" : raise typer . BadParameter ( \"Only Camila is allowed\" ) return value def main ( name : str = typer . Option ( ... , callback = name_callback )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And because the callback will be called when the shell calls your program asking for completion, that message \"Validating name\" will be printed and it will break completion. It will look something like: // Run it normally $ typer ./main.py run --name Camila // See the extra message \"Validating name\" Validating name Hello Camila $ typer ./main.py run -- [ TAB ][ TAB ] // Some weird broken error message \u26d4\ufe0f (eval) :1: command not found: Validating rutyper ./main.pyed Typer app.","title":"Breaking completion in a callback"},{"location":"tutorial/options/callback-and-context/#fix-completion-using-the-context","text":"When you create a Typer application it uses Click underneath. And every Click application has a special object called a \"Context\" that is normally hidden. But you can access the context by declaring a function parameter of type typer.Context . The \"context\" has some additional data about the current execution of your program: import typer def name_callback ( ctx : typer . Context , value : str ): if ctx . resilient_parsing : return typer . echo ( \"Validating name\" ) if value != \"Camila\" : raise typer . BadParameter ( \"Only Camila is allowed\" ) return value def main ( name : str = typer . Option ( ... , callback = name_callback )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) The ctx.resilient_parsing will be True when handling completion, so you can just return without printing anything else. But it will be False when calling the program normally. So you can continue the execution of your previous code. That's all is needed to fix completion \ud83d\ude80 Check it: $ typer ./main.py run -- [ TAB ][ TAB ] // Now it works correctly \ud83c\udf89 --help -- Show this message and exit. --name // And you can call it normally $ typer ./main.py run --name Camila Validating name Hello Camila","title":"Fix completion - using the Context"},{"location":"tutorial/options/callback-and-context/#using-the-callbackparam-object","text":"The same way you can access the typer.Context by declaring a function parameter with its value, you can declare another function parameter with type typer.CallbackParam to get the specific Click Parameter object. import typer def name_callback ( ctx : typer . Context , param : typer . CallbackParam , value : str ): if ctx . resilient_parsing : return typer . echo ( f \"Validating param: { param . name } \" ) if value != \"Camila\" : raise typer . BadParameter ( \"Only Camila is allowed\" ) return value def main ( name : str = typer . Option ( ... , callback = name_callback )): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) It's probably not very common, but you could do it if you need it. For example if you had a callback that could be used by several CLI parameters , that way the callback could know which parameter is each time. Check it: $ python main.py --name Camila Validating param: name Hello Camila","title":"Using the CallbackParam object"},{"location":"tutorial/options/callback-and-context/#technical-details","text":"Because you get the relevant data in the callback function based on standard Python type annotations, you get type checks and autocompletion in your editor for free. And Typer will make sure you get the function parameters you want. You don't have to worry about their names, their order, etc. As it's based on standard Python types, it \" just works \". \u2728","title":"Technical Details"},{"location":"tutorial/options/callback-and-context/#clicks-parameter","text":"The typer.CallbackParam is actually just a sub-class of Click's Parameter , so you get all the right completion in your editor.","title":"Click's Parameter"},{"location":"tutorial/options/callback-and-context/#callback-with-type-annotations","text":"You can get the typer.Context and the typer.CallbackParam simply by declaring a function parameter of each type. The order doesn't matter, the name of the function parameters doesn't matter. You could also get only the typer.CallbackParam and not the typer.Context , or vice versa, it will still work.","title":"Callback with type annotations"},{"location":"tutorial/options/callback-and-context/#value-function-parameter","text":"The value function parameter in the callback can also have any name (e.g. lastname ) and any type, but it should have the same type annotation as in the main function, because that's what it will receive. It's also possible to not declare its type. It will still work. And it's possible to not declare the value parameter at all, and, for example, only get the typer.Context . That will also work.","title":"value function parameter"},{"location":"tutorial/options/help/","text":"You already saw how to add a help text for CLI arguments with the help parameter. Let's now do the same for CLI options : import typer def main ( name : str , lastname : str = typer . Option ( \"\" , help = \"Last name of person to greet.\" ), formal : bool = typer . Option ( False , help = \"Say hi formally.\" ), ): \"\"\" Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. \"\"\" if formal : typer . echo ( f \"Good day Ms. { name } { lastname } .\" ) else : typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) We are replacing the default values we had before with typer.Option() . As we no longer have a default value there, the first parameter to typer.Option() serves the same purpose of defining that default value. So, if we had: lastname : str = \"\" now we write: lastname : str = typer . Option ( \"\" ) And both forms achieve the same: a CLI option with a default value of an empty string ( \"\" ). And then we can pass the help keyword parameter: lastname : str = typer . Option ( \"\" , help = \"this option does this and that\" ) to create the help for that CLI option . Copy that example from above to a file main.py . Test it: $ python main.py --help Usage: main.py [OPTIONS] NAME Say hi to NAME, optionally with a --lastname. If --formal is used, say hi very formally. Arguments: NAME [required] Options: --lastname TEXT Last name of person to greet. [default: ] --formal / --no-formal Say hi formally. [default: False] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Now you have a help text for the --lastname and --formal CLI options \ud83c\udf89 Hide default from help \u00b6 You can tell Typer to not show the default value in the help text with show_default=False : import typer def main ( fullname : str = typer . Option ( \"Wade Wilson\" , show_default = False )): typer . echo ( f \"Hello { fullname } \" ) if __name__ == \"__main__\" : typer . run ( main ) And it will no longer show the default value in the help text: $ python main.py Hello Wade Wilson // Show the help $ python main.py --help Usage: main.py [OPTIONS] Options: --fullname TEXT --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Notice there's no [default: Wade Wilson] \ud83d\udd25 Technical Details In Click applications the default values are hidden by default. \ud83d\ude48 In Typer these default values are shown by default. \ud83d\udc40","title":"CLI Options with Help"},{"location":"tutorial/options/help/#hide-default-from-help","text":"You can tell Typer to not show the default value in the help text with show_default=False : import typer def main ( fullname : str = typer . Option ( \"Wade Wilson\" , show_default = False )): typer . echo ( f \"Hello { fullname } \" ) if __name__ == \"__main__\" : typer . run ( main ) And it will no longer show the default value in the help text: $ python main.py Hello Wade Wilson // Show the help $ python main.py --help Usage: main.py [OPTIONS] Options: --fullname TEXT --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Notice there's no [default: Wade Wilson] \ud83d\udd25 Technical Details In Click applications the default values are hidden by default. \ud83d\ude48 In Typer these default values are shown by default. \ud83d\udc40","title":"Hide default from help"},{"location":"tutorial/options/name/","text":"By default Typer will create a CLI option name from the function parameter. So, if you have a function with: def main ( user_name : Optional [ str ] = None ): pass or def main ( user_name : Optional [ str ] = typer . Option ( None )): pass Typer will create a CLI option : --user-name But you can customize it if you want to. Let's say the function parameter name is user_name as above, but you want the CLI option to be just --name . You can pass the CLI option name that you want to have in the next positional argument passed to typer.Option() : import typer def main ( user_name : str = typer . Option ( ... , \"--name\" )): typer . echo ( f \"Hello { user_name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Here you are passing the string \"--name\" as the second positional argument to typer.Option() . Info \" Positional \" means that it's not a function argument with a keyword name. For example show_default=True is a keyword argument. \" show_default \" is the keyword. But in \"--name\" there's no option_name=\"--name\" or something similar, it's just the string value \"--name\" that goes in typer.Option() after the ... value passed in the first position. That's a \"positional argument\" in a function. Check it: $ python main.py --help // Notice the --name instead of --user-name Usage: main.py [OPTIONS] Options: --name TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python --name Camila Hello Camila CLI option short names \u00b6 A short name is a CLI option name with a single dash ( - ) instead of 2 ( -- ) and a single letter, like -n instead of --name . For example, the ls program has a CLI option named --size , and the same CLI option also has a short name -s : // With the long name --size $ ls ./myproject --size 12 first-steps.md 4 intro.md // With the short name -s $ ls ./myproject -s 12 first-steps.md 4 intro.md // Both CLI option names do the same CLI option short names together \u00b6 Short names have another feature, when they have a single letter, as in -s , you can put several of these CLI options together, with a single dash. For example, the ls program has these 2 CLI options (among others): --size : show the sizes of the listed files. --human : show a human-readable format, like 1MB instead of just 1024 . And these 2 CLI options have short versions too: --size : short version -s . --human : short version -h . So, you can put them together with -sh or -hs : // Call ls with long CLI options $ ls --size --human 12K first-steps.md 4.0K intro.md // Now with short versions $ ls -s -h 12K first-steps.md 4.0K intro.md // And with short versions together $ ls -sh 12K first-steps.md 4.0K intro.md // Order in short versions doesn't matter $ ls -hs 12K first-steps.md 4.0K intro.md // They all work the same \ud83c\udf89 CLI option short names with values \u00b6 When you use CLI options with short names, you can put them together if they are just boolean flags, like --size or --human . But if you have a CLI option --file with a short name -f that takes a value, if you put it with other short names for CLI options , you have to put it as the last letter, so that it can receive the value that comes right after. For example, let's say you are decompressing/extracting a file myproject.tar.gz with the program tar . You can pass these CLI option short names to tar : -x : means \"e X tract\", to decompress and extract the contents. -v : means \" V erbose\", to print on the screen what it is doing, so you can know that it's decompressing each file and can entertain yourself while you wait. -f : means \" F ile\", this one requires a value, the compressed file to extract (in our example, this is myproject.tar.gz ). So if you use all the short names together, this -f has to come last, to receive the value that comes next to it. For example: $ tar -xvf myproject.tar.gz myproject/ myproject/first-steps.md myproject/intro.md // But if you put the -f before $ tar -fxv myproject.tar.gz // You get an ugly error tar: You must specify one of the blah, blah, error, error Defining CLI option short names \u00b6 In Typer you can also define CLI option short names the same way you can customize the long names. typer.Option() receives as a first function argument the default value, e.g. None , and all the next positional values are to define the CLI option name(s). Tip Remember the positional function arguments are those that don't have a keyword. All the other function arguments/parameters you pass to typer.Option() like prompt=True and help=\"This option blah, blah\" require the keyword. You can overwrite the CLI option name to use as in the previous example, but you can also declare extra alternatives, including short names. For example, extending the previous example, let's add a CLI option short name -n : import typer def main ( user_name : str = typer . Option ( ... , \"--name\" , \"-n\" )): typer . echo ( f \"Hello { user_name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Here we are overwriting the CLI option name that by default would be --user-name , and we are defining it to be --name . And we are also declaring a CLI option short name of -n . Check it: // Check the help $ python main.py --help // Notice the two CLI option names -n and --name Usage: main.py [OPTIONS] Options: -n, --name TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try the short version $ python main.py -n Camila Hello Camila CLI option only short name \u00b6 If you only declare a short name like -n then that will be the only CLI option name. And neither --name nor --user-name will be available. import typer def main ( user_name : str = typer . Option ( ... , \"-n\" )): typer . echo ( f \"Hello { user_name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --help // Notice there's no --name nor --user-name, only -n Usage: main.py [OPTIONS] Options: -n TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py -n Camila Hello Camila CLI option short name and default \u00b6 Continuing with the example above, as Typer allows you to declare a CLI option as having only a short name, if you want to have the default long name plus a short name, you have to declare both explicitly: import typer def main ( user_name : str = typer . Option ( ... , \"--user-name\" , \"-n\" )): typer . echo ( f \"Hello { user_name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --help // Notice that we have the long version --user-name back // and we also have the short version -n Usage: main.py [OPTIONS] Options: -n, --user-name TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py --user-name Camila Hello Camila // And try the short version $ python main.py -n Camila CLI option short names together \u00b6 You can create multiple short names and use them together. You don't have to do anything special for it to work (apart from declaring those short versions): import typer def main ( name : str = typer . Option ( ... , \"--name\" , \"-n\" ), formal : bool = typer . Option ( False , \"--formal\" , \"-f\" ), ): if formal : typer . echo ( f \"Good day Ms. { name } .\" ) else : typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Notice that, again, we are declaring the long and short version of the CLI option names. Check it: $ python main.py --help // We now have short versions -n and -f // And also long versions --name and --formal Usage: main.py [OPTIONS] Options: -n, --name TEXT [required] -f, --formal --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try the short versions $ python main.py -n Camila -f Good day Ms. Camila. // And try the 2 short versions together // See how -n has to go last, to be able to get the value $ python main.py -fn Camila Good day Ms. Camila.","title":"CLI Option Name"},{"location":"tutorial/options/name/#cli-option-short-names","text":"A short name is a CLI option name with a single dash ( - ) instead of 2 ( -- ) and a single letter, like -n instead of --name . For example, the ls program has a CLI option named --size , and the same CLI option also has a short name -s : // With the long name --size $ ls ./myproject --size 12 first-steps.md 4 intro.md // With the short name -s $ ls ./myproject -s 12 first-steps.md 4 intro.md // Both CLI option names do the same","title":"CLI option short names"},{"location":"tutorial/options/name/#cli-option-short-names-together","text":"Short names have another feature, when they have a single letter, as in -s , you can put several of these CLI options together, with a single dash. For example, the ls program has these 2 CLI options (among others): --size : show the sizes of the listed files. --human : show a human-readable format, like 1MB instead of just 1024 . And these 2 CLI options have short versions too: --size : short version -s . --human : short version -h . So, you can put them together with -sh or -hs : // Call ls with long CLI options $ ls --size --human 12K first-steps.md 4.0K intro.md // Now with short versions $ ls -s -h 12K first-steps.md 4.0K intro.md // And with short versions together $ ls -sh 12K first-steps.md 4.0K intro.md // Order in short versions doesn't matter $ ls -hs 12K first-steps.md 4.0K intro.md // They all work the same \ud83c\udf89","title":"CLI option short names together"},{"location":"tutorial/options/name/#cli-option-short-names-with-values","text":"When you use CLI options with short names, you can put them together if they are just boolean flags, like --size or --human . But if you have a CLI option --file with a short name -f that takes a value, if you put it with other short names for CLI options , you have to put it as the last letter, so that it can receive the value that comes right after. For example, let's say you are decompressing/extracting a file myproject.tar.gz with the program tar . You can pass these CLI option short names to tar : -x : means \"e X tract\", to decompress and extract the contents. -v : means \" V erbose\", to print on the screen what it is doing, so you can know that it's decompressing each file and can entertain yourself while you wait. -f : means \" F ile\", this one requires a value, the compressed file to extract (in our example, this is myproject.tar.gz ). So if you use all the short names together, this -f has to come last, to receive the value that comes next to it. For example: $ tar -xvf myproject.tar.gz myproject/ myproject/first-steps.md myproject/intro.md // But if you put the -f before $ tar -fxv myproject.tar.gz // You get an ugly error tar: You must specify one of the blah, blah, error, error","title":"CLI option short names with values"},{"location":"tutorial/options/name/#defining-cli-option-short-names","text":"In Typer you can also define CLI option short names the same way you can customize the long names. typer.Option() receives as a first function argument the default value, e.g. None , and all the next positional values are to define the CLI option name(s). Tip Remember the positional function arguments are those that don't have a keyword. All the other function arguments/parameters you pass to typer.Option() like prompt=True and help=\"This option blah, blah\" require the keyword. You can overwrite the CLI option name to use as in the previous example, but you can also declare extra alternatives, including short names. For example, extending the previous example, let's add a CLI option short name -n : import typer def main ( user_name : str = typer . Option ( ... , \"--name\" , \"-n\" )): typer . echo ( f \"Hello { user_name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Here we are overwriting the CLI option name that by default would be --user-name , and we are defining it to be --name . And we are also declaring a CLI option short name of -n . Check it: // Check the help $ python main.py --help // Notice the two CLI option names -n and --name Usage: main.py [OPTIONS] Options: -n, --name TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try the short version $ python main.py -n Camila Hello Camila","title":"Defining CLI option short names"},{"location":"tutorial/options/name/#cli-option-only-short-name","text":"If you only declare a short name like -n then that will be the only CLI option name. And neither --name nor --user-name will be available. import typer def main ( user_name : str = typer . Option ( ... , \"-n\" )): typer . echo ( f \"Hello { user_name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --help // Notice there's no --name nor --user-name, only -n Usage: main.py [OPTIONS] Options: -n TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py -n Camila Hello Camila","title":"CLI option only short name"},{"location":"tutorial/options/name/#cli-option-short-name-and-default","text":"Continuing with the example above, as Typer allows you to declare a CLI option as having only a short name, if you want to have the default long name plus a short name, you have to declare both explicitly: import typer def main ( user_name : str = typer . Option ( ... , \"--user-name\" , \"-n\" )): typer . echo ( f \"Hello { user_name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --help // Notice that we have the long version --user-name back // and we also have the short version -n Usage: main.py [OPTIONS] Options: -n, --user-name TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py --user-name Camila Hello Camila // And try the short version $ python main.py -n Camila","title":"CLI option short name and default"},{"location":"tutorial/options/name/#cli-option-short-names-together_1","text":"You can create multiple short names and use them together. You don't have to do anything special for it to work (apart from declaring those short versions): import typer def main ( name : str = typer . Option ( ... , \"--name\" , \"-n\" ), formal : bool = typer . Option ( False , \"--formal\" , \"-f\" ), ): if formal : typer . echo ( f \"Good day Ms. { name } .\" ) else : typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Notice that, again, we are declaring the long and short version of the CLI option names. Check it: $ python main.py --help // We now have short versions -n and -f // And also long versions --name and --formal Usage: main.py [OPTIONS] Options: -n, --name TEXT [required] -f, --formal --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try the short versions $ python main.py -n Camila -f Good day Ms. Camila. // And try the 2 short versions together // See how -n has to go last, to be able to get the value $ python main.py -fn Camila Good day Ms. Camila.","title":"CLI option short names together"},{"location":"tutorial/options/password/","text":"Apart from having a prompt, you can make a CLI option have a confirmation_prompt=True : import typer def main ( name : str , email : str = typer . Option ( ... , prompt = True , confirmation_prompt = True ) ): typer . echo ( f \"Hello { name } , your email is { email } \" ) if __name__ == \"__main__\" : typer . run ( main ) And the CLI program will ask for confirmation: $ python main.py Camila // It prompts for the email # Email: $ camila@example.com # Repeat for confirmation: $ camila@example.com Hello Camila, your email is camila@example.com A Password prompt \u00b6 When receiving a password, it is very common (in most shells) to not show anything on the screen while typing the password. The program will still receive the password, but nothing will be shown on screen, not even **** . You can achieve the same using hide_input=True . And if you combine it with confirmation_prompt=True you can easily receive a password with double confirmation: import typer def main ( name : str , password : str = typer . Option ( ... , prompt = True , confirmation_prompt = True , hide_input = True ), ): typer . echo ( f \"Hello { name } . Doing something very secure with password.\" ) typer . echo ( f \"...just kidding, here it is, very insecure: { password } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py Camila // It prompts for the password, but doesn't show anything when you type # Password: $ # Repeat for confirmation: $ // Let's imagine the password typed was \"typerrocks\" Hello Camila. Doing something very secure with password. ...just kidding, here it is, very insecure: typerrocks","title":"Password CLI Option and Confirmation Prompt"},{"location":"tutorial/options/password/#a-password-prompt","text":"When receiving a password, it is very common (in most shells) to not show anything on the screen while typing the password. The program will still receive the password, but nothing will be shown on screen, not even **** . You can achieve the same using hide_input=True . And if you combine it with confirmation_prompt=True you can easily receive a password with double confirmation: import typer def main ( name : str , password : str = typer . Option ( ... , prompt = True , confirmation_prompt = True , hide_input = True ), ): typer . echo ( f \"Hello { name } . Doing something very secure with password.\" ) typer . echo ( f \"...just kidding, here it is, very insecure: { password } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py Camila // It prompts for the password, but doesn't show anything when you type # Password: $ # Repeat for confirmation: $ // Let's imagine the password typed was \"typerrocks\" Hello Camila. Doing something very secure with password. ...just kidding, here it is, very insecure: typerrocks","title":"A Password prompt"},{"location":"tutorial/options/prompt/","text":"It's also possible to, instead of just showing an error, ask for the missing value with prompt=True : import typer def main ( name : str , lastname : str = typer . Option ( ... , prompt = True )): typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) And then your program will ask the user for it in the terminal: // Call it with the NAME CLI argument $ python main.py Camila // It asks for the missing CLI option --lastname # Lastname: $ Guti\u00e9rrez Hello Camila Guti\u00e9rrez Customize the prompt \u00b6 You can also set a custom prompt, passing the string that you want to use instead of just True : import typer def main ( name : str , lastname : str = typer . Option ( ... , prompt = \"Please tell me your last name\" ) ): typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) And then your program will ask for it using with your custom prompt: // Call it with the NAME CLI argument $ python main.py Camila // It uses the custom prompt # Please tell me your last name: $ Guti\u00e9rrez Hello Camila Guti\u00e9rrez Confirmation prompt \u00b6 In some cases you could want to prompt for something and then ask the user to confirm it by typing it twice. You can do it passing the parameter confirmation_prompt=True . Let's say it's a CLI app to delete a project: import typer def main ( project_name : str = typer . Option ( ... , prompt = True , confirmation_prompt = True )): typer . echo ( f \"Deleting project { project_name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And it will prompt the user for a value and then for the confirmation: $ python main.py // Your app will first prompt for the project name, and then for the confirmation # Project name: $ Old Project # Repeat for confirmation: $ Old Project Deleting project Old Project // If the user doesn't type the same, receives an error and a new prompt $ python main.py # Project name: $ Old Project # Repeat for confirmation: $ New Spice Error: the two entered values do not match # Project name: $ Old Project # Repeat for confirmation: $ Old Project Deleting project Old Project // Now it works \ud83c\udf89","title":"CLI Option Prompt"},{"location":"tutorial/options/prompt/#customize-the-prompt","text":"You can also set a custom prompt, passing the string that you want to use instead of just True : import typer def main ( name : str , lastname : str = typer . Option ( ... , prompt = \"Please tell me your last name\" ) ): typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) And then your program will ask for it using with your custom prompt: // Call it with the NAME CLI argument $ python main.py Camila // It uses the custom prompt # Please tell me your last name: $ Guti\u00e9rrez Hello Camila Guti\u00e9rrez","title":"Customize the prompt"},{"location":"tutorial/options/prompt/#confirmation-prompt","text":"In some cases you could want to prompt for something and then ask the user to confirm it by typing it twice. You can do it passing the parameter confirmation_prompt=True . Let's say it's a CLI app to delete a project: import typer def main ( project_name : str = typer . Option ( ... , prompt = True , confirmation_prompt = True )): typer . echo ( f \"Deleting project { project_name } \" ) if __name__ == \"__main__\" : typer . run ( main ) And it will prompt the user for a value and then for the confirmation: $ python main.py // Your app will first prompt for the project name, and then for the confirmation # Project name: $ Old Project # Repeat for confirmation: $ Old Project Deleting project Old Project // If the user doesn't type the same, receives an error and a new prompt $ python main.py # Project name: $ Old Project # Repeat for confirmation: $ New Spice Error: the two entered values do not match # Project name: $ Old Project # Repeat for confirmation: $ Old Project Deleting project Old Project // Now it works \ud83c\udf89","title":"Confirmation prompt"},{"location":"tutorial/options/required/","text":"We said before that by default : CLI options are optional CLI arguments are required Well, that's how they work by default , and that's the convention in many CLI programs and systems. But if you really want, you can change that. To make a CLI option required, pass ... to typer.Option() . Info If you hadn't seen that ... before: it is a a special single value, it is part of Python and is called \"Ellipsis\" . That will tell Typer that it's still a CLI option , but it doesn't have a default value, and it's required. Let's make --lastname a required CLI option : import typer def main ( name : str , lastname : str = typer . Option ( ... )): typer . echo ( f \"Hello { name } { lastname } \" ) if __name__ == \"__main__\" : typer . run ( main ) And test it: // Pass the NAME CLI argument $ python main.py Camila // We didn't pass the now required --lastname CLI option Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Missing option '--lastname'. // Now update it to pass the required --lastname CLI option $ python main.py Camila --lastname Guti\u00e9rrez Hello Camila Guti\u00e9rrez // And if you check the help $ python main.py --help Usage: main.py [OPTIONS] NAME Options: --lastname TEXT [required] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // It now tells you that --lastname is required \ud83c\udf89","title":"Required CLI Options"},{"location":"tutorial/options/version/","text":"You could use a callback to implement a --version CLI option . It would show the version of your CLI program and then it would terminate it. Even before any other CLI parameter is processed. First version of --version \u00b6 Let's see a first version of how it could look like: from typing import Optional import typer __version__ = \"0.1.0\" def version_callback ( value : bool ): if value : typer . echo ( f \"Awesome CLI Version: { __version__ } \" ) raise typer . Exit () def main ( name : str = typer . Option ( \"World\" ), version : Optional [ bool ] = typer . Option ( None , \"--version\" , callback = version_callback ), ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Notice that we don't have to get the typer.Context and check for ctx.resilient_parsing for completion to work, because we only print and modify the program when --version is passed, otherwise, nothing is printed or changed from the callback. If the --version CLI option is passed, we get a value True in the callback. Then we can print the version and raise typer.Exit() to make sure the program is terminated before anything else is executed. We also declare the explicit CLI option name --version , because we don't want an automatic --no-version , it would look awkward. Check it: $ python main.py --help // We get a --version, and don't get an awkward --no-version \ud83c\udf89 Usage: main.py [OPTIONS] Options: --version --name TEXT --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // We can call it normally $ python main.py --name Camila Hello Camila // And we can get the version $ python main.py --version Awesome CLI Version: 0.1.0 // Because we exit in the callback, we don't get a \"Hello World\" message after the version \ud83d\ude80 Previous parameters and is_eager \u00b6 But now let's say that the --name CLI option that we declared before --version is required, and it has a callback that could exit the program: from typing import Optional import typer __version__ = \"0.1.0\" def version_callback ( value : bool ): if value : typer . echo ( f \"Awesome CLI Version: { __version__ } \" ) raise typer . Exit () def name_callback ( name : str ): if name != \"Camila\" : raise typer . BadParameter ( \"Only Camila is allowed\" ) def main ( name : str = typer . Option ( ... , callback = name_callback ), version : Optional [ bool ] = typer . Option ( None , \"--version\" , callback = version_callback ), ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Then our CLI program could not work as expected in some cases as it is right now , because if we use --version after --name then the callback for --name will be processed before and we can get its error: $ python main.py --name Rick --version Only Camila is allowed Aborted! Tip We don't have to check for ctx.resilient_parsing in the name_callback() for completion to work, because we are not using typer.echo() , instead we are raising a typer.BadParameter . Technical Details typer.BadParameter prints the error to \"standard error\", not to \"standard output\", and because the completion system only reads from \"standard output\", it won't break completion. Info If you need a refresher about what is \"standard output\" and \"standard error\" check the section in Printing and Colors: \"Standard Output\" and \"Standard Error\" . Fix with is_eager \u00b6 For those cases, we can mark a CLI parameter (a CLI option or CLI argument ) with is_eager=True . That will tell Typer (actually Click) that it should process this CLI parameter before the others: from typing import Optional import typer __version__ = \"0.1.0\" def version_callback ( value : bool ): if value : typer . echo ( f \"Awesome CLI Version: { __version__ } \" ) raise typer . Exit () def name_callback ( name : str ): if name != \"Camila\" : raise typer . BadParameter ( \"Only Camila is allowed\" ) return name def main ( name : str = typer . Option ( ... , callback = name_callback ), version : Optional [ bool ] = typer . Option ( None , \"--version\" , callback = version_callback , is_eager = True ), ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --name Rick --version // Now we only get the version, and the name is not used Awesome CLI Version: 0.1.0","title":"Version CLI Option, is_eager"},{"location":"tutorial/options/version/#first-version-of-version","text":"Let's see a first version of how it could look like: from typing import Optional import typer __version__ = \"0.1.0\" def version_callback ( value : bool ): if value : typer . echo ( f \"Awesome CLI Version: { __version__ } \" ) raise typer . Exit () def main ( name : str = typer . Option ( \"World\" ), version : Optional [ bool ] = typer . Option ( None , \"--version\" , callback = version_callback ), ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Notice that we don't have to get the typer.Context and check for ctx.resilient_parsing for completion to work, because we only print and modify the program when --version is passed, otherwise, nothing is printed or changed from the callback. If the --version CLI option is passed, we get a value True in the callback. Then we can print the version and raise typer.Exit() to make sure the program is terminated before anything else is executed. We also declare the explicit CLI option name --version , because we don't want an automatic --no-version , it would look awkward. Check it: $ python main.py --help // We get a --version, and don't get an awkward --no-version \ud83c\udf89 Usage: main.py [OPTIONS] Options: --version --name TEXT --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // We can call it normally $ python main.py --name Camila Hello Camila // And we can get the version $ python main.py --version Awesome CLI Version: 0.1.0 // Because we exit in the callback, we don't get a \"Hello World\" message after the version \ud83d\ude80","title":"First version of --version"},{"location":"tutorial/options/version/#previous-parameters-and-is_eager","text":"But now let's say that the --name CLI option that we declared before --version is required, and it has a callback that could exit the program: from typing import Optional import typer __version__ = \"0.1.0\" def version_callback ( value : bool ): if value : typer . echo ( f \"Awesome CLI Version: { __version__ } \" ) raise typer . Exit () def name_callback ( name : str ): if name != \"Camila\" : raise typer . BadParameter ( \"Only Camila is allowed\" ) def main ( name : str = typer . Option ( ... , callback = name_callback ), version : Optional [ bool ] = typer . Option ( None , \"--version\" , callback = version_callback ), ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Then our CLI program could not work as expected in some cases as it is right now , because if we use --version after --name then the callback for --name will be processed before and we can get its error: $ python main.py --name Rick --version Only Camila is allowed Aborted! Tip We don't have to check for ctx.resilient_parsing in the name_callback() for completion to work, because we are not using typer.echo() , instead we are raising a typer.BadParameter . Technical Details typer.BadParameter prints the error to \"standard error\", not to \"standard output\", and because the completion system only reads from \"standard output\", it won't break completion. Info If you need a refresher about what is \"standard output\" and \"standard error\" check the section in Printing and Colors: \"Standard Output\" and \"Standard Error\" .","title":"Previous parameters and is_eager"},{"location":"tutorial/options/version/#fix-with-is_eager","text":"For those cases, we can mark a CLI parameter (a CLI option or CLI argument ) with is_eager=True . That will tell Typer (actually Click) that it should process this CLI parameter before the others: from typing import Optional import typer __version__ = \"0.1.0\" def version_callback ( value : bool ): if value : typer . echo ( f \"Awesome CLI Version: { __version__ } \" ) raise typer . Exit () def name_callback ( name : str ): if name != \"Camila\" : raise typer . BadParameter ( \"Only Camila is allowed\" ) return name def main ( name : str = typer . Option ( ... , callback = name_callback ), version : Optional [ bool ] = typer . Option ( None , \"--version\" , callback = version_callback , is_eager = True ), ): typer . echo ( f \"Hello { name } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --name Rick --version // Now we only get the version, and the name is not used Awesome CLI Version: 0.1.0","title":"Fix with is_eager"},{"location":"tutorial/parameter-types/","text":"You can use several data types for the CLI options and CLI arguments , and you can add data validation requirements too. Data conversion \u00b6 When you declare a CLI parameter with some type Typer will convert the data received in the command line to that data type. For example: import typer def main ( name : str , age : int = 20 , height_meters : float = 1.89 , female : bool = True ): typer . echo ( f \"NAME is { name } , of type: { type ( name ) } \" ) typer . echo ( f \"--age is { age } , of type: { type ( age ) } \" ) typer . echo ( f \"--height-meters is { height_meters } , of type: { type ( height_meters ) } \" ) typer . echo ( f \"--female is { female } , of type: { type ( female ) } \" ) if __name__ == \"__main__\" : typer . run ( main ) In this example, the value received for the CLI argument NAME will be treated as str . The value for the CLI option --age will be converted to an int and --height-meters will be converted to a float . And as female is a bool CLI option , Typer will convert it to a \"flag\" --female and the counterpart --no-female . And here's how it looks like: $ python main.py --help // Notice how --age is an INTEGER and --height-meters is a FLOAT Usage: main.py [OPTIONS] NAME Arguments: NAME [required] Options: --age INTEGER [default: 20] --height-meters FLOAT [default: 1.89] --female / --no-female [default: True] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Call it with CLI parameters $ python main.py Camila --age 15 --height-meters 1 .70 --female // All the data has the correct Python type NAME is Camila, of type: class 'str' --age is 15, of type: class 'int' --height-meters is 1.7, of type: class 'float' --female is True, of type: class 'bool' // And if you pass an incorrect type $ python main.py Camila --age 15 .3 Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Invalid value for '--age': 15.3 is not a valid integer // Because 15.3 is not an INTEGER (it's a float) Watch next \u00b6 See more about specific types and validations in the next sections... Technical Details All the types you will see in the next sections are handled underneath by Click's Parameter Types .","title":"CLI Parameter Types Intro"},{"location":"tutorial/parameter-types/#data-conversion","text":"When you declare a CLI parameter with some type Typer will convert the data received in the command line to that data type. For example: import typer def main ( name : str , age : int = 20 , height_meters : float = 1.89 , female : bool = True ): typer . echo ( f \"NAME is { name } , of type: { type ( name ) } \" ) typer . echo ( f \"--age is { age } , of type: { type ( age ) } \" ) typer . echo ( f \"--height-meters is { height_meters } , of type: { type ( height_meters ) } \" ) typer . echo ( f \"--female is { female } , of type: { type ( female ) } \" ) if __name__ == \"__main__\" : typer . run ( main ) In this example, the value received for the CLI argument NAME will be treated as str . The value for the CLI option --age will be converted to an int and --height-meters will be converted to a float . And as female is a bool CLI option , Typer will convert it to a \"flag\" --female and the counterpart --no-female . And here's how it looks like: $ python main.py --help // Notice how --age is an INTEGER and --height-meters is a FLOAT Usage: main.py [OPTIONS] NAME Arguments: NAME [required] Options: --age INTEGER [default: 20] --height-meters FLOAT [default: 1.89] --female / --no-female [default: True] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Call it with CLI parameters $ python main.py Camila --age 15 --height-meters 1 .70 --female // All the data has the correct Python type NAME is Camila, of type: class 'str' --age is 15, of type: class 'int' --height-meters is 1.7, of type: class 'float' --female is True, of type: class 'bool' // And if you pass an incorrect type $ python main.py Camila --age 15 .3 Usage: main.py [OPTIONS] NAME Try \"main.py --help\" for help. Error: Invalid value for '--age': 15.3 is not a valid integer // Because 15.3 is not an INTEGER (it's a float)","title":"Data conversion"},{"location":"tutorial/parameter-types/#watch-next","text":"See more about specific types and validations in the next sections... Technical Details All the types you will see in the next sections are handled underneath by Click's Parameter Types .","title":"Watch next"},{"location":"tutorial/parameter-types/bool/","text":"We have seen some examples of CLI options with bool , and how Typer creates --something and --no-something automatically. But we can customize those names. Only --force \u00b6 Let's say that we want a --force CLI option only, we want to discard --no-force . We can do that by specifying the exact name we want: import typer def main ( force : bool = typer . Option ( False , \"--force\" )): if force : typer . echo ( \"Forcing operation\" ) else : typer . echo ( \"Not forcing\" ) if __name__ == \"__main__\" : typer . run ( main ) Now there's only a --force CLI option : // Check the help $ python main.py --help // Notice there's only --force, we no longer have --no-force Usage: main.py [OPTIONS] Options: --force [default: False] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it: $ python main.py Not forcing // Now add --force $ python main.py --force Forcing operation // And --no-force no longer exists \u26d4\ufe0f $ python main.py --no-force Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: no such option: --no-force Alternative names \u00b6 Now let's imagine we have a CLI option --accept . And we want to allow setting --accept or the contrary, but --no-accept looks ugly. We might want to instead have --accept and --reject . We can do that by passing a single str with the 2 names for the bool CLI option separated by / : from typing import Optional import typer def main ( accept : Optional [ bool ] = typer . Option ( None , \"--accept/--reject\" )): if accept is None : typer . echo ( \"I don't know what you want yet\" ) elif accept : typer . echo ( \"Accepting!\" ) else : typer . echo ( \"Rejecting!\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Check the help $ python main.py --help // Notice the --accept / --reject Usage: main.py [OPTIONS] Options: --accept / --reject --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py I don't know what you want yet // Now pass --accept $ python main.py --accept Accepting! // And --reject $ python main.py --reject Rejecting! Short names \u00b6 The same way, you can declare short versions of the names for these CLI options . For example, let's say we want -f for --force and -F for --no-force : import typer def main ( force : bool = typer . Option ( False , \"--force/--no-force\" , \"-f/-F\" )): if force : typer . echo ( \"Forcing operation\" ) else : typer . echo ( \"Not forcing\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Check the help $ python main.py --help // Notice the -f, --force / -F, --no-force Usage: main.py [OPTIONS] Options: -f, --force / -F, --no-force [default: False] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try with the short name -f $ python main.py -f Forcing operation // Try with the short name -F $ python main.py -F Not forcing Only names for False \u00b6 If you want to (although it might not be a good idea), you can declare only CLI option names to set the False value. To do that, use a space and a single / and pass the negative name after: import typer def main ( in_prod : bool = typer . Option ( True , \" /--demo\" , \" /-d\" )): if in_prod : typer . echo ( \"Running in production\" ) else : typer . echo ( \"Running demo\" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Have in mind that it's a string with a preceding space and then a / . So, it's \" /-S\" not \"/-S\" . Check it: // Check the help $ python main.py --help // Notice the / -d, --demo Usage: main.py [OPTIONS] Options: / -d, --demo [default: True] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py Running in production // Now pass --demo $ python main.py --demo Running demo // And the short version $ python main.py -d Running demo","title":"Boolean CLI Options"},{"location":"tutorial/parameter-types/bool/#only-force","text":"Let's say that we want a --force CLI option only, we want to discard --no-force . We can do that by specifying the exact name we want: import typer def main ( force : bool = typer . Option ( False , \"--force\" )): if force : typer . echo ( \"Forcing operation\" ) else : typer . echo ( \"Not forcing\" ) if __name__ == \"__main__\" : typer . run ( main ) Now there's only a --force CLI option : // Check the help $ python main.py --help // Notice there's only --force, we no longer have --no-force Usage: main.py [OPTIONS] Options: --force [default: False] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it: $ python main.py Not forcing // Now add --force $ python main.py --force Forcing operation // And --no-force no longer exists \u26d4\ufe0f $ python main.py --no-force Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: no such option: --no-force","title":"Only --force"},{"location":"tutorial/parameter-types/bool/#alternative-names","text":"Now let's imagine we have a CLI option --accept . And we want to allow setting --accept or the contrary, but --no-accept looks ugly. We might want to instead have --accept and --reject . We can do that by passing a single str with the 2 names for the bool CLI option separated by / : from typing import Optional import typer def main ( accept : Optional [ bool ] = typer . Option ( None , \"--accept/--reject\" )): if accept is None : typer . echo ( \"I don't know what you want yet\" ) elif accept : typer . echo ( \"Accepting!\" ) else : typer . echo ( \"Rejecting!\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Check the help $ python main.py --help // Notice the --accept / --reject Usage: main.py [OPTIONS] Options: --accept / --reject --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py I don't know what you want yet // Now pass --accept $ python main.py --accept Accepting! // And --reject $ python main.py --reject Rejecting!","title":"Alternative names"},{"location":"tutorial/parameter-types/bool/#short-names","text":"The same way, you can declare short versions of the names for these CLI options . For example, let's say we want -f for --force and -F for --no-force : import typer def main ( force : bool = typer . Option ( False , \"--force/--no-force\" , \"-f/-F\" )): if force : typer . echo ( \"Forcing operation\" ) else : typer . echo ( \"Not forcing\" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Check the help $ python main.py --help // Notice the -f, --force / -F, --no-force Usage: main.py [OPTIONS] Options: -f, --force / -F, --no-force [default: False] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try with the short name -f $ python main.py -f Forcing operation // Try with the short name -F $ python main.py -F Not forcing","title":"Short names"},{"location":"tutorial/parameter-types/bool/#only-names-for-false","text":"If you want to (although it might not be a good idea), you can declare only CLI option names to set the False value. To do that, use a space and a single / and pass the negative name after: import typer def main ( in_prod : bool = typer . Option ( True , \" /--demo\" , \" /-d\" )): if in_prod : typer . echo ( \"Running in production\" ) else : typer . echo ( \"Running demo\" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Have in mind that it's a string with a preceding space and then a / . So, it's \" /-S\" not \"/-S\" . Check it: // Check the help $ python main.py --help // Notice the / -d, --demo Usage: main.py [OPTIONS] Options: / -d, --demo [default: True] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py Running in production // Now pass --demo $ python main.py --demo Running demo // And the short version $ python main.py -d Running demo","title":"Only names for False"},{"location":"tutorial/parameter-types/datetime/","text":"You can specify a CLI parameter as a Python datetime . Your function will receive a standard Python datetime object, and again, your editor will give you completion, etc. from datetime import datetime import typer def main ( birth : datetime ): typer . echo ( f \"Interesting day to be born: { birth } \" ) typer . echo ( f \"Birth hour: { birth . hour } \" ) if __name__ == \"__main__\" : typer . run ( main ) Typer will accept any string from the following formats: * %Y-%m-%d * %Y-%m-%dT%H:%M:%S * %Y-%m%d %H:%M:%S Check it: $ python main.py --help Usage: main.py [OPTIONS] BIRTH:[%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S] Arguments: BIRTH:[%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S][required] Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Pass a datetime $ python main.py 1956 -01-31T10:00:00 Interesting day to be born: 1956-01-31 10:00:00 Birth hour: 10 // An invalid date $ python main.py july-19-1989 Usage: main.py [OPTIONS] [%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d%H:%M:%S] Error: Invalid value for '[%Y-%m-%d|%Y-%m-%dT%H:%M:%S|%Y-%m-%d %H:%M:%S]': invalid datetime format: july-19-1989. (choose from %Y-%m-%d, %Y-%m-%dT%H:%M:%S, %Y-%m-%d %H:%M:%S) Custom date format \u00b6 You can also customize the formats received for the datetime with the formats parameter. formats receives a list of strings with the date formats that would be passed to datetime.strptime() . For example, let's imagine that you want to accept an ISO formatted datetime, but for some strange reason, you also want to accept a format with: first the month then the day then the year separated with \" / \" ...It's a crazy example, but let's say you also needed that strange format: from datetime import datetime import typer def main ( launch_date : datetime = typer . Argument ( ... , formats = [ \"%Y-%m- %d \" , \"%Y-%m- %d T%H:%M:%S\" , \"%Y-%m- %d %H:%M:%S\" , \"%m/ %d /%Y\" ] ) ): typer . echo ( f \"Launch will be at: { launch_date } \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Notice the last string in formats : \"%m/%d/%Y\" . Check it: // ISO dates work $ python main.py 1969 -10-29 Launch will be at: 1969-10-29 00:00:00 // But the strange custom format also works $ python main.py 10 /29/1969 Launch will be at: 1969-10-29 00:00:00","title":"DateTime"},{"location":"tutorial/parameter-types/datetime/#custom-date-format","text":"You can also customize the formats received for the datetime with the formats parameter. formats receives a list of strings with the date formats that would be passed to datetime.strptime() . For example, let's imagine that you want to accept an ISO formatted datetime, but for some strange reason, you also want to accept a format with: first the month then the day then the year separated with \" / \" ...It's a crazy example, but let's say you also needed that strange format: from datetime import datetime import typer def main ( launch_date : datetime = typer . Argument ( ... , formats = [ \"%Y-%m- %d \" , \"%Y-%m- %d T%H:%M:%S\" , \"%Y-%m- %d %H:%M:%S\" , \"%m/ %d /%Y\" ] ) ): typer . echo ( f \"Launch will be at: { launch_date } \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Notice the last string in formats : \"%m/%d/%Y\" . Check it: // ISO dates work $ python main.py 1969 -10-29 Launch will be at: 1969-10-29 00:00:00 // But the strange custom format also works $ python main.py 10 /29/1969 Launch will be at: 1969-10-29 00:00:00","title":"Custom date format"},{"location":"tutorial/parameter-types/enum/","text":"To define a CLI parameter that can take a value from a predefined set of values you can use a standard Python enum.Enum : from enum import Enum import typer class NeuralNetwork ( str , Enum ): simple = \"simple\" conv = \"conv\" lstm = \"lstm\" def main ( network : NeuralNetwork = NeuralNetwork . simple ): typer . echo ( f \"Training neural network of type: { network . value } \" ) if __name__ == \"__main__\" : typer . run ( main ) Tip Notice that the function parameter network will be an Enum , not a str . To get the str value in your function's code use network.value . Check it: $ python main.py --help // Notice the predefined values [simple|conv|lstm] Usage: main.py [OPTIONS] Options: --network [simple|conv|lstm] [default: simple] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Try it $ python main.py --network conv Training neural network of type: conv // Invalid value $ python main.py --network capsule Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: Invalid value for '--network': invalid choice: capsule. (choose from simple, conv, lstm) Case insensitive Enum choices \u00b6 You can make an Enum (choice) CLI parameter be case-insensitive with the case_sensitive parameter: from enum import Enum import typer class NeuralNetwork ( str , Enum ): simple = \"simple\" conv = \"conv\" lstm = \"lstm\" def main ( network : NeuralNetwork = typer . Option ( NeuralNetwork . simple , case_sensitive = False ) ): typer . echo ( f \"Training neural network of type: { network . value } \" ) if __name__ == \"__main__\" : typer . run ( main ) And then the values of the Enum will be checked no matter if lower case, upper case, or a mix: // Notice the upper case CONV $ python main.py --network CONV Training neural network of type: conv // A mix also works $ python main.py --network LsTm Training neural network of type: lstm","title":"Enum - Choices"},{"location":"tutorial/parameter-types/enum/#case-insensitive-enum-choices","text":"You can make an Enum (choice) CLI parameter be case-insensitive with the case_sensitive parameter: from enum import Enum import typer class NeuralNetwork ( str , Enum ): simple = \"simple\" conv = \"conv\" lstm = \"lstm\" def main ( network : NeuralNetwork = typer . Option ( NeuralNetwork . simple , case_sensitive = False ) ): typer . echo ( f \"Training neural network of type: { network . value } \" ) if __name__ == \"__main__\" : typer . run ( main ) And then the values of the Enum will be checked no matter if lower case, upper case, or a mix: // Notice the upper case CONV $ python main.py --network CONV Training neural network of type: conv // A mix also works $ python main.py --network LsTm Training neural network of type: lstm","title":"Case insensitive Enum choices"},{"location":"tutorial/parameter-types/file/","text":"Apart from Path CLI parameters you can also declare some types of \"files\". Tip In most of the cases you are probably fine just using Path . You can read and write data with Path the same way. The difference is that these types will give you a Python file-like object instead of a Python Path . A \"file-like object\" is the same type of object returned by open() as in: with open ( 'file.txt' ) as f : # Here f is the file-like object read_data = f . read () print ( read_data ) But in some special use cases you might want to use these special types. For example if you are migrating an existing application. FileText reading \u00b6 typer.FileText gives you a file-like object for reading text, you will get str data from it. This means that even if your file has text written in a non-english language, e.g. a text.txt file with: la cig\u00fce\u00f1a trae al ni\u00f1o You will have a str with the text inside, e.g.: content = \"la cig\u00fce\u00f1a trae al ni\u00f1o\" instead of having bytes , e.g.: content = b \"la cig \\xc3\\xbc e \\xc3\\xb1 a trae al ni \\xc3\\xb1 o\" You will get all the correct editor support, attributes, methods, etc for the file-like object: import typer def main ( config : typer . FileText = typer . Option ( ... )): for line in config : typer . echo ( f \"Config line: { line } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Create a quick text config $ echo \"some settings\" > config.txt // Add another line to the config to test it $ echo \"some more settings\" >> config.txt // Now run your program $ python main.py --config config.txt Config line: some settings Config line: some more settings FileTextWrite \u00b6 For writing text, you can use typer.FileTextWrite : import typer def main ( config : typer . FileTextWrite = typer . Option ( ... )): config . write ( \"Some config written by the app\" ) typer . echo ( \"Config written\" ) if __name__ == \"__main__\" : typer . run ( main ) This would be for writing human text, like: some settings la cig\u00fce\u00f1a trae al ni\u00f1o ...not to write binary bytes . Check it: $ python main.py --config text.txt Config written // Check the contents of the file $ cat text.txt Some config written by the app Technical Details typer.FileTextWrite is a just a convenience class. It's the same as using typer.FileText and setting mode=\"w\" . You will learn about mode later below. FileBinaryRead \u00b6 To read binary data you can use typer.FileBinaryRead . You will receive bytes from it. It's useful for reading binary files like images: import typer def main ( file : typer . FileBinaryRead = typer . Option ( ... )): processed_total = 0 for bytes_chunk in file : # Process the bytes in bytes_chunk processed_total += len ( bytes_chunk ) typer . echo ( f \"Processed bytes total: { processed_total } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --file lena.jpg Processed bytes total: 512 Processed bytes total: 1024 Processed bytes total: 1536 Processed bytes total: 2048 FileBinaryWrite \u00b6 To write binary data you can use typer.FileBinaryWrite . You would write bytes to it. It's useful for writing binary files like images. Have in mind that you have to pass bytes to its .write() method, not str . If you have a str , you have to encode it first to get bytes . import typer def main ( file : typer . FileBinaryWrite = typer . Option ( ... )): first_line_str = \"some settings \\n \" # You cannot write str directly to a binary file, you have to encode it to get bytes first_line_bytes = first_line_str . encode ( \"utf-8\" ) # Then you can write the bytes file . write ( first_line_bytes ) # This is already bytes, it starts with b\" second_line = b \"la cig \\xc3\\xbc e \\xc3\\xb1 a trae al ni \\xc3\\xb1 o\" file . write ( second_line ) typer . echo ( \"Binary file written\" ) if __name__ == \"__main__\" : typer . run ( main ) $ python main.py --file binary.dat Binary file written // Check the binary file was created $ ls ./binary.dat ./binary.dat File CLI parameter configurations \u00b6 You can use several configuration parameters for these types (classes) in typer.Option() and typer.Argument() : mode : controls the \" mode \" to open the file with. It's automatically set for you by using the classes above. Read more about it below. encoding : to force a specific encoding, e.g. \"utf-8\" . lazy : delay I/O operations. Automatic by default. By default, when writing files, Click will generate a file-like object that is not yet the actual file. Once you start writing, it will go, open the file and start writing to it, but not before. This is mainly useful to avoid creating the file until you start writing to it. It's normally safe to leave this automatic. But you can overwrite it setting lazy=False . By default, it's lazy=True for writing and lazy=False for reading. atomic : if true, all writes will actually go to a temporal file and then moved to the final destination after completing. This is useful with files modified frequently by several users/programs. Advanced mode \u00b6 By default, Typer will configure the mode for you: typer.FileText : mode=\"r\" , to read text. typer.FileTextWrite : mode=\"w\" , to write text. typer.FileBinaryRead : mode=\"rb\" , to read binary data. typer.FileBinaryWrite : mode=\"wb\" , to write binary data. Note about FileTextWrite \u00b6 typer.FileTextWrite is actually just a convenience class. It's the same as using typer.FileText with mode=\"w\" . But it's probably shorter and more intuitive as you can get it with autocompletion in your editor by just starting to type typer.File ... just like the other classes. Customize mode \u00b6 You can override the mode from the defaults above. For example, you could use mode=\"a\" to write \"appending\" to the same file: import typer def main ( config : typer . FileText = typer . Option ( ... , mode = \"a\" )): config . write ( \"This is a single line \\n \" ) typer . echo ( \"Config line written\" ) if __name__ == \"__main__\" : typer . run ( main ) Tip As you are manually setting mode=\"a\" , you can use typer.FileText or typer.FileTextWrite , both will work. Check it: $ python main.py --config config.txt Config line written // Run your program a couple more times to see how it appends instead of overwriting $ python main.py --config config.txt Config line written $ python main.py --config config.txt Config line written // Check the contents of the file, it should have each of the 3 lines appended $ cat config.txt This is a single line This is a single line This is a single line About the different types \u00b6 Info These are technical details about why the different types/classes provided by Typer . But you don't need this information to be able to use them. You can skip it. Typer provides you these different types (classes) because they inherit directly from the actual Python implementation that will be provided underneath for each case. This way your editor will give you the right type checks and completion for each type. Even if you use lazy . When you use lazy Click creates a especial object to delay writes, and serves as a \"proxy\" to the actual file that will be written. But this especial proxy object doesn't expose the attributes and methods needed for type checks and completion in the editor. If you access those attributes or call the methods, the \"proxy\" lazy object will call them in the final object and it will all work. But you wouldn't get autocompletion for them. But because these Typer classes inherit from the actual implementation that will be provided underneath (not the lazy object), you will get all the autocompletion and type checks in the editor.","title":"File"},{"location":"tutorial/parameter-types/file/#filetext-reading","text":"typer.FileText gives you a file-like object for reading text, you will get str data from it. This means that even if your file has text written in a non-english language, e.g. a text.txt file with: la cig\u00fce\u00f1a trae al ni\u00f1o You will have a str with the text inside, e.g.: content = \"la cig\u00fce\u00f1a trae al ni\u00f1o\" instead of having bytes , e.g.: content = b \"la cig \\xc3\\xbc e \\xc3\\xb1 a trae al ni \\xc3\\xb1 o\" You will get all the correct editor support, attributes, methods, etc for the file-like object: import typer def main ( config : typer . FileText = typer . Option ( ... )): for line in config : typer . echo ( f \"Config line: { line } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: // Create a quick text config $ echo \"some settings\" > config.txt // Add another line to the config to test it $ echo \"some more settings\" >> config.txt // Now run your program $ python main.py --config config.txt Config line: some settings Config line: some more settings","title":"FileText reading"},{"location":"tutorial/parameter-types/file/#filetextwrite","text":"For writing text, you can use typer.FileTextWrite : import typer def main ( config : typer . FileTextWrite = typer . Option ( ... )): config . write ( \"Some config written by the app\" ) typer . echo ( \"Config written\" ) if __name__ == \"__main__\" : typer . run ( main ) This would be for writing human text, like: some settings la cig\u00fce\u00f1a trae al ni\u00f1o ...not to write binary bytes . Check it: $ python main.py --config text.txt Config written // Check the contents of the file $ cat text.txt Some config written by the app Technical Details typer.FileTextWrite is a just a convenience class. It's the same as using typer.FileText and setting mode=\"w\" . You will learn about mode later below.","title":"FileTextWrite"},{"location":"tutorial/parameter-types/file/#filebinaryread","text":"To read binary data you can use typer.FileBinaryRead . You will receive bytes from it. It's useful for reading binary files like images: import typer def main ( file : typer . FileBinaryRead = typer . Option ( ... )): processed_total = 0 for bytes_chunk in file : # Process the bytes in bytes_chunk processed_total += len ( bytes_chunk ) typer . echo ( f \"Processed bytes total: { processed_total } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --file lena.jpg Processed bytes total: 512 Processed bytes total: 1024 Processed bytes total: 1536 Processed bytes total: 2048","title":"FileBinaryRead"},{"location":"tutorial/parameter-types/file/#filebinarywrite","text":"To write binary data you can use typer.FileBinaryWrite . You would write bytes to it. It's useful for writing binary files like images. Have in mind that you have to pass bytes to its .write() method, not str . If you have a str , you have to encode it first to get bytes . import typer def main ( file : typer . FileBinaryWrite = typer . Option ( ... )): first_line_str = \"some settings \\n \" # You cannot write str directly to a binary file, you have to encode it to get bytes first_line_bytes = first_line_str . encode ( \"utf-8\" ) # Then you can write the bytes file . write ( first_line_bytes ) # This is already bytes, it starts with b\" second_line = b \"la cig \\xc3\\xbc e \\xc3\\xb1 a trae al ni \\xc3\\xb1 o\" file . write ( second_line ) typer . echo ( \"Binary file written\" ) if __name__ == \"__main__\" : typer . run ( main ) $ python main.py --file binary.dat Binary file written // Check the binary file was created $ ls ./binary.dat ./binary.dat","title":"FileBinaryWrite"},{"location":"tutorial/parameter-types/file/#file-cli-parameter-configurations","text":"You can use several configuration parameters for these types (classes) in typer.Option() and typer.Argument() : mode : controls the \" mode \" to open the file with. It's automatically set for you by using the classes above. Read more about it below. encoding : to force a specific encoding, e.g. \"utf-8\" . lazy : delay I/O operations. Automatic by default. By default, when writing files, Click will generate a file-like object that is not yet the actual file. Once you start writing, it will go, open the file and start writing to it, but not before. This is mainly useful to avoid creating the file until you start writing to it. It's normally safe to leave this automatic. But you can overwrite it setting lazy=False . By default, it's lazy=True for writing and lazy=False for reading. atomic : if true, all writes will actually go to a temporal file and then moved to the final destination after completing. This is useful with files modified frequently by several users/programs.","title":"File CLI parameter configurations"},{"location":"tutorial/parameter-types/file/#advanced-mode","text":"By default, Typer will configure the mode for you: typer.FileText : mode=\"r\" , to read text. typer.FileTextWrite : mode=\"w\" , to write text. typer.FileBinaryRead : mode=\"rb\" , to read binary data. typer.FileBinaryWrite : mode=\"wb\" , to write binary data.","title":"Advanced mode"},{"location":"tutorial/parameter-types/file/#note-about-filetextwrite","text":"typer.FileTextWrite is actually just a convenience class. It's the same as using typer.FileText with mode=\"w\" . But it's probably shorter and more intuitive as you can get it with autocompletion in your editor by just starting to type typer.File ... just like the other classes.","title":"Note about FileTextWrite"},{"location":"tutorial/parameter-types/file/#customize-mode","text":"You can override the mode from the defaults above. For example, you could use mode=\"a\" to write \"appending\" to the same file: import typer def main ( config : typer . FileText = typer . Option ( ... , mode = \"a\" )): config . write ( \"This is a single line \\n \" ) typer . echo ( \"Config line written\" ) if __name__ == \"__main__\" : typer . run ( main ) Tip As you are manually setting mode=\"a\" , you can use typer.FileText or typer.FileTextWrite , both will work. Check it: $ python main.py --config config.txt Config line written // Run your program a couple more times to see how it appends instead of overwriting $ python main.py --config config.txt Config line written $ python main.py --config config.txt Config line written // Check the contents of the file, it should have each of the 3 lines appended $ cat config.txt This is a single line This is a single line This is a single line","title":"Customize mode"},{"location":"tutorial/parameter-types/file/#about-the-different-types","text":"Info These are technical details about why the different types/classes provided by Typer . But you don't need this information to be able to use them. You can skip it. Typer provides you these different types (classes) because they inherit directly from the actual Python implementation that will be provided underneath for each case. This way your editor will give you the right type checks and completion for each type. Even if you use lazy . When you use lazy Click creates a especial object to delay writes, and serves as a \"proxy\" to the actual file that will be written. But this especial proxy object doesn't expose the attributes and methods needed for type checks and completion in the editor. If you access those attributes or call the methods, the \"proxy\" lazy object will call them in the final object and it will all work. But you wouldn't get autocompletion for them. But because these Typer classes inherit from the actual implementation that will be provided underneath (not the lazy object), you will get all the autocompletion and type checks in the editor.","title":"About the different types"},{"location":"tutorial/parameter-types/number/","text":"You can define numeric validations with max and min values for int and float CLI parameters : import typer def main ( id : int = typer . Argument ( ... , min = 0 , max = 1000 ), age : int = typer . Option ( 20 , min = 18 ), score : float = typer . Option ( 0 , max = 100 ), ): typer . echo ( f \"ID is { id } \" ) typer . echo ( f \"--age is { age } \" ) typer . echo ( f \"--score is { score } \" ) if __name__ == \"__main__\" : typer . run ( main ) CLI arguments and CLI options can both use these validations. You can specify min , max or both. Check it: $ python main.py --help // Notice the extra RANGE in the help text for --age and --score Usage: main.py [OPTIONS] ID Arguments: ID [required] Options: --age INTEGER RANGE [default: 20] --score FLOAT RANGE [default: 0] --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. // Pass all the CLI parameters $ python main.py 5 --age 20 --score 90 ID is 5 --age is 20 --score is 90.0 // Pass an invalid ID $ python main.py 1002 Usage: main.py [OPTIONS] ID Try \"main.py --help\" for help. Error: Invalid value for 'ID': 1002 is not in the valid range of 0 to 1000. // Pass an invalid age $ python main.py 5 --age 15 Usage: main.py [OPTIONS] ID Try \"main.py --help\" for help. Error: Invalid value for '--age': 15 is smaller than the minimum valid value 18. // Pass an invalid score $ python main.py 5 --age 20 --score 100 .5 Usage: main.py [OPTIONS] ID Try \"main.py --help\" for help. Error: Invalid value for '--score': 100.5 is bigger than the maximum valid value 100. // But as we didn't specify a minimum score, this is accepted $ python main.py 5 --age 20 --score -5 ID is 5 --age is 20 --score is -5.0 Clamping numbers \u00b6 You might want to, instead of showing an error, use the closest minimum or maximum valid values. You can do it with the clamp parameter: import typer def main ( id : int = typer . Argument ( ... , min = 0 , max = 1000 ), rank : int = typer . Option ( 0 , max = 10 , clamp = True ), score : float = typer . Option ( 0 , min = 0 , max = 100 , clamp = True ), ): typer . echo ( f \"ID is { id } \" ) typer . echo ( f \"--rank is { rank } \" ) typer . echo ( f \"--score is { score } \" ) if __name__ == \"__main__\" : typer . run ( main ) And then, when you pass data that is out of the valid range, it will be \"clamped\", the closest valid value will be used: // ID doesn't have clamp, so it shows an error $ python main.py 1002 Usage: main.py [OPTIONS] ID Try \"main.py --help\" for help. Error: Invalid value for 'ID': 1002 is not in the valid range of 0 to 1000. // But --rank and --score use clamp $ python main.py 5 --rank 11 --score -5 ID is 5 --rank is 10 --score is 0 Counter CLI options \u00b6 You can make a CLI option work as a counter with the counter parameter: import typer def main ( verbose : int = typer . Option ( 0 , \"--verbose\" , \"-v\" , count = True )): typer . echo ( f \"Verbose level is { verbose } \" ) if __name__ == \"__main__\" : typer . run ( main ) It means that the CLI option will be like a boolean flag, e.g. --verbose . And the value you receive in the function will be the amount of times that --verbose was added: // Check it $ python main.py Verbose level is 0 // Now use one --verbose $ python main.py --verbose Verbose level is 1 // Now 3 --verbose $ python main.py --verbose --verbose --verbose Verbose level is 3 // And with the short name $ python main.py -v Verbose level is 1 // And with the short name 3 times $ python main.py -v -v -v Verbose level is 3 // As short names can be put together, this also works $ python main.py -vvv Verbose level is 3","title":"Number"},{"location":"tutorial/parameter-types/number/#clamping-numbers","text":"You might want to, instead of showing an error, use the closest minimum or maximum valid values. You can do it with the clamp parameter: import typer def main ( id : int = typer . Argument ( ... , min = 0 , max = 1000 ), rank : int = typer . Option ( 0 , max = 10 , clamp = True ), score : float = typer . Option ( 0 , min = 0 , max = 100 , clamp = True ), ): typer . echo ( f \"ID is { id } \" ) typer . echo ( f \"--rank is { rank } \" ) typer . echo ( f \"--score is { score } \" ) if __name__ == \"__main__\" : typer . run ( main ) And then, when you pass data that is out of the valid range, it will be \"clamped\", the closest valid value will be used: // ID doesn't have clamp, so it shows an error $ python main.py 1002 Usage: main.py [OPTIONS] ID Try \"main.py --help\" for help. Error: Invalid value for 'ID': 1002 is not in the valid range of 0 to 1000. // But --rank and --score use clamp $ python main.py 5 --rank 11 --score -5 ID is 5 --rank is 10 --score is 0","title":"Clamping numbers"},{"location":"tutorial/parameter-types/number/#counter-cli-options","text":"You can make a CLI option work as a counter with the counter parameter: import typer def main ( verbose : int = typer . Option ( 0 , \"--verbose\" , \"-v\" , count = True )): typer . echo ( f \"Verbose level is { verbose } \" ) if __name__ == \"__main__\" : typer . run ( main ) It means that the CLI option will be like a boolean flag, e.g. --verbose . And the value you receive in the function will be the amount of times that --verbose was added: // Check it $ python main.py Verbose level is 0 // Now use one --verbose $ python main.py --verbose Verbose level is 1 // Now 3 --verbose $ python main.py --verbose --verbose --verbose Verbose level is 3 // And with the short name $ python main.py -v Verbose level is 1 // And with the short name 3 times $ python main.py -v -v -v Verbose level is 3 // As short names can be put together, this also works $ python main.py -vvv Verbose level is 3","title":"Counter CLI options"},{"location":"tutorial/parameter-types/path/","text":"You can declare a CLI parameter to be a standard Python pathlib.Path . This is what you would do for directory paths, file paths, etc: from pathlib import Path from typing import Optional import typer def main ( config : Optional [ Path ] = typer . Option ( None )): if config is None : typer . echo ( \"No config file\" ) raise typer . Abort () if config . is_file (): text = config . read_text () typer . echo ( f \"Config file contents: { text } \" ) elif config . is_dir (): typer . echo ( \"Config is a directory, will use all its config files\" ) elif not config . exists (): typer . echo ( \"The config doesn't exist\" ) if __name__ == \"__main__\" : typer . run ( main ) And again, as you receive a standard Python Path object the same as the type annotation, your editor will give you autocompletion for all its attributes and methods. Check it: // No config $ python main.py No config file Aborted! // Pass a config that doesn't exist $ python main.py --config config.txt The config doesn't exist // Now create a quick config $ echo \"some settings\" > config.txt // And try again $ python main.py --config config.txt Config file contents: some settings // And with a directory $ python main.py --config ./ Config is a directory, will use all its config files Path validations \u00b6 You can perform several validations for Path CLI parameters : exists : if set to true, the file or directory needs to exist for this value to be valid. If this is not required and a file does indeed not exist, then all further checks are silently skipped. file_okay : controls if a file is a possible value. dir_okay : controls if a directory is a possible value. writable : if true, a writable check is performed. readable : if true, a readable check is performed. resolve_path : if this is true, then the path is fully resolved before the value is passed onwards. This means that it\u2019s absolute and symlinks are resolved. Technical Details It will not expand a tilde-prefix (something with ~ , like ~/Documents/ ), as this is supposed to be done by the shell only. Tip All these parameters come directly from Click . For example: from pathlib import Path import typer def main ( config : Path = typer . Option ( ... , exists = True , file_okay = True , dir_okay = False , writable = False , readable = True , resolve_path = True , ) ): text = config . read_text () typer . echo ( f \"Config file contents: { text } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --config config.txt Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: Invalid value for '--config': File 'config.txt' does not exist. // Now create a quick config $ echo \"some settings\" > config.txt // And try again $ python main.py --config config.txt Config file contents: some settings // And with a directory $ python main.py --config ./ Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: Invalid value for '--config': File './' is a directory. Advanced Path configurations \u00b6 Advanced Details You probably won't need these configurations at first, you may want to skip it. They are used for more advanced use cases. allow_dash : If this is set to True, a single dash to indicate standard streams is permitted. path_type : optionally a string type that should be used to represent the path. The default is None which means the return value will be either bytes or unicode depending on what makes most sense given the input data Click deals with.","title":"Path"},{"location":"tutorial/parameter-types/path/#path-validations","text":"You can perform several validations for Path CLI parameters : exists : if set to true, the file or directory needs to exist for this value to be valid. If this is not required and a file does indeed not exist, then all further checks are silently skipped. file_okay : controls if a file is a possible value. dir_okay : controls if a directory is a possible value. writable : if true, a writable check is performed. readable : if true, a readable check is performed. resolve_path : if this is true, then the path is fully resolved before the value is passed onwards. This means that it\u2019s absolute and symlinks are resolved. Technical Details It will not expand a tilde-prefix (something with ~ , like ~/Documents/ ), as this is supposed to be done by the shell only. Tip All these parameters come directly from Click . For example: from pathlib import Path import typer def main ( config : Path = typer . Option ( ... , exists = True , file_okay = True , dir_okay = False , writable = False , readable = True , resolve_path = True , ) ): text = config . read_text () typer . echo ( f \"Config file contents: { text } \" ) if __name__ == \"__main__\" : typer . run ( main ) Check it: $ python main.py --config config.txt Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: Invalid value for '--config': File 'config.txt' does not exist. // Now create a quick config $ echo \"some settings\" > config.txt // And try again $ python main.py --config config.txt Config file contents: some settings // And with a directory $ python main.py --config ./ Usage: main.py [OPTIONS] Try \"main.py --help\" for help. Error: Invalid value for '--config': File './' is a directory.","title":"Path validations"},{"location":"tutorial/parameter-types/path/#advanced-path-configurations","text":"Advanced Details You probably won't need these configurations at first, you may want to skip it. They are used for more advanced use cases. allow_dash : If this is set to True, a single dash to indicate standard streams is permitted. path_type : optionally a string type that should be used to represent the path. The default is None which means the return value will be either bytes or unicode depending on what makes most sense given the input data Click deals with.","title":"Advanced Path configurations"},{"location":"tutorial/parameter-types/uuid/","text":"Info A UUID is a \"Universally Unique Identifier\" . It's a standard format for identifiers, like passport numbers, but for anything, not just people in countries. They look like this: d48edaa6-871a-4082-a196-4daab372d4a1 The way they are generated makes them sufficiently long and random that you could assume that every UUID generated is unique. Even if it was generated by a different application, database, or system. So, if your system uses UUIDs to identify your data, you could mix it with the data from some other system that also uses UUIDs with some confidence that their IDs (UUIDs) won't clash with yours. This wouldn't be true if you just used int s as identifiers, as most databases do. You can declare a CLI parameter as a UUID: from uuid import UUID import typer def main ( user_id : UUID ): typer . echo ( f \"USER_ID is { user_id } \" ) typer . echo ( f \"UUID version is: { user_id . version } \" ) if __name__ == \"__main__\" : typer . run ( main ) Your Python code will receive a standard Python UUID object with all its attributes and methods, and as you are annotating your function parameter with that type, you will have type checks, autocompletion in your editor, etc. Check it: // Pass a valid UUID v4 $ python main.py d48edaa6-871a-4082-a196-4daab372d4a1 USER_ID is d48edaa6-871a-4082-a196-4daab372d4a1 UUID version is: 4 // An invalid value $ python main.py 7479706572 -72756c6573 Usage: main.py [OPTIONS] USER_ID Try \"main.py --help\" for help. Error: Invalid value for 'USER_ID': 7479706572-72756c6573 is not a valid UUID value","title":"UUID"},{"location":"tutorial/subcommands/","text":"You read before how to create a program with Commands . Now we'll see how to create a CLI program with commands that have their own subcommands. Also known as command groups. For example, the CLI program git has a command remote . But git remote , in turn, has its own subcommands, like add : // git remote alone shows the current remote repositories $ git remote origin // Use -v to make it verbose and show more info $ git remote -v origin git@github.com:yourusername/typer.git (fetch) origin git@github.com:yourusername/typer.git (push) // git remote add takes 2 CLI arguments, a name and URL $ git remote add upstream https://github.com/tiangolo/typer.git // Doesn't output anything, but now you have another remote repository called upstream // Now check again $ git remote -v origin git@github.com:yourusername/typer.git (fetch) origin git@github.com:yourusername/typer.git (push) upstream https://github.com/tiangolo/typer.git (fetch) upstream https://github.com/tiangolo/typer.git (push) In the next sections we'll see how to create subcommands like these.","title":"SubCommands - Command Groups - Intro"},{"location":"tutorial/subcommands/add-typer/","text":"We'll start with the core idea. To add a typer.Typer() app inside of another. Manage items \u00b6 Let's imagine that you are creating a CLI program to manage items in some distant land. It could be in an items.py file with this: import typer app = typer . Typer () @app . command () def create ( item : str ): typer . echo ( f \"Creating item: { item } \" ) @app . command () def delete ( item : str ): typer . echo ( f \"Deleting item: { item } \" ) @app . command () def sell ( item : str ): typer . echo ( f \"Selling item: { item } \" ) if __name__ == \"__main__\" : app () And you would use it like: $ python items.py create Wand Creating item: Wand Manage users \u00b6 But then you realize that you also have to manage users from your CLI app . It could be a file users.py with something like: import typer app = typer . Typer () @app . command () def create ( user_name : str ): typer . echo ( f \"Creating user: { user_name } \" ) @app . command () def delete ( user_name : str ): typer . echo ( f \"Deleting user: { user_name } \" ) if __name__ == \"__main__\" : app () And you would use it like: $ python users.py create Camila Creating user: Camila Put them together \u00b6 Both parts are similar. In fact, items.py and users.py both have commands create and delete . But we need them to be part of the same CLI program . In this case, as with git remote , we can put them together as subcommands in another typer.Typer() CLI program . Now create a main.py with: import typer import items import users app = typer . Typer () app . add_typer ( users . app , name = \"users\" ) app . add_typer ( items . app , name = \"items\" ) if __name__ == \"__main__\" : app () Here's what we do in main.py : Import the other Python modules (the files users.py and items.py ). Create the main typer.Typer() application. Use app.add_typer() to include the app from items.py and users.py , each of those 2 was also created with typer.Typer() . Define a name with the command that will be used for each of these \"sub-Typers\" to group their own commands. And now your CLI program has 2 commands: users : with all of the commands (subcommands) in the app from users.py . items with all the commands (subcommands) in the app from items.py . Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: items users Now you have a CLI program with commands items and users , and they in turn have their own commands (subcommands). Let's check the items command: // Check the help for items $ python main.py items --help // It shows its own commands (subcommands): create, delete, sell Usage: main.py items [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete sell // Try it $ python main.py items create Wand Creating item: Wand $ python main.py items sell Vase Selling item: Vase Tip Notice that we are still calling $ python main.py but now we are using the command items . And now check the command users , with all its subcommands: $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete // Try it $ python main.py users create Camila Creating user: Camila Recap \u00b6 That's the core idea. You can just create typer.Typer() apps and add them inside one another. And you can do that with any levels of commands that you want. Do you need sub-sub-sub-subcommands? Go ahead, create all the typer.Typer() s you need and put them together with app.add_typer() . In the next sections we'll update this with more features, but you already have the core idea. This way, in the same spirit of Click, Typer applications are composable, each typer.Typer() can be a CLI app by itself, but it can also be added as a command group to another Typer app.","title":"Add Typer"},{"location":"tutorial/subcommands/add-typer/#manage-items","text":"Let's imagine that you are creating a CLI program to manage items in some distant land. It could be in an items.py file with this: import typer app = typer . Typer () @app . command () def create ( item : str ): typer . echo ( f \"Creating item: { item } \" ) @app . command () def delete ( item : str ): typer . echo ( f \"Deleting item: { item } \" ) @app . command () def sell ( item : str ): typer . echo ( f \"Selling item: { item } \" ) if __name__ == \"__main__\" : app () And you would use it like: $ python items.py create Wand Creating item: Wand","title":"Manage items"},{"location":"tutorial/subcommands/add-typer/#manage-users","text":"But then you realize that you also have to manage users from your CLI app . It could be a file users.py with something like: import typer app = typer . Typer () @app . command () def create ( user_name : str ): typer . echo ( f \"Creating user: { user_name } \" ) @app . command () def delete ( user_name : str ): typer . echo ( f \"Deleting user: { user_name } \" ) if __name__ == \"__main__\" : app () And you would use it like: $ python users.py create Camila Creating user: Camila","title":"Manage users"},{"location":"tutorial/subcommands/add-typer/#put-them-together","text":"Both parts are similar. In fact, items.py and users.py both have commands create and delete . But we need them to be part of the same CLI program . In this case, as with git remote , we can put them together as subcommands in another typer.Typer() CLI program . Now create a main.py with: import typer import items import users app = typer . Typer () app . add_typer ( users . app , name = \"users\" ) app . add_typer ( items . app , name = \"items\" ) if __name__ == \"__main__\" : app () Here's what we do in main.py : Import the other Python modules (the files users.py and items.py ). Create the main typer.Typer() application. Use app.add_typer() to include the app from items.py and users.py , each of those 2 was also created with typer.Typer() . Define a name with the command that will be used for each of these \"sub-Typers\" to group their own commands. And now your CLI program has 2 commands: users : with all of the commands (subcommands) in the app from users.py . items with all the commands (subcommands) in the app from items.py . Check it: // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: items users Now you have a CLI program with commands items and users , and they in turn have their own commands (subcommands). Let's check the items command: // Check the help for items $ python main.py items --help // It shows its own commands (subcommands): create, delete, sell Usage: main.py items [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete sell // Try it $ python main.py items create Wand Creating item: Wand $ python main.py items sell Vase Selling item: Vase Tip Notice that we are still calling $ python main.py but now we are using the command items . And now check the command users , with all its subcommands: $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete // Try it $ python main.py users create Camila Creating user: Camila","title":"Put them together"},{"location":"tutorial/subcommands/add-typer/#recap","text":"That's the core idea. You can just create typer.Typer() apps and add them inside one another. And you can do that with any levels of commands that you want. Do you need sub-sub-sub-subcommands? Go ahead, create all the typer.Typer() s you need and put them together with app.add_typer() . In the next sections we'll update this with more features, but you already have the core idea. This way, in the same spirit of Click, Typer applications are composable, each typer.Typer() can be a CLI app by itself, but it can also be added as a command group to another Typer app.","title":"Recap"},{"location":"tutorial/subcommands/callback-override/","text":"When creating a Typer app you can define a callback function, it always executes and defines the CLI arguments and CLI options that go before a command. When adding a Typer app inside of another, the sub-Typer can also have its own callback. It can handle any CLI parameters that go before its own commands and execute any extra code: import typer app = typer . Typer () users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @users_app . callback () def users_callback (): typer . echo ( \"Running a users command\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () In this case it doesn't define any CLI parameters , it just writes a message. Check it: $ python main.py users create Camila // Notice the first message is not created by the command function but by the callback Running a users command Creating user: Camila Add a callback on creation \u00b6 It's also possible to add a callback when creating the typer.Typer() app that will be added to another Typer app: import typer app = typer . Typer () def users_callback (): typer . echo ( \"Running a users command\" ) users_app = typer . Typer ( callback = users_callback ) app . add_typer ( users_app , name = \"users\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () This achieves exactly the same as above, it's just another place to add the callback. Check it: $ python main.py users create Camila Running a users command Creating user: Camila Overriding the callback on creation \u00b6 If a callback was added when creating the typer.Typer() app, it's possible to override it with a new one using @app.callback() . This is the same information you saw on the section about Commands - Typer Callback , and it applies the same for sub-Typer apps: import typer app = typer . Typer () def default_callback (): typer . echo ( \"Running a users command\" ) users_app = typer . Typer ( callback = default_callback ) app . add_typer ( users_app , name = \"users\" ) @users_app . callback () def user_callback (): typer . echo ( \"Callback override, running users command\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Here we had defined a callback when creating the typer.Typer() sub-app, but then we override it with a new callback with the function user_callback() . As @app.callback() takes precedence over typer.Typer(callback=some_function) , now our CLI app will use this new callback. Check it: $ python main.py users create Camila // Notice the message from the new callback Callback override, running users command Creating user: Camila Overriding the callback when adding a sub-Typer \u00b6 Lastly, you can override the callback defined anywhere else when adding a sub-Typer with app.add_typer() using the callback parameter. This has the highest priority: import typer app = typer . Typer () def default_callback (): typer . echo ( \"Running a users command\" ) users_app = typer . Typer ( callback = default_callback ) def callback_for_add_typer (): typer . echo ( \"I have the high land! Running users command\" ) app . add_typer ( users_app , name = \"users\" , callback = callback_for_add_typer ) @users_app . callback () def user_callback (): typer . echo ( \"Callback override, running users command\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Notice that the precedence goes to app.add_typer() and is not affected by the order of execution. There's another callback defined below, but the one from app.add_typer() wins. Now when you use the CLI program it will use the new callback function callback_for_add_typer() . Check it: $ python users create Camila // Notice the message from the callback added in add_typer() I have the high land! Running users command Creating user: Camila","title":"Sub-Typer Callback Override"},{"location":"tutorial/subcommands/callback-override/#add-a-callback-on-creation","text":"It's also possible to add a callback when creating the typer.Typer() app that will be added to another Typer app: import typer app = typer . Typer () def users_callback (): typer . echo ( \"Running a users command\" ) users_app = typer . Typer ( callback = users_callback ) app . add_typer ( users_app , name = \"users\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () This achieves exactly the same as above, it's just another place to add the callback. Check it: $ python main.py users create Camila Running a users command Creating user: Camila","title":"Add a callback on creation"},{"location":"tutorial/subcommands/callback-override/#overriding-the-callback-on-creation","text":"If a callback was added when creating the typer.Typer() app, it's possible to override it with a new one using @app.callback() . This is the same information you saw on the section about Commands - Typer Callback , and it applies the same for sub-Typer apps: import typer app = typer . Typer () def default_callback (): typer . echo ( \"Running a users command\" ) users_app = typer . Typer ( callback = default_callback ) app . add_typer ( users_app , name = \"users\" ) @users_app . callback () def user_callback (): typer . echo ( \"Callback override, running users command\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Here we had defined a callback when creating the typer.Typer() sub-app, but then we override it with a new callback with the function user_callback() . As @app.callback() takes precedence over typer.Typer(callback=some_function) , now our CLI app will use this new callback. Check it: $ python main.py users create Camila // Notice the message from the new callback Callback override, running users command Creating user: Camila","title":"Overriding the callback on creation"},{"location":"tutorial/subcommands/callback-override/#overriding-the-callback-when-adding-a-sub-typer","text":"Lastly, you can override the callback defined anywhere else when adding a sub-Typer with app.add_typer() using the callback parameter. This has the highest priority: import typer app = typer . Typer () def default_callback (): typer . echo ( \"Running a users command\" ) users_app = typer . Typer ( callback = default_callback ) def callback_for_add_typer (): typer . echo ( \"I have the high land! Running users command\" ) app . add_typer ( users_app , name = \"users\" , callback = callback_for_add_typer ) @users_app . callback () def user_callback (): typer . echo ( \"Callback override, running users command\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Notice that the precedence goes to app.add_typer() and is not affected by the order of execution. There's another callback defined below, but the one from app.add_typer() wins. Now when you use the CLI program it will use the new callback function callback_for_add_typer() . Check it: $ python users create Camila // Notice the message from the callback added in add_typer() I have the high land! Running users command Creating user: Camila","title":"Overriding the callback when adding a sub-Typer"},{"location":"tutorial/subcommands/name-and-help/","text":"When adding a Typer app to another we have seen how to set the name to use for the command. For example to set the command to users : app . add_typer ( users . app , name = \"users\" ) Add a help text \u00b6 We can also set the help while adding a Typer: import typer app = typer . Typer () users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" , help = \"Manage users in the app.\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () And then we get that help text for that command in the CLI program : // Check the main help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create We can set the name and help in several places, each one taking precedence over the other, overriding the previous value. Let's see those locations. Tip There are other attributes that can be set in that same way in the same places we'll see next. But those are documented later in another section. Inferring name and help from callback \u00b6 Inferring a command's name and help \u00b6 When you create a command with @app.command() , by default, it generates the name from the function name. And by default, the help text is extracted from the function's docstring. For example: @app . command () def create ( item : str ): \"\"\" Create an item. \"\"\" typer . echo ( f \"Creating item: { item } \" ) ...will create a command create with a help text of Create an item . Inferring name and help from @app.callback() \u00b6 The same way, if you define a callback in a typer.Typer() , the help text is extracted from the callback function's docstring. And if that Typer app is added to another Typer app, the default name of the command is generated from the name of the callback function. Here's an example: import typer app = typer . Typer () users_app = typer . Typer () app . add_typer ( users_app ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Notice that now we added the sub-Typer without specifying a name nor a help . They are now inferred from the callback function. The command name will be the same callback function's name: users . And the help text for that users command will be the callback function's docstring: Manage users in the app. . Check it: // Check the main help $ python main.py --help // Notice the command name \"users\" and the help text \"Manage users in the app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: \"Manage users in the app.\" Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create Name and help from callback parameter in typer.Typer() \u00b6 If you pass a callback parameter while creating a typer.Typer(callback=some_function) it will be used to infer the name and help text. This has the lowest priority, we'll see later what has a higher priority and can override it. Check the code: import typer app = typer . Typer () def users (): \"\"\" Manage users in the app. \"\"\" users_app = typer . Typer ( callback = users ) app . add_typer ( users_app ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () This achieves exactly the same as the previous example. Check it: // Check the main help $ python main.py --help // Notice the command name \"users\" and the help text \"Manage users in the app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: \"Manage users in the app.\" Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create Override a callback set in typer.Typer() with @app.callback() \u00b6 The same as with normal Typer apps, if you pass a callback to typer.Typer(callback=some_function) and then override it with @app.callback() , the name and help text will be inferred from the new callback: import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback ) app . add_typer ( users_app ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Now the name of the command will be users instead of old-callback , and the help text will be Manage users in the app. instead of Old callback help. . Check it: // Check the main help $ python main.py --help // Notice the command name \"users\" and the help text \"Manage users in the app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: \"Manage users in the app.\" Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create Infer name and help from callback in app.add_typer() \u00b6 If you override the callback in app.add_typer() when including a sub-app, the name and help will be inferred from this callback function. This takes precedence over inferring the name and help from a callback set in @sub_app.callback() and typer.Typer(callback=sub_app_callback) . Check the code: import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Now the command will be new-users instead of users . And the help text will be I have the highland! Create some users. instead of the previous ones. Check it: // Check the main help $ python main.py --help // Check the command new-users and its help text Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: new-users I have the highland! Create some users. // Now check the help for the new-users command $ python main.py new-users --help // Notice the help text Usage: main.py new-users [OPTIONS] COMMAND [ARGS]... I have the highland! Create some users. Options: --help Show this message and exit. Commands: create Enough inferring \u00b6 So, when inferring a name and help text, the precedence order from lowest priority to highest is: sub_app = typer.Typer(callback=some_function) @sub_app.callback() app.add_typer(sub_app, callback=new_function) That's for inferring the name and help text from functions. But if you set the name and help text explicitly, that has a higher priority than these. Set the name and help \u00b6 Let's now see the places where you can set the command name and help text, from lowest priority to highest. Tip Setting the name and help text explicitly always has a higher precedence than inferring from a callback function. Name and help in typer.Typer() \u00b6 You could have all the callbacks and overrides we defined before, but the name and help text was inferred from the function name and docstring. If you set it explicitly, that takes precedence over inferring. You can set it when creating a new typer.Typer() : import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback , name = \"exp-users\" , help = \"Explicit help.\" ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Info The rest of the callbacks and overrides are there only to show you that they don't affect the name and help text when you set it explicitly. We set an explicit name exp-users , and an explicit help Explicit help. . So that will take precedence now. Check it: // Check the main help $ python main.py --help // Notice the command name is exp-users and the help text is \"Explicit help.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: exp-users Explicit help. // Check the help for the exp-users command $ python main.py exp-users --help // Notice the main help text Usage: main.py exp-users [OPTIONS] COMMAND [ARGS]... Explicit help. Options: --help Show this message and exit. Commands: create Name and help in @app.callback() \u00b6 Any parameter that you use when creating a typer.Typer() app can be overridden in the parameters of @app.callback() . Continuing with the previous example, we now override the values in @user_app.callback() : import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback , name = \"exp-users\" , help = \"Explicit help.\" ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users ) @users_app . callback ( \"call-users\" , help = \"Help from callback for users.\" ) def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () And now the command name will be call-users and the help text will be Help from callback for users. . Check it: // Check the help $ python main.py --help // The command name now is call-users and the help text is \"Help from callback for users.\". Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: call-users Help from callback for users. // Check the call-users command help $ python main.py call-users --help // Notice the main help text Usage: main.py call-users [OPTIONS] COMMAND [ARGS]... Help from callback for users. Options: --help Show this message and exit. Commands: create Name and help in app.add_typer() \u00b6 And finally, with the highest priority, you can override all that by explicitly setting the name and help in app.add_typer() , just like we did on the first example above: import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback , name = \"exp-users\" , help = \"Explicit help.\" ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users , name = \"cake-sith-users\" , help = \"Unlimited powder! Eh, users.\" , ) @users_app . callback ( \"call-users\" , help = \"Help from callback for users.\" ) def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () And now, with the highest priorities of them all, the command name will now be cake-sith-users and the help text will be Unlimited powder! Eh, users. . Check it: // Check the help $ python main.py --help // Notice the command name cake-sith-users and the new help text \"Unlimited powder! Eh, users.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: cake-sith-users Unlimited powder! Eh, users. // And check the help for the command cake-sith-users $ python main.py cake-sith-users --help // Notice the main help text Usage: main.py cake-sith-users [OPTIONS] COMMAND [ARGS]... Unlimited powder! Eh, users. Options: --help Show this message and exit. Commands: create Recap \u00b6 The precedence to generate a command's name and help, from lowest priority to highest, is: Implicitly inferred from sub_app = typer.Typer(callback=some_function) Implicitly inferred from the callback function under @sub_app.callback() Implicitly inferred from app.add_typer(sub_app, callback=some_function) Explicitly set on sub_app = typer.Typer(name=\"some-name\", help=\"Some help.\") Explicitly set on @sub_app.callback(\"some-name\", help=\"Some help.\") Explicitly set on app.add_typer(sub_app, name=\"some-name\", help=\"Some help.\") So, app.add_typer(sub_app, name=\"some-name\", help=\"Some help.\") always wins.","title":"SubCommand Name and Help"},{"location":"tutorial/subcommands/name-and-help/#add-a-help-text","text":"We can also set the help while adding a Typer: import typer app = typer . Typer () users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" , help = \"Manage users in the app.\" ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () And then we get that help text for that command in the CLI program : // Check the main help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create We can set the name and help in several places, each one taking precedence over the other, overriding the previous value. Let's see those locations. Tip There are other attributes that can be set in that same way in the same places we'll see next. But those are documented later in another section.","title":"Add a help text"},{"location":"tutorial/subcommands/name-and-help/#inferring-name-and-help-from-callback","text":"","title":"Inferring name and help from callback"},{"location":"tutorial/subcommands/name-and-help/#inferring-a-commands-name-and-help","text":"When you create a command with @app.command() , by default, it generates the name from the function name. And by default, the help text is extracted from the function's docstring. For example: @app . command () def create ( item : str ): \"\"\" Create an item. \"\"\" typer . echo ( f \"Creating item: { item } \" ) ...will create a command create with a help text of Create an item .","title":"Inferring a command's name and help"},{"location":"tutorial/subcommands/name-and-help/#inferring-name-and-help-from-appcallback","text":"The same way, if you define a callback in a typer.Typer() , the help text is extracted from the callback function's docstring. And if that Typer app is added to another Typer app, the default name of the command is generated from the name of the callback function. Here's an example: import typer app = typer . Typer () users_app = typer . Typer () app . add_typer ( users_app ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Notice that now we added the sub-Typer without specifying a name nor a help . They are now inferred from the callback function. The command name will be the same callback function's name: users . And the help text for that users command will be the callback function's docstring: Manage users in the app. . Check it: // Check the main help $ python main.py --help // Notice the command name \"users\" and the help text \"Manage users in the app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: \"Manage users in the app.\" Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create","title":"Inferring name and help from @app.callback()"},{"location":"tutorial/subcommands/name-and-help/#name-and-help-from-callback-parameter-in-typertyper","text":"If you pass a callback parameter while creating a typer.Typer(callback=some_function) it will be used to infer the name and help text. This has the lowest priority, we'll see later what has a higher priority and can override it. Check the code: import typer app = typer . Typer () def users (): \"\"\" Manage users in the app. \"\"\" users_app = typer . Typer ( callback = users ) app . add_typer ( users_app ) @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () This achieves exactly the same as the previous example. Check it: // Check the main help $ python main.py --help // Notice the command name \"users\" and the help text \"Manage users in the app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: \"Manage users in the app.\" Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create","title":"Name and help from callback parameter in typer.Typer()"},{"location":"tutorial/subcommands/name-and-help/#override-a-callback-set-in-typertyper-with-appcallback","text":"The same as with normal Typer apps, if you pass a callback to typer.Typer(callback=some_function) and then override it with @app.callback() , the name and help text will be inferred from the new callback: import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback ) app . add_typer ( users_app ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Now the name of the command will be users instead of old-callback , and the help text will be Manage users in the app. instead of Old callback help. . Check it: // Check the main help $ python main.py --help // Notice the command name \"users\" and the help text \"Manage users in the app.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: users Manage users in the app. // Check the help for the users command $ python main.py users --help // Notice the main description: \"Manage users in the app.\" Usage: main.py users [OPTIONS] COMMAND [ARGS]... Manage users in the app. Options: --help Show this message and exit. Commands: create","title":"Override a callback set in typer.Typer() with @app.callback()"},{"location":"tutorial/subcommands/name-and-help/#infer-name-and-help-from-callback-in-appadd_typer","text":"If you override the callback in app.add_typer() when including a sub-app, the name and help will be inferred from this callback function. This takes precedence over inferring the name and help from a callback set in @sub_app.callback() and typer.Typer(callback=sub_app_callback) . Check the code: import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Now the command will be new-users instead of users . And the help text will be I have the highland! Create some users. instead of the previous ones. Check it: // Check the main help $ python main.py --help // Check the command new-users and its help text Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: new-users I have the highland! Create some users. // Now check the help for the new-users command $ python main.py new-users --help // Notice the help text Usage: main.py new-users [OPTIONS] COMMAND [ARGS]... I have the highland! Create some users. Options: --help Show this message and exit. Commands: create","title":"Infer name and help from callback in app.add_typer()"},{"location":"tutorial/subcommands/name-and-help/#enough-inferring","text":"So, when inferring a name and help text, the precedence order from lowest priority to highest is: sub_app = typer.Typer(callback=some_function) @sub_app.callback() app.add_typer(sub_app, callback=new_function) That's for inferring the name and help text from functions. But if you set the name and help text explicitly, that has a higher priority than these.","title":"Enough inferring"},{"location":"tutorial/subcommands/name-and-help/#set-the-name-and-help","text":"Let's now see the places where you can set the command name and help text, from lowest priority to highest. Tip Setting the name and help text explicitly always has a higher precedence than inferring from a callback function.","title":"Set the name and help"},{"location":"tutorial/subcommands/name-and-help/#name-and-help-in-typertyper","text":"You could have all the callbacks and overrides we defined before, but the name and help text was inferred from the function name and docstring. If you set it explicitly, that takes precedence over inferring. You can set it when creating a new typer.Typer() : import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback , name = \"exp-users\" , help = \"Explicit help.\" ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users ) @users_app . callback () def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () Info The rest of the callbacks and overrides are there only to show you that they don't affect the name and help text when you set it explicitly. We set an explicit name exp-users , and an explicit help Explicit help. . So that will take precedence now. Check it: // Check the main help $ python main.py --help // Notice the command name is exp-users and the help text is \"Explicit help.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: exp-users Explicit help. // Check the help for the exp-users command $ python main.py exp-users --help // Notice the main help text Usage: main.py exp-users [OPTIONS] COMMAND [ARGS]... Explicit help. Options: --help Show this message and exit. Commands: create","title":"Name and help in typer.Typer()"},{"location":"tutorial/subcommands/name-and-help/#name-and-help-in-appcallback","text":"Any parameter that you use when creating a typer.Typer() app can be overridden in the parameters of @app.callback() . Continuing with the previous example, we now override the values in @user_app.callback() : import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback , name = \"exp-users\" , help = \"Explicit help.\" ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users ) @users_app . callback ( \"call-users\" , help = \"Help from callback for users.\" ) def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () And now the command name will be call-users and the help text will be Help from callback for users. . Check it: // Check the help $ python main.py --help // The command name now is call-users and the help text is \"Help from callback for users.\". Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: call-users Help from callback for users. // Check the call-users command help $ python main.py call-users --help // Notice the main help text Usage: main.py call-users [OPTIONS] COMMAND [ARGS]... Help from callback for users. Options: --help Show this message and exit. Commands: create","title":"Name and help in @app.callback()"},{"location":"tutorial/subcommands/name-and-help/#name-and-help-in-appadd_typer","text":"And finally, with the highest priority, you can override all that by explicitly setting the name and help in app.add_typer() , just like we did on the first example above: import typer app = typer . Typer () def old_callback (): \"\"\" Old callback help. \"\"\" users_app = typer . Typer ( callback = old_callback , name = \"exp-users\" , help = \"Explicit help.\" ) def new_users (): \"\"\" I have the highland! Create some users. \"\"\" app . add_typer ( users_app , callback = new_users , name = \"cake-sith-users\" , help = \"Unlimited powder! Eh, users.\" , ) @users_app . callback ( \"call-users\" , help = \"Help from callback for users.\" ) def users (): \"\"\" Manage users in the app. \"\"\" @users_app . command () def create ( name : str ): typer . echo ( f \"Creating user: { name } \" ) if __name__ == \"__main__\" : app () And now, with the highest priorities of them all, the command name will now be cake-sith-users and the help text will be Unlimited powder! Eh, users. . Check it: // Check the help $ python main.py --help // Notice the command name cake-sith-users and the new help text \"Unlimited powder! Eh, users.\" Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: cake-sith-users Unlimited powder! Eh, users. // And check the help for the command cake-sith-users $ python main.py cake-sith-users --help // Notice the main help text Usage: main.py cake-sith-users [OPTIONS] COMMAND [ARGS]... Unlimited powder! Eh, users. Options: --help Show this message and exit. Commands: create","title":"Name and help in app.add_typer()"},{"location":"tutorial/subcommands/name-and-help/#recap","text":"The precedence to generate a command's name and help, from lowest priority to highest, is: Implicitly inferred from sub_app = typer.Typer(callback=some_function) Implicitly inferred from the callback function under @sub_app.callback() Implicitly inferred from app.add_typer(sub_app, callback=some_function) Explicitly set on sub_app = typer.Typer(name=\"some-name\", help=\"Some help.\") Explicitly set on @sub_app.callback(\"some-name\", help=\"Some help.\") Explicitly set on app.add_typer(sub_app, name=\"some-name\", help=\"Some help.\") So, app.add_typer(sub_app, name=\"some-name\", help=\"Some help.\") always wins.","title":"Recap"},{"location":"tutorial/subcommands/nested-subcommands/","text":"We'll now see how these same ideas can be extended for deeply nested commands. Let's imagine that the same CLI program from the previous examples now needs to handle lands . But a land could be a reign or town . And each of those could have their own commands, like create and delete . A CLI app for reigns \u00b6 Let's start with a file reigns.py : import typer app = typer . Typer () @app . command () def conquer ( name : str ): typer . echo ( f \"Conquering reign: { name } \" ) @app . command () def destroy ( name : str ): typer . echo ( f \"Destroying reign: { name } \" ) if __name__ == \"__main__\" : app () This is already a simple CLI program to manage reigns: // Check the help $ python reigns.py --help Usage: reigns.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: conquer destroy // Try it $ python reigns.py conquer Cintra Conquering reign: Cintra $ python reigns.py destroy Mordor Destroying reign: Mordor A CLI app for towns \u00b6 And now the equivalent for managing towns in towns.py : import typer app = typer . Typer () @app . command () def found ( name : str ): typer . echo ( f \"Founding town: { name } \" ) @app . command () def burn ( name : str ): typer . echo ( f \"Burning town: { name } \" ) if __name__ == \"__main__\" : app () With it, you can manage towns: // Check the help $ python towns.py --help Usage: towns.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: burn found // Try it $ python towns.py found \"New Asgard\" Founding town: New Asgard $ python towns.py burn Vizima Burning town: Vizima Manage the land in a CLI app \u00b6 Now let's put the reigns and towns together in the same CLI program in lands.py : import typer import reigns import towns app = typer . Typer () app . add_typer ( reigns . app , name = \"reigns\" ) app . add_typer ( towns . app , name = \"towns\" ) if __name__ == \"__main__\" : app () And now we have a single CLI program with a command (or command group) reigns that has its own commands. And another command towns with its own subcommands. Check it: // Check the help $ python lands.py --help Usage: lands.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: reigns towns // We still have the help for reigns $ python lands.py reigns --help Usage: lands.py reigns [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: conquer destroy // And the help for towns $ python lands.py towns --help Usage: lands.py towns [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: burn found Now try it, manage the lands through the CLI: // Try the reigns command $ python lands.py reigns conquer Gondor Conquering reign: Gondor $ python lands.py reigns destroy Nilfgaard Destroying reign: Nilfgaard // Try the towns command $ python lands.py towns found Springfield Founding town: Springfield $ python lands.py towns burn Atlantis Burning town: Atlantis Deeply nested subcommands \u00b6 Now let's say that all these commands in the lands.py CLI program should be part of the previous CLI program we built in the first example. We want our CLI program to have these commands/command groups: users : create delete items : create delete sell lands : reigns : conquer destroy towns : found burn This already is a quite deeply nested \"tree\" of commands/command groups. But to achieve that, we just have to add the lands Typer app to the same main.py file we already had: import typer import items import lands import users app = typer . Typer () app . add_typer ( users . app , name = \"users\" ) app . add_typer ( items . app , name = \"items\" ) app . add_typer ( lands . app , name = \"lands\" ) if __name__ == \"__main__\" : app () And now we have everything in a single CLI program : // Check the main help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: items lands users // Try some users commands $ python main.py users create Camila Creating user: Camila // Now try some items commands $ python main.py items create Sword Creating item: Sword // And now some lands commands for reigns $ python main.py lands reigns conquer Gondor Conquering reign: Gondor // And for towns $ python main.py lands towns found Cartagena Founding town: Cartagena Review the files \u00b6 Here are all the files if you want to review/copy them: reigns.py : import typer app = typer . Typer () @app . command () def conquer ( name : str ): typer . echo ( f \"Conquering reign: { name } \" ) @app . command () def destroy ( name : str ): typer . echo ( f \"Destroying reign: { name } \" ) if __name__ == \"__main__\" : app () towns.py : import typer app = typer . Typer () @app . command () def found ( name : str ): typer . echo ( f \"Founding town: { name } \" ) @app . command () def burn ( name : str ): typer . echo ( f \"Burning town: { name } \" ) if __name__ == \"__main__\" : app () lands.py : import typer import reigns import towns app = typer . Typer () app . add_typer ( reigns . app , name = \"reigns\" ) app . add_typer ( towns . app , name = \"towns\" ) if __name__ == \"__main__\" : app () users.py : import typer app = typer . Typer () @app . command () def create ( user_name : str ): typer . echo ( f \"Creating user: { user_name } \" ) @app . command () def delete ( user_name : str ): typer . echo ( f \"Deleting user: { user_name } \" ) if __name__ == \"__main__\" : app () items.py : import typer app = typer . Typer () @app . command () def create ( item : str ): typer . echo ( f \"Creating item: { item } \" ) @app . command () def delete ( item : str ): typer . echo ( f \"Deleting item: { item } \" ) @app . command () def sell ( item : str ): typer . echo ( f \"Selling item: { item } \" ) if __name__ == \"__main__\" : app () main.py : import typer import items import lands import users app = typer . Typer () app . add_typer ( users . app , name = \"users\" ) app . add_typer ( items . app , name = \"items\" ) app . add_typer ( lands . app , name = \"lands\" ) if __name__ == \"__main__\" : app () Tip All these files have an if __name__ == \"__main__\" block just to demonstrate how each of them can also be an independent CLI app . But for your final application, only main.py would need it. Recap \u00b6 That's it, you can just add Typer applications one inside another as much as you want and create complex CLI programs while writing simple code. You can probably achieve a simpler CLI program design that's easier to use than the example here. But if your requirements are complex, Typer helps you build your CLI app easily. Tip Auto completion helps a lot, specially with complex programs. Check the docs about adding auto completion to your CLI apps .","title":"Nested SubCommands"},{"location":"tutorial/subcommands/nested-subcommands/#a-cli-app-for-reigns","text":"Let's start with a file reigns.py : import typer app = typer . Typer () @app . command () def conquer ( name : str ): typer . echo ( f \"Conquering reign: { name } \" ) @app . command () def destroy ( name : str ): typer . echo ( f \"Destroying reign: { name } \" ) if __name__ == \"__main__\" : app () This is already a simple CLI program to manage reigns: // Check the help $ python reigns.py --help Usage: reigns.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: conquer destroy // Try it $ python reigns.py conquer Cintra Conquering reign: Cintra $ python reigns.py destroy Mordor Destroying reign: Mordor","title":"A CLI app for reigns"},{"location":"tutorial/subcommands/nested-subcommands/#a-cli-app-for-towns","text":"And now the equivalent for managing towns in towns.py : import typer app = typer . Typer () @app . command () def found ( name : str ): typer . echo ( f \"Founding town: { name } \" ) @app . command () def burn ( name : str ): typer . echo ( f \"Burning town: { name } \" ) if __name__ == \"__main__\" : app () With it, you can manage towns: // Check the help $ python towns.py --help Usage: towns.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: burn found // Try it $ python towns.py found \"New Asgard\" Founding town: New Asgard $ python towns.py burn Vizima Burning town: Vizima","title":"A CLI app for towns"},{"location":"tutorial/subcommands/nested-subcommands/#manage-the-land-in-a-cli-app","text":"Now let's put the reigns and towns together in the same CLI program in lands.py : import typer import reigns import towns app = typer . Typer () app . add_typer ( reigns . app , name = \"reigns\" ) app . add_typer ( towns . app , name = \"towns\" ) if __name__ == \"__main__\" : app () And now we have a single CLI program with a command (or command group) reigns that has its own commands. And another command towns with its own subcommands. Check it: // Check the help $ python lands.py --help Usage: lands.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: reigns towns // We still have the help for reigns $ python lands.py reigns --help Usage: lands.py reigns [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: conquer destroy // And the help for towns $ python lands.py towns --help Usage: lands.py towns [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: burn found Now try it, manage the lands through the CLI: // Try the reigns command $ python lands.py reigns conquer Gondor Conquering reign: Gondor $ python lands.py reigns destroy Nilfgaard Destroying reign: Nilfgaard // Try the towns command $ python lands.py towns found Springfield Founding town: Springfield $ python lands.py towns burn Atlantis Burning town: Atlantis","title":"Manage the land in a CLI app"},{"location":"tutorial/subcommands/nested-subcommands/#deeply-nested-subcommands","text":"Now let's say that all these commands in the lands.py CLI program should be part of the previous CLI program we built in the first example. We want our CLI program to have these commands/command groups: users : create delete items : create delete sell lands : reigns : conquer destroy towns : found burn This already is a quite deeply nested \"tree\" of commands/command groups. But to achieve that, we just have to add the lands Typer app to the same main.py file we already had: import typer import items import lands import users app = typer . Typer () app . add_typer ( users . app , name = \"users\" ) app . add_typer ( items . app , name = \"items\" ) app . add_typer ( lands . app , name = \"lands\" ) if __name__ == \"__main__\" : app () And now we have everything in a single CLI program : // Check the main help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: items lands users // Try some users commands $ python main.py users create Camila Creating user: Camila // Now try some items commands $ python main.py items create Sword Creating item: Sword // And now some lands commands for reigns $ python main.py lands reigns conquer Gondor Conquering reign: Gondor // And for towns $ python main.py lands towns found Cartagena Founding town: Cartagena","title":"Deeply nested subcommands"},{"location":"tutorial/subcommands/nested-subcommands/#review-the-files","text":"Here are all the files if you want to review/copy them: reigns.py : import typer app = typer . Typer () @app . command () def conquer ( name : str ): typer . echo ( f \"Conquering reign: { name } \" ) @app . command () def destroy ( name : str ): typer . echo ( f \"Destroying reign: { name } \" ) if __name__ == \"__main__\" : app () towns.py : import typer app = typer . Typer () @app . command () def found ( name : str ): typer . echo ( f \"Founding town: { name } \" ) @app . command () def burn ( name : str ): typer . echo ( f \"Burning town: { name } \" ) if __name__ == \"__main__\" : app () lands.py : import typer import reigns import towns app = typer . Typer () app . add_typer ( reigns . app , name = \"reigns\" ) app . add_typer ( towns . app , name = \"towns\" ) if __name__ == \"__main__\" : app () users.py : import typer app = typer . Typer () @app . command () def create ( user_name : str ): typer . echo ( f \"Creating user: { user_name } \" ) @app . command () def delete ( user_name : str ): typer . echo ( f \"Deleting user: { user_name } \" ) if __name__ == \"__main__\" : app () items.py : import typer app = typer . Typer () @app . command () def create ( item : str ): typer . echo ( f \"Creating item: { item } \" ) @app . command () def delete ( item : str ): typer . echo ( f \"Deleting item: { item } \" ) @app . command () def sell ( item : str ): typer . echo ( f \"Selling item: { item } \" ) if __name__ == \"__main__\" : app () main.py : import typer import items import lands import users app = typer . Typer () app . add_typer ( users . app , name = \"users\" ) app . add_typer ( items . app , name = \"items\" ) app . add_typer ( lands . app , name = \"lands\" ) if __name__ == \"__main__\" : app () Tip All these files have an if __name__ == \"__main__\" block just to demonstrate how each of them can also be an independent CLI app . But for your final application, only main.py would need it.","title":"Review the files"},{"location":"tutorial/subcommands/nested-subcommands/#recap","text":"That's it, you can just add Typer applications one inside another as much as you want and create complex CLI programs while writing simple code. You can probably achieve a simpler CLI program design that's easier to use than the example here. But if your requirements are complex, Typer helps you build your CLI app easily. Tip Auto completion helps a lot, specially with complex programs. Check the docs about adding auto completion to your CLI apps .","title":"Recap"},{"location":"tutorial/subcommands/single-file/","text":"In some cases, it's possible that your application code needs to live on a single file. You can still use the same ideas: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: { item } \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: { item } \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: { item } \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: { user_name } \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: { user_name } \" ) if __name__ == \"__main__\" : app () There are several things to notice here... Apps at the top \u00b6 First, you can create typer.Typer() objects and add them to another one at the top. It doesn't have to be done after creating the subcommands: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: { item } \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: { item } \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: { item } \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: { user_name } \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: { user_name } \" ) if __name__ == \"__main__\" : app () You can add the commands (subcommands) to each typer.Typer() app later and it will still work. Function names \u00b6 As you now have subcommands like create for users and for items , you can no longer call the functions with just the name, like def create() , because they would overwrite each other. So we use longer names: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: { item } \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: { item } \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: { item } \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: { user_name } \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: { user_name } \" ) if __name__ == \"__main__\" : app () Command name \u00b6 We are naming the functions with longer names so that they don't overwrite each other. But we still want the subcommands to be create , delete , etc. To call them like: // We want this \u2714\ufe0f $ python main.py items create instead of: // We don't want this \u26d4\ufe0f $ python main.py items items-create So we pass the name we want to use for each subcommand as the function argument to the decorator: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: { item } \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: { item } \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: { item } \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: { user_name } \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: { user_name } \" ) if __name__ == \"__main__\" : app () Check it \u00b6 It still works the same: // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: items users Check the items command: // Check the help for items $ python main.py items --help // It shows its own commands (subcommands): create, delete, sell Usage: main.py items [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete sell // Try it $ python main.py items create Wand Creating item: Wand $ python main.py items sell Vase Selling item: Vase And the same for the users command: $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete // Try it $ python main.py users create Camila Creating user: Camila","title":"SubCommands in a Single File"},{"location":"tutorial/subcommands/single-file/#apps-at-the-top","text":"First, you can create typer.Typer() objects and add them to another one at the top. It doesn't have to be done after creating the subcommands: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: { item } \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: { item } \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: { item } \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: { user_name } \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: { user_name } \" ) if __name__ == \"__main__\" : app () You can add the commands (subcommands) to each typer.Typer() app later and it will still work.","title":"Apps at the top"},{"location":"tutorial/subcommands/single-file/#function-names","text":"As you now have subcommands like create for users and for items , you can no longer call the functions with just the name, like def create() , because they would overwrite each other. So we use longer names: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: { item } \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: { item } \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: { item } \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: { user_name } \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: { user_name } \" ) if __name__ == \"__main__\" : app ()","title":"Function names"},{"location":"tutorial/subcommands/single-file/#command-name","text":"We are naming the functions with longer names so that they don't overwrite each other. But we still want the subcommands to be create , delete , etc. To call them like: // We want this \u2714\ufe0f $ python main.py items create instead of: // We don't want this \u26d4\ufe0f $ python main.py items items-create So we pass the name we want to use for each subcommand as the function argument to the decorator: import typer app = typer . Typer () items_app = typer . Typer () app . add_typer ( items_app , name = \"items\" ) users_app = typer . Typer () app . add_typer ( users_app , name = \"users\" ) @items_app . command ( \"create\" ) def items_create ( item : str ): typer . echo ( f \"Creating item: { item } \" ) @items_app . command ( \"delete\" ) def items_delete ( item : str ): typer . echo ( f \"Deleting item: { item } \" ) @items_app . command ( \"sell\" ) def items_sell ( item : str ): typer . echo ( f \"Selling item: { item } \" ) @users_app . command ( \"create\" ) def users_create ( user_name : str ): typer . echo ( f \"Creating user: { user_name } \" ) @users_app . command ( \"delete\" ) def users_delete ( user_name : str ): typer . echo ( f \"Deleting user: { user_name } \" ) if __name__ == \"__main__\" : app ()","title":"Command name"},{"location":"tutorial/subcommands/single-file/#check-it","text":"It still works the same: // Check the help $ python main.py --help Usage: main.py [OPTIONS] COMMAND [ARGS]... Options: --install-completion Install completion for the current shell. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show this message and exit. Commands: items users Check the items command: // Check the help for items $ python main.py items --help // It shows its own commands (subcommands): create, delete, sell Usage: main.py items [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete sell // Try it $ python main.py items create Wand Creating item: Wand $ python main.py items sell Vase Selling item: Vase And the same for the users command: $ python main.py users --help Usage: main.py users [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: create delete // Try it $ python main.py users create Camila Creating user: Camila","title":"Check it"}]}